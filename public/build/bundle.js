
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function (exports) {
    'use strict';

    function noop$4() { }
    const identity$a = x => x;
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$4;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now$1 = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$4;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                else
                    this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active$1 = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active$1 += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active$1 -= deleted;
            if (!active$1)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active$1)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch$1(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity$a, tick = noop$4, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now$1() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch$1(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch$1(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity$a, tick = noop$4, css } = config || null_transition;
            const program = {
                start: now$1() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch$1(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch$1(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch$1(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$4,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$4;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function cubicOut$1(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$a } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut$1, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$4) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$4) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$4;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    // User interface store objects


    const ui = writable({
        page:               null,
        state: {
            actionVis:  {
                act:                'intro',
                scene:              0,
                nodes:  {
                    force:          'cluster-center',
                    focusArea:      null,
                    base:           true,
                    shadow:         false,
                    arcs:           false,
                    shapes:         false,
                    symbols:        false
                },
                legend: {
                    hazards:        false,
                    approach:       false,
                    scale:          false
                }
            },
            postcards: {
                view:           'table',
                style:          'duotone',
                selectedAction: null
            }
        }, 
        el:        {},
        animation: {},
        vis: {
            nodes: {
                scales: {}
            }
        }
    });


    const data = writable({
        actions:            null,
        stakeholders:       null,
        references:         null,
        stats:              {}
    });

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

    /*!
     * GSAP 3.10.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */

    /* eslint-disable */
    var _config = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    },
        _defaults$1 = {
      duration: .5,
      overwrite: false,
      delay: 0
    },
        _suppressOverwrites$1,
        _bigNum$1 = 1e8,
        _tinyNum = 1 / _bigNum$1,
        _2PI = Math.PI * 2,
        _HALF_PI = _2PI / 4,
        _gsID = 0,
        _sqrt = Math.sqrt,
        _cos = Math.cos,
        _sin = Math.sin,
        _isString$1 = function _isString(value) {
      return typeof value === "string";
    },
        _isFunction$1 = function _isFunction(value) {
      return typeof value === "function";
    },
        _isNumber$1 = function _isNumber(value) {
      return typeof value === "number";
    },
        _isUndefined = function _isUndefined(value) {
      return typeof value === "undefined";
    },
        _isObject$1 = function _isObject(value) {
      return typeof value === "object";
    },
        _isNotFalse = function _isNotFalse(value) {
      return value !== false;
    },
        _windowExists$2 = function _windowExists() {
      return typeof window !== "undefined";
    },
        _isFuncOrString = function _isFuncOrString(value) {
      return _isFunction$1(value) || _isString$1(value);
    },
        _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
        // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
    _isArray = Array.isArray,
        _strictNumExp = /(?:-?\.?\d|\.)+/gi,
        //only numbers (including negatives and decimals) but NOT relative values.
    _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
    _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
    _relExp = /[+-]=-?[.\d]+/,
        _delimitedValueExp = /[^,'"\[\]\s]+/gi,
        // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
    _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        _globalTimeline,
        _win$3,
        _coreInitted$2,
        _doc$3,
        _globals = {},
        _installScope = {},
        _coreReady,
        _install = function _install(scope) {
      return (_installScope = _merge(scope, _globals)) && gsap$2;
    },
        _missingPlugin = function _missingPlugin(property, value) {
      return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
    },
        _warn = function _warn(message, suppress) {
      return !suppress && console.warn(message);
    },
        _addGlobal = function _addGlobal(name, obj) {
      return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
    },
        _emptyFunc = function _emptyFunc() {
      return 0;
    },
        _reservedProps = {},
        _lazyTweens = [],
        _lazyLookup = {},
        _lastRenderedFrame,
        _plugins = {},
        _effects = {},
        _nextGCFrame = 30,
        _harnessPlugins = [],
        _callbackNames = "",
        _harness = function _harness(targets) {
      var target = targets[0],
          harnessPlugin,
          i;
      _isObject$1(target) || _isFunction$1(target) || (targets = [targets]);

      if (!(harnessPlugin = (target._gsap || {}).harness)) {
        // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
        i = _harnessPlugins.length;

        while (i-- && !_harnessPlugins[i].targetTest(target)) {}

        harnessPlugin = _harnessPlugins[i];
      }

      i = targets.length;

      while (i--) {
        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
      }

      return targets;
    },
        _getCache = function _getCache(target) {
      return target._gsap || _harness(toArray(target))[0]._gsap;
    },
        _getProperty = function _getProperty(target, property, v) {
      return (v = target[property]) && _isFunction$1(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
    },
        _forEachName = function _forEachName(names, func) {
      return (names = names.split(",")).forEach(func) || names;
    },
        //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
    _round$1 = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
        _roundPrecise = function _roundPrecise(value) {
      return Math.round(value * 10000000) / 10000000 || 0;
    },
        // increased precision mostly for timing values.
    _parseRelative = function _parseRelative(start, value) {
      var operator = value.charAt(0),
          end = parseFloat(value.substr(2));
      start = parseFloat(start);
      return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
    },
        _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
      //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
      var l = toFind.length,
          i = 0;

      for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

      return i < l;
    },
        _lazyRender = function _lazyRender() {
      var l = _lazyTweens.length,
          a = _lazyTweens.slice(0),
          i,
          tween;

      _lazyLookup = {};
      _lazyTweens.length = 0;

      for (i = 0; i < l; i++) {
        tween = a[i];
        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
      }
    },
        _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
      _lazyTweens.length && _lazyRender();
      animation.render(time, suppressEvents, force);
      _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
    },
        _numericIfPossible = function _numericIfPossible(value) {
      var n = parseFloat(value);
      return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString$1(value) ? value.trim() : value;
    },
        _passThrough$1 = function _passThrough(p) {
      return p;
    },
        _setDefaults$1 = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }

      return obj;
    },
        _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
      return function (obj, defaults) {
        for (var p in defaults) {
          p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
        }
      };
    },
        _merge = function _merge(base, toMerge) {
      for (var p in toMerge) {
        base[p] = toMerge[p];
      }

      return base;
    },
        _mergeDeep = function _mergeDeep(base, toMerge) {
      for (var p in toMerge) {
        p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject$1(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
      }

      return base;
    },
        _copyExcluding = function _copyExcluding(obj, excluding) {
      var copy = {},
          p;

      for (p in obj) {
        p in excluding || (copy[p] = obj[p]);
      }

      return copy;
    },
        _inheritDefaults = function _inheritDefaults(vars) {
      var parent = vars.parent || _globalTimeline,
          func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults$1;

      if (_isNotFalse(vars.inherit)) {
        while (parent) {
          func(vars, parent.vars.defaults);
          parent = parent.parent || parent._dp;
        }
      }

      return vars;
    },
        _arraysMatch = function _arraysMatch(a1, a2) {
      var i = a1.length,
          match = i === a2.length;

      while (match && i-- && a1[i] === a2[i]) {}

      return i < 0;
    },
        _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }

      if (lastProp === void 0) {
        lastProp = "_last";
      }

      var prev = parent[lastProp],
          t;

      if (sortBy) {
        t = child[sortBy];

        while (prev && prev[sortBy] > t) {
          prev = prev._prev;
        }
      }

      if (prev) {
        child._next = prev._next;
        prev._next = child;
      } else {
        child._next = parent[firstProp];
        parent[firstProp] = child;
      }

      if (child._next) {
        child._next._prev = child;
      } else {
        parent[lastProp] = child;
      }

      child._prev = prev;
      child.parent = child._dp = parent;
      return child;
    },
        _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }

      if (lastProp === void 0) {
        lastProp = "_last";
      }

      var prev = child._prev,
          next = child._next;

      if (prev) {
        prev._next = next;
      } else if (parent[firstProp] === child) {
        parent[firstProp] = next;
      }

      if (next) {
        next._prev = prev;
      } else if (parent[lastProp] === child) {
        parent[lastProp] = prev;
      }

      child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
    },
        _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
      child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
      child._act = 0;
    },
        _uncache = function _uncache(animation, child) {
      if (animation && (!child || child._end > animation._dur || child._start < 0)) {
        // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
        var a = animation;

        while (a) {
          a._dirty = 1;
          a = a.parent;
        }
      }

      return animation;
    },
        _recacheAncestors = function _recacheAncestors(animation) {
      var parent = animation.parent;

      while (parent && parent.parent) {
        //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
        parent._dirty = 1;
        parent.totalDuration();
        parent = parent.parent;
      }

      return animation;
    },
        _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
      return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
    },
        _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
      return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
    },
        // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
    _animationCycle = function _animationCycle(tTime, cycleDuration) {
      var whole = Math.floor(tTime /= cycleDuration);
      return tTime && whole === tTime ? whole - 1 : whole;
    },
        _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
      return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
    },
        _setEnd = function _setEnd(animation) {
      return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
    },
        _alignPlayhead = function _alignPlayhead(animation, totalTime) {
      // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
      var parent = animation._dp;

      if (parent && parent.smoothChildTiming && animation._ts) {
        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

        _setEnd(animation);

        parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
      }

      return animation;
    },

    /*
    _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
    	let cycleDuration = duration + repeatDelay,
    		time = _round(clampedTotalTime % cycleDuration);
    	if (time > duration) {
    		time = duration;
    	}
    	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
    },
    */
    _postAddChecks = function _postAddChecks(timeline, child) {
      var t;

      if (child._time || child._initted && !child._dur) {
        //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
        t = _parentToChildTotalTime(timeline.rawTime(), child);

        if (!child._dur || _clamp$1(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
          child.render(t, true);
        }
      } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


      if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
        //in case any of the ancestors had completed but should now be enabled...
        if (timeline._dur < timeline.duration()) {
          t = timeline;

          while (t._dp) {
            t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

            t = t._dp;
          }
        }

        timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
      }
    },
        _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
      child.parent && _removeFromParent(child);
      child._start = _roundPrecise((_isNumber$1(position) ? position : position || timeline !== _globalTimeline ? _parsePosition$1(timeline, position, child) : timeline._time) + child._delay);
      child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

      _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

      _isFromOrFromStart(child) || (timeline._recent = child);
      skipChecks || _postAddChecks(timeline, child);
      return timeline;
    },
        _scrollTrigger = function _scrollTrigger(animation, trigger) {
      return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
    },
        _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
      _initTween(tween, totalTime);

      if (!tween._initted) {
        return 1;
      }

      if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
        _lazyTweens.push(tween);

        tween._lazy = [totalTime, suppressEvents];
        return 1;
      }
    },
        _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
      var parent = _ref.parent;
      return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
    },
        // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
    _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
      var data = _ref2.data;
      return data === "isFromStart" || data === "isStart";
    },
        _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
      var prevRatio = tween.ratio,
          ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
          // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
      repeatDelay = tween._rDelay,
          tTime = 0,
          pt,
          iteration,
          prevIteration;

      if (repeatDelay && tween._repeat) {
        // in case there's a zero-duration tween that has a repeat with a repeatDelay
        tTime = _clamp$1(0, tween._tDur, totalTime);
        iteration = _animationCycle(tTime, repeatDelay);
        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
          // if iteration changed
          prevRatio = 1 - ratio;
          tween.vars.repeatRefresh && tween._initted && tween.invalidate();
        }
      }

      if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
          // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
          return;
        }

        prevIteration = tween._zTime;
        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

        tween.ratio = ratio;
        tween._from && (ratio = 1 - ratio);
        tween._time = 0;
        tween._tTime = tTime;
        pt = tween._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }

        tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
        tween._onUpdate && !suppressEvents && _callback$1(tween, "onUpdate");
        tTime && tween._repeat && !suppressEvents && tween.parent && _callback$1(tween, "onRepeat");

        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
          ratio && _removeFromParent(tween, 1);

          if (!suppressEvents) {
            _callback$1(tween, ratio ? "onComplete" : "onReverseComplete", true);

            tween._prom && tween._prom();
          }
        }
      } else if (!tween._zTime) {
        tween._zTime = totalTime;
      }
    },
        _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
      var child;

      if (time > prevTime) {
        child = animation._first;

        while (child && child._start <= time) {
          if (child.data === "isPause" && child._start > prevTime) {
            return child;
          }

          child = child._next;
        }
      } else {
        child = animation._last;

        while (child && child._start >= time) {
          if (child.data === "isPause" && child._start < prevTime) {
            return child;
          }

          child = child._prev;
        }
      }
    },
        _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
      var repeat = animation._repeat,
          dur = _roundPrecise(duration) || 0,
          totalProgress = animation._tTime / animation._tDur;
      totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
      animation._dur = dur;
      animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
      totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
      skipUncache || _uncache(animation.parent, animation);
      return animation;
    },
        _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
      return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
    },
        _zeroPosition = {
      _start: 0,
      endTime: _emptyFunc,
      totalDuration: _emptyFunc
    },
        _parsePosition$1 = function _parsePosition(animation, position, percentAnimation) {
      var labels = animation.labels,
          recent = animation._recent || _zeroPosition,
          clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur,
          //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
      i,
          offset,
          isPercent;

      if (_isString$1(position) && (isNaN(position) || position in labels)) {
        //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
        offset = position.charAt(0);
        isPercent = position.substr(-1) === "%";
        i = position.indexOf("=");

        if (offset === "<" || offset === ">") {
          i >= 0 && (position = position.replace(/=/, ""));
          return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
        }

        if (i < 0) {
          position in labels || (labels[position] = clippedDuration);
          return labels[position];
        }

        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

        if (isPercent && percentAnimation) {
          offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
        }

        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
      }

      return position == null ? clippedDuration : +position;
    },
        _createTweenType = function _createTweenType(type, params, timeline) {
      var isLegacy = _isNumber$1(params[1]),
          varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
          vars = params[varsIndex],
          irVars,
          parent;

      isLegacy && (vars.duration = params[1]);
      vars.parent = timeline;

      if (type) {
        irVars = vars;
        parent = timeline;

        while (parent && !("immediateRender" in irVars)) {
          // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
          irVars = parent.vars.defaults || {};
          parent = _isNotFalse(parent.vars.inherit) && parent.parent;
        }

        vars.immediateRender = _isNotFalse(irVars.immediateRender);
        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
      }

      return new Tween(params[0], vars, params[varsIndex + 1]);
    },
        _conditionalReturn = function _conditionalReturn(value, func) {
      return value || value === 0 ? func(value) : func;
    },
        _clamp$1 = function _clamp(min, max, value) {
      return value < min ? min : value > max ? max : value;
    },
        getUnit = function getUnit(value, v) {
      return !_isString$1(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
    },
        // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
    clamp = function clamp(min, max, value) {
      return _conditionalReturn(value, function (v) {
        return _clamp$1(min, max, v);
      });
    },
        _slice = [].slice,
        _isArrayLike = function _isArrayLike(value, nonEmpty) {
      return value && _isObject$1(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject$1(value[0])) && !value.nodeType && value !== _win$3;
    },
        _flatten = function _flatten(ar, leaveStrings, accumulator) {
      if (accumulator === void 0) {
        accumulator = [];
      }

      return ar.forEach(function (value) {
        var _accumulator;

        return _isString$1(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
      }) || accumulator;
    },
        //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
    toArray = function toArray(value, scope, leaveStrings) {
      return _isString$1(value) && !leaveStrings && (_coreInitted$2 || !_wake()) ? _slice.call((scope || _doc$3).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
    },
        selector$1 = function selector(value) {
      value = toArray(value)[0] || _warn("Invalid scope") || {};
      return function (v) {
        var el = value.current || value.nativeElement || value;
        return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$3.createElement("div") : value);
      };
    },
        shuffle$2 = function shuffle(a) {
      return a.sort(function () {
        return .5 - Math.random();
      });
    },
        // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
    //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
    distribute = function distribute(v) {
      if (_isFunction$1(v)) {
        return v;
      }

      var vars = _isObject$1(v) ? v : {
        each: v
      },
          //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
      ease = _parseEase(vars.ease),
          from = vars.from || 0,
          base = parseFloat(vars.base) || 0,
          cache = {},
          isDecimal = from > 0 && from < 1,
          ratios = isNaN(from) || isDecimal,
          axis = vars.axis,
          ratioX = from,
          ratioY = from;

      if (_isString$1(from)) {
        ratioX = ratioY = {
          center: .5,
          edges: .5,
          end: 1
        }[from] || 0;
      } else if (!isDecimal && ratios) {
        ratioX = from[0];
        ratioY = from[1];
      }

      return function (i, target, a) {
        var l = (a || vars).length,
            distances = cache[l],
            originX,
            originY,
            x,
            y,
            d,
            j,
            max,
            min,
            wrapAt;

        if (!distances) {
          wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];

          if (!wrapAt) {
            max = -_bigNum$1;

            while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

            wrapAt--;
          }

          distances = cache[l] = [];
          originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
          originY = wrapAt === _bigNum$1 ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
          max = 0;
          min = _bigNum$1;

          for (j = 0; j < l; j++) {
            x = j % wrapAt - originX;
            y = originY - (j / wrapAt | 0);
            distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
            d > max && (max = d);
            d < min && (min = d);
          }

          from === "random" && shuffle$2(distances);
          distances.max = max - min;
          distances.min = min;
          distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
          distances.b = l < 0 ? base - l : base;
          distances.u = getUnit(vars.amount || vars.each) || 0; //unit

          ease = ease && l < 0 ? _invertEase(ease) : ease;
        }

        l = (distances[i] - distances.min) / distances.max || 0;
        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
      };
    },
        _roundModifier = function _roundModifier(v) {
      //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
      var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

      return function (raw) {
        var n = Math.round(parseFloat(raw) / v) * v * p;
        return (n - n % 1) / p + (_isNumber$1(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
      };
    },
        snap = function snap(snapTo, value) {
      var isArray = _isArray(snapTo),
          radius,
          is2D;

      if (!isArray && _isObject$1(snapTo)) {
        radius = isArray = snapTo.radius || _bigNum$1;

        if (snapTo.values) {
          snapTo = toArray(snapTo.values);

          if (is2D = !_isNumber$1(snapTo[0])) {
            radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
          }
        } else {
          snapTo = _roundModifier(snapTo.increment);
        }
      }

      return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction$1(snapTo) ? function (raw) {
        is2D = snapTo(raw);
        return Math.abs(is2D - raw) <= radius ? is2D : raw;
      } : function (raw) {
        var x = parseFloat(is2D ? raw.x : raw),
            y = parseFloat(is2D ? raw.y : 0),
            min = _bigNum$1,
            closest = 0,
            i = snapTo.length,
            dx,
            dy;

        while (i--) {
          if (is2D) {
            dx = snapTo[i].x - x;
            dy = snapTo[i].y - y;
            dx = dx * dx + dy * dy;
          } else {
            dx = Math.abs(snapTo[i] - x);
          }

          if (dx < min) {
            min = dx;
            closest = i;
          }
        }

        closest = !radius || min <= radius ? snapTo[closest] : raw;
        return is2D || closest === raw || _isNumber$1(raw) ? closest : closest + getUnit(raw);
      });
    },
        random = function random(min, max, roundingIncrement, returnFunction) {
      return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
      });
    },
        pipe = function pipe() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }

      return function (value) {
        return functions.reduce(function (v, f) {
          return f(v);
        }, value);
      };
    },
        unitize = function unitize(func, unit) {
      return function (value) {
        return func(parseFloat(value)) + (unit || getUnit(value));
      };
    },
        normalize$2 = function normalize(min, max, value) {
      return mapRange(min, max, 0, 1, value);
    },
        _wrapArray = function _wrapArray(a, wrapper, value) {
      return _conditionalReturn(value, function (index) {
        return a[~~wrapper(index)];
      });
    },
        wrap = function wrap(min, max, value) {
      // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
      var range = max - min;
      return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
        return (range + (value - min) % range) % range + min;
      });
    },
        wrapYoyo = function wrapYoyo(min, max, value) {
      var range = max - min,
          total = range * 2;
      return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
        value = (total + (value - min) % total) % total || 0;
        return min + (value > range ? total - value : value);
      });
    },
        _replaceRandom = function _replaceRandom(value) {
      //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
      var prev = 0,
          s = "",
          i,
          nums,
          end,
          isArray;

      while (~(i = value.indexOf("random(", prev))) {
        end = value.indexOf(")", i);
        isArray = value.charAt(i + 7) === "[";
        nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
        s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
        prev = end + 1;
      }

      return s + value.substr(prev, value.length - prev);
    },
        mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
      var inRange = inMax - inMin,
          outRange = outMax - outMin;
      return _conditionalReturn(value, function (value) {
        return outMin + ((value - inMin) / inRange * outRange || 0);
      });
    },
        interpolate$3 = function interpolate(start, end, progress, mutate) {
      var func = isNaN(start + end) ? 0 : function (p) {
        return (1 - p) * start + p * end;
      };

      if (!func) {
        var isString = _isString$1(start),
            master = {},
            p,
            i,
            interpolators,
            l,
            il;

        progress === true && (mutate = 1) && (progress = null);

        if (isString) {
          start = {
            p: start
          };
          end = {
            p: end
          };
        } else if (_isArray(start) && !_isArray(end)) {
          interpolators = [];
          l = start.length;
          il = l - 2;

          for (i = 1; i < l; i++) {
            interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
          }

          l--;

          func = function func(p) {
            p *= l;
            var i = Math.min(il, ~~p);
            return interpolators[i](p - i);
          };

          progress = end;
        } else if (!mutate) {
          start = _merge(_isArray(start) ? [] : {}, start);
        }

        if (!interpolators) {
          for (p in end) {
            _addPropTween.call(master, start, p, "get", end[p]);
          }

          func = function func(p) {
            return _renderPropTweens(p, master) || (isString ? start.p : start);
          };
        }
      }

      return _conditionalReturn(progress, func);
    },
        _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
      //used for nextLabel() and previousLabel()
      var labels = timeline.labels,
          min = _bigNum$1,
          p,
          distance,
          label;

      for (p in labels) {
        distance = labels[p] - fromTime;

        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
          label = p;
          min = distance;
        }
      }

      return label;
    },
        _callback$1 = function _callback(animation, type, executeLazyFirst) {
      var v = animation.vars,
          callback = v[type],
          params,
          scope;

      if (!callback) {
        return;
      }

      params = v[type + "Params"];
      scope = v.callbackScope || animation;
      executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

      return params ? callback.apply(scope, params) : callback.call(scope);
    },
        _interrupt = function _interrupt(animation) {
      _removeFromParent(animation);

      animation.scrollTrigger && animation.scrollTrigger.kill(false);
      animation.progress() < 1 && _callback$1(animation, "onInterrupt");
      return animation;
    },
        _quickTween,
        _createPlugin = function _createPlugin(config) {
      config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

      var name = config.name,
          isFunc = _isFunction$1(config),
          Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
          //in case someone passes in an object that's not a plugin, like CustomEase
      instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
          statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };

      _wake();

      if (config !== Plugin) {
        if (_plugins[name]) {
          return;
        }

        _setDefaults$1(Plugin, _setDefaults$1(_copyExcluding(config, instanceDefaults), statics)); //static methods


        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


        _plugins[Plugin.prop = name] = Plugin;

        if (config.targetTest) {
          _harnessPlugins.push(Plugin);

          _reservedProps[name] = 1;
        }

        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
      }

      _addGlobal(name, Plugin);

      config.register && config.register(gsap$2, Plugin, PropTween);
    },

    /*
     * --------------------------------------------------------------------------------------
     * COLORS
     * --------------------------------------------------------------------------------------
     */
    _255 = 255,
        _colorLookup = {
      aqua: [0, _255, _255],
      lime: [0, _255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _255],
      navy: [0, 0, 128],
      white: [_255, _255, _255],
      olive: [128, 128, 0],
      yellow: [_255, _255, 0],
      orange: [_255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_255, 0, 0],
      pink: [_255, 192, 203],
      cyan: [0, _255, _255],
      transparent: [_255, _255, _255, 0]
    },
        // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
    // let ctx = _doc.createElement("canvas").getContext("2d");
    // _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
    _hue = function _hue(h, m1, m2) {
      h += h < 0 ? 1 : h > 1 ? -1 : 0;
      return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
    },
        splitColor = function splitColor(v, toHSL, forceAlpha) {
      var a = !v ? _colorLookup.black : _isNumber$1(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
          r,
          g,
          b,
          h,
          s,
          l,
          max,
          min,
          d,
          wasHSL;

      if (!a) {
        if (v.substr(-1) === ",") {
          //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
          v = v.substr(0, v.length - 1);
        }

        if (_colorLookup[v]) {
          a = _colorLookup[v];
        } else if (v.charAt(0) === "#") {
          if (v.length < 6) {
            //for shorthand like #9F0 or #9F0F (could have alpha)
            r = v.charAt(1);
            g = v.charAt(2);
            b = v.charAt(3);
            v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
          }

          if (v.length === 9) {
            // hex with alpha, like #fd5e53ff
            a = parseInt(v.substr(1, 6), 16);
            return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
          }

          v = parseInt(v.substr(1), 16);
          a = [v >> 16, v >> 8 & _255, v & _255];
        } else if (v.substr(0, 3) === "hsl") {
          a = wasHSL = v.match(_strictNumExp);

          if (!toHSL) {
            h = +a[0] % 360 / 360;
            s = +a[1] / 100;
            l = +a[2] / 100;
            g = l <= .5 ? l * (s + 1) : l + s - l * s;
            r = l * 2 - g;
            a.length > 3 && (a[3] *= 1); //cast as number

            a[0] = _hue(h + 1 / 3, r, g);
            a[1] = _hue(h, r, g);
            a[2] = _hue(h - 1 / 3, r, g);
          } else if (~v.indexOf("=")) {
            //if relative values are found, just return the raw strings with the relative prefixes in place.
            a = v.match(_numExp);
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
          }
        } else {
          a = v.match(_strictNumExp) || _colorLookup.transparent;
        }

        a = a.map(Number);
      }

      if (toHSL && !wasHSL) {
        r = a[0] / _255;
        g = a[1] / _255;
        b = a[2] / _255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        l = (max + min) / 2;

        if (max === min) {
          h = s = 0;
        } else {
          d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h *= 60;
        }

        a[0] = ~~(h + .5);
        a[1] = ~~(s * 100 + .5);
        a[2] = ~~(l * 100 + .5);
      }

      forceAlpha && a.length < 4 && (a[3] = 1);
      return a;
    },
        _colorOrderData = function _colorOrderData(v) {
      // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
      var values = [],
          c = [],
          i = -1;
      v.split(_colorExp).forEach(function (v) {
        var a = v.match(_numWithUnitExp) || [];
        values.push.apply(values, a);
        c.push(i += a.length + 1);
      });
      values.c = c;
      return values;
    },
        _formatColors = function _formatColors(s, toHSL, orderMatchData) {
      var result = "",
          colors = (s + result).match(_colorExp),
          type = toHSL ? "hsla(" : "rgba(",
          i = 0,
          c,
          shell,
          d,
          l;

      if (!colors) {
        return s;
      }

      colors = colors.map(function (color) {
        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
      });

      if (orderMatchData) {
        d = _colorOrderData(s);
        c = orderMatchData.c;

        if (c.join(result) !== d.c.join(result)) {
          shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
          l = shell.length - 1;

          for (; i < l; i++) {
            result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
          }
        }
      }

      if (!shell) {
        shell = s.split(_colorExp);
        l = shell.length - 1;

        for (; i < l; i++) {
          result += shell[i] + colors[i];
        }
      }

      return result + shell[l];
    },
        _colorExp = function () {
      var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
          //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
      p;

      for (p in _colorLookup) {
        s += "|" + p + "\\b";
      }

      return new RegExp(s + ")", "gi");
    }(),
        _hslExp = /hsl[a]?\(/,
        _colorStringFilter = function _colorStringFilter(a) {
      var combined = a.join(" "),
          toHSL;
      _colorExp.lastIndex = 0;

      if (_colorExp.test(combined)) {
        toHSL = _hslExp.test(combined);
        a[1] = _formatColors(a[1], toHSL);
        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

        return true;
      }
    },

    /*
     * --------------------------------------------------------------------------------------
     * TICKER
     * --------------------------------------------------------------------------------------
     */
    _tickerActive,
        _ticker = function () {
      var _getTime = Date.now,
          _lagThreshold = 500,
          _adjustedLag = 33,
          _startTime = _getTime(),
          _lastUpdate = _startTime,
          _gap = 1000 / 240,
          _nextTime = _gap,
          _listeners = [],
          _id,
          _req,
          _raf,
          _self,
          _delta,
          _i,
          _tick = function _tick(v) {
        var elapsed = _getTime() - _lastUpdate,
            manual = v === true,
            overlap,
            dispatch,
            time,
            frame;

        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;

        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1000;
          _self.time = time = time / 1000;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }

        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

        if (dispatch) {
          for (_i = 0; _i < _listeners.length; _i++) {
            // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
            _listeners[_i](time, _delta, frame, v);
          }
        }
      };

      _self = {
        time: 0,
        frame: 0,
        tick: function tick() {
          _tick(true);
        },
        deltaRatio: function deltaRatio(fps) {
          return _delta / (1000 / (fps || 60));
        },
        wake: function wake() {
          if (_coreReady) {
            if (!_coreInitted$2 && _windowExists$2()) {
              _win$3 = _coreInitted$2 = window;
              _doc$3 = _win$3.document || {};
              _globals.gsap = gsap$2;
              (_win$3.gsapVersions || (_win$3.gsapVersions = [])).push(gsap$2.version);

              _install(_installScope || _win$3.GreenSockGlobals || !_win$3.gsap && _win$3 || {});

              _raf = _win$3.requestAnimationFrame;
            }

            _id && _self.sleep();

            _req = _raf || function (f) {
              return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
            };

            _tickerActive = 1;

            _tick(2);
          }
        },
        sleep: function sleep() {
          (_raf ? _win$3.cancelAnimationFrame : clearTimeout)(_id);
          _tickerActive = 0;
          _req = _emptyFunc;
        },
        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
          _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

          _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
        },
        fps: function fps(_fps) {
          _gap = 1000 / (_fps || 240);
          _nextTime = _self.time * 1000 + _gap;
        },
        add: function add(callback, once, prioritize) {
          var func = once ? function (t, d, f, v) {
            callback(t, d, f, v);

            _self.remove(func);
          } : callback;

          _self.remove(callback);

          _listeners[prioritize ? "unshift" : "push"](func);

          _wake();

          return func;
        },
        remove: function remove(callback, i) {
          ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
        },
        _listeners: _listeners
      };
      return _self;
    }(),
        _wake = function _wake() {
      return !_tickerActive && _ticker.wake();
    },
        //also ensures the core classes are initialized.

    /*
    * -------------------------------------------------
    * EASING
    * -------------------------------------------------
    */
    _easeMap = {},
        _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
        _quotesExp = /["']/g,
        _parseObjectInString = function _parseObjectInString(value) {
      //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
      var obj = {},
          split = value.substr(1, value.length - 3).split(":"),
          key = split[0],
          i = 1,
          l = split.length,
          index,
          val,
          parsedVal;

      for (; i < l; i++) {
        val = split[i];
        index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
        parsedVal = val.substr(0, index);
        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
        key = val.substr(index + 1).trim();
      }

      return obj;
    },
        _valueInParentheses = function _valueInParentheses(value) {
      var open = value.indexOf("(") + 1,
          close = value.indexOf(")"),
          nested = value.indexOf("(", open);
      return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
    },
        _configEaseFromString = function _configEaseFromString(name) {
      //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
      var split = (name + "").split("("),
          ease = _easeMap[split[0]];
      return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
    },
        _invertEase = function _invertEase(ease) {
      return function (p) {
        return 1 - ease(1 - p);
      };
    },
        // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
    _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
      var child = timeline._first,
          ease;

      while (child) {
        if (child instanceof Timeline) {
          _propagateYoyoEase(child, isYoyo);
        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
          if (child.timeline) {
            _propagateYoyoEase(child.timeline, isYoyo);
          } else {
            ease = child._ease;
            child._ease = child._yEase;
            child._yEase = ease;
            child._yoyo = isYoyo;
          }
        }

        child = child._next;
      }
    },
        _parseEase = function _parseEase(ease, defaultEase) {
      return !ease ? defaultEase : (_isFunction$1(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
    },
        _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
      if (easeOut === void 0) {
        easeOut = function easeOut(p) {
          return 1 - easeIn(1 - p);
        };
      }

      if (easeInOut === void 0) {
        easeInOut = function easeInOut(p) {
          return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
        };
      }

      var ease = {
        easeIn: easeIn,
        easeOut: easeOut,
        easeInOut: easeInOut
      },
          lowercaseName;

      _forEachName(names, function (name) {
        _easeMap[name] = _globals[name] = ease;
        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

        for (var p in ease) {
          _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
        }
      });

      return ease;
    },
        _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
      return function (p) {
        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
      };
    },
        _configElastic = function _configElastic(type, amplitude, period) {
      var p1 = amplitude >= 1 ? amplitude : 1,
          //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
      p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
          p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
          easeOut = function easeOut(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);

      p2 = _2PI / p2; //precalculate to optimize

      ease.config = function (amplitude, period) {
        return _configElastic(type, amplitude, period);
      };

      return ease;
    },
        _configBack = function _configBack(type, overshoot) {
      if (overshoot === void 0) {
        overshoot = 1.70158;
      }

      var easeOut = function easeOut(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);

      ease.config = function (overshoot) {
        return _configBack(type, overshoot);
      };

      return ease;
    }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
    // _weightedEase = ratio => {
    // 	let y = 0.5 + ratio / 2;
    // 	return p => (2 * (1 - p) * p * y + p * p);
    // },
    // a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
    // _weightedEaseStrong = ratio => {
    // 	ratio = .5 + ratio / 2;
    // 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
    // 		b = ratio - o,
    // 		c = ratio + o;
    // 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
    // };


    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
      var power = i < 5 ? i + 1 : i;

      _insertEase(name + ",Power" + (power - 1), i ? function (p) {
        return Math.pow(p, power);
      } : function (p) {
        return p;
      }, function (p) {
        return 1 - Math.pow(1 - p, power);
      }, function (p) {
        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
      });
    });

    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

    (function (n, c) {
      var n1 = 1 / c,
          n2 = 2 * n1,
          n3 = 2.5 * n1,
          easeOut = function easeOut(p) {
        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
      };

      _insertEase("Bounce", function (p) {
        return 1 - easeOut(1 - p);
      }, easeOut);
    })(7.5625, 2.75);

    _insertEase("Expo", function (p) {
      return p ? Math.pow(2, 10 * (p - 1)) : 0;
    });

    _insertEase("Circ", function (p) {
      return -(_sqrt(1 - p * p) - 1);
    });

    _insertEase("Sine", function (p) {
      return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
    });

    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
        if (steps === void 0) {
          steps = 1;
        }

        var p1 = 1 / steps,
            p2 = steps + (immediateStart ? 0 : 1),
            p3 = immediateStart ? 1 : 0,
            max = 1 - _tinyNum;
        return function (p) {
          return ((p2 * _clamp$1(0, max, p) | 0) + p3) * p1;
        };
      }
    };
    _defaults$1.ease = _easeMap["quad.out"];

    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
      return _callbackNames += name + "," + name + "Params,";
    });
    /*
     * --------------------------------------------------------------------------------------
     * CACHE
     * --------------------------------------------------------------------------------------
     */


    var GSCache = function GSCache(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter;
    };
    /*
     * --------------------------------------------------------------------------------------
     * ANIMATION
     * --------------------------------------------------------------------------------------
     */

    var Animation = /*#__PURE__*/function () {
      function Animation(vars) {
        this.vars = vars;
        this._delay = +vars.delay || 0;

        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
          // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
          this._rDelay = vars.repeatDelay || 0;
          this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
        }

        this._ts = 1;

        _setDuration(this, +vars.duration, 1, 1);

        this.data = vars.data;
        _tickerActive || _ticker.wake();
      }

      var _proto = Animation.prototype;

      _proto.delay = function delay(value) {
        if (value || value === 0) {
          this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
          this._delay = value;
          return this;
        }

        return this._delay;
      };

      _proto.duration = function duration(value) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
      };

      _proto.totalDuration = function totalDuration(value) {
        if (!arguments.length) {
          return this._tDur;
        }

        this._dirty = 0;
        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
      };

      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
        _wake();

        if (!arguments.length) {
          return this._tTime;
        }

        var parent = this._dp;

        if (parent && parent.smoothChildTiming && this._ts) {
          _alignPlayhead(this, _totalTime);

          !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
          //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

          while (parent && parent.parent) {
            if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
              parent.totalTime(parent._tTime, true);
            }

            parent = parent.parent;
          }

          if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
            //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
            _addToTimeline(this._dp, this, this._start - this._delay);
          }
        }

        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
          // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
          this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
          //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
          //   this._lock = 1;

          _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
          //}

        }

        return this;
      };

      _proto.time = function time(value, suppressEvents) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
      };

      _proto.totalProgress = function totalProgress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
      };

      _proto.progress = function progress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
      };

      _proto.iteration = function iteration(value, suppressEvents) {
        var cycleDuration = this.duration() + this._rDelay;

        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
      } // potential future addition:
      // isPlayingBackwards() {
      // 	let animation = this,
      // 		orientation = 1; // 1 = forward, -1 = backward
      // 	while (animation) {
      // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
      // 		animation = animation.parent;
      // 	}
      // 	return orientation < 0;
      // }
      ;

      _proto.timeScale = function timeScale(value) {
        if (!arguments.length) {
          return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
        }

        if (this._rts === value) {
          return this;
        }

        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
        // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
        //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
        // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

        this._rts = +value || 0;
        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

        this.totalTime(_clamp$1(-this._delay, this._tDur, tTime), true);

        _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


        return _recacheAncestors(this);
      };

      _proto.paused = function paused(value) {
        if (!arguments.length) {
          return this._ps;
        }

        if (this._ps !== value) {
          this._ps = value;

          if (value) {
            this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

            this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
          } else {
            _wake();

            this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
          }
        }

        return this;
      };

      _proto.startTime = function startTime(value) {
        if (arguments.length) {
          this._start = value;
          var parent = this.parent || this._dp;
          parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
          return this;
        }

        return this._start;
      };

      _proto.endTime = function endTime(includeRepeats) {
        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
      };

      _proto.rawTime = function rawTime(wrapRepeats) {
        var parent = this.parent || this._dp; // _dp = detached parent

        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
      };

      _proto.globalTime = function globalTime(rawTime) {
        var animation = this,
            time = arguments.length ? rawTime : animation.rawTime();

        while (animation) {
          time = animation._start + time / (animation._ts || 1);
          animation = animation._dp;
        }

        return time;
      };

      _proto.repeat = function repeat(value) {
        if (arguments.length) {
          this._repeat = value === Infinity ? -2 : value;
          return _onUpdateTotalDuration(this);
        }

        return this._repeat === -2 ? Infinity : this._repeat;
      };

      _proto.repeatDelay = function repeatDelay(value) {
        if (arguments.length) {
          var time = this._time;
          this._rDelay = value;

          _onUpdateTotalDuration(this);

          return time ? this.time(time) : this;
        }

        return this._rDelay;
      };

      _proto.yoyo = function yoyo(value) {
        if (arguments.length) {
          this._yoyo = value;
          return this;
        }

        return this._yoyo;
      };

      _proto.seek = function seek(position, suppressEvents) {
        return this.totalTime(_parsePosition$1(this, position), _isNotFalse(suppressEvents));
      };

      _proto.restart = function restart(includeDelay, suppressEvents) {
        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      };

      _proto.play = function play(from, suppressEvents) {
        from != null && this.seek(from, suppressEvents);
        return this.reversed(false).paused(false);
      };

      _proto.reverse = function reverse(from, suppressEvents) {
        from != null && this.seek(from || this.totalDuration(), suppressEvents);
        return this.reversed(true).paused(false);
      };

      _proto.pause = function pause(atTime, suppressEvents) {
        atTime != null && this.seek(atTime, suppressEvents);
        return this.paused(true);
      };

      _proto.resume = function resume() {
        return this.paused(false);
      };

      _proto.reversed = function reversed(value) {
        if (arguments.length) {
          !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

          return this;
        }

        return this._rts < 0;
      };

      _proto.invalidate = function invalidate() {
        this._initted = this._act = 0;
        this._zTime = -_tinyNum;
        return this;
      };

      _proto.isActive = function isActive() {
        var parent = this.parent || this._dp,
            start = this._start,
            rawTime;
        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
      };

      _proto.eventCallback = function eventCallback(type, callback, params) {
        var vars = this.vars;

        if (arguments.length > 1) {
          if (!callback) {
            delete vars[type];
          } else {
            vars[type] = callback;
            params && (vars[type + "Params"] = params);
            type === "onUpdate" && (this._onUpdate = callback);
          }

          return this;
        }

        return vars[type];
      };

      _proto.then = function then(onFulfilled) {
        var self = this;
        return new Promise(function (resolve) {
          var f = _isFunction$1(onFulfilled) ? onFulfilled : _passThrough$1,
              _resolve = function _resolve() {
            var _then = self.then;
            self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

            _isFunction$1(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
            resolve(f);
            self.then = _then;
          };

          if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
            _resolve();
          } else {
            self._prom = _resolve;
          }
        });
      };

      _proto.kill = function kill() {
        _interrupt(this);
      };

      return Animation;
    }();

    _setDefaults$1(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
    /*
     * -------------------------------------------------
     * TIMELINE
     * -------------------------------------------------
     */


    var Timeline = /*#__PURE__*/function (_Animation) {
      _inheritsLoose(Timeline, _Animation);

      function Timeline(vars, position) {
        var _this;

        if (vars === void 0) {
          vars = {};
        }

        _this = _Animation.call(this, vars) || this;
        _this.labels = {};
        _this.smoothChildTiming = !!vars.smoothChildTiming;
        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
        _this._sort = _isNotFalse(vars.sortChildren);
        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
        vars.reversed && _this.reverse();
        vars.paused && _this.paused(true);
        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
        return _this;
      }

      var _proto2 = Timeline.prototype;

      _proto2.to = function to(targets, vars, position) {
        _createTweenType(0, arguments, this);

        return this;
      };

      _proto2.from = function from(targets, vars, position) {
        _createTweenType(1, arguments, this);

        return this;
      };

      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
        _createTweenType(2, arguments, this);

        return this;
      };

      _proto2.set = function set(targets, vars, position) {
        vars.duration = 0;
        vars.parent = this;
        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
        vars.immediateRender = !!vars.immediateRender;
        new Tween(targets, vars, _parsePosition$1(this, position), 1);
        return this;
      };

      _proto2.call = function call(callback, params, position) {
        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
      } //ONLY for backward compatibility! Maybe delete?
      ;

      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.duration = duration;
        vars.stagger = vars.stagger || stagger;
        vars.onComplete = onCompleteAll;
        vars.onCompleteParams = onCompleteAllParams;
        vars.parent = this;
        new Tween(targets, vars, _parsePosition$1(this, position));
        return this;
      };

      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.runBackwards = 1;
        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
      };

      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
        toVars.startAt = fromVars;
        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
      };

      _proto2.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._dirty ? this.totalDuration() : this._tDur,
            dur = this._dur,
            tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
            // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
            time,
            child,
            next,
            iteration,
            cycleDuration,
            prevPaused,
            pauseTween,
            timeScale,
            prevStart,
            prevIteration,
            yoyo,
            isYoyo;
        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

        if (tTime !== this._tTime || force || crossingStart) {
          if (prevTime !== this._time && dur) {
            //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
            tTime += this._time - prevTime;
            totalTime += this._time - prevTime;
          }

          time = tTime;
          prevStart = this._start;
          timeScale = this._ts;
          prevPaused = !timeScale;

          if (crossingStart) {
            dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

            (totalTime || !suppressEvents) && (this._zTime = totalTime);
          }

          if (this._repeat) {
            //adjust the time for repeats and yoyos
            yoyo = this._yoyo;
            cycleDuration = dur + this._rDelay;

            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }

            time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

            if (tTime === tDur) {
              // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);

              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }

              time > dur && (time = dur);
            }

            prevIteration = _animationCycle(this._tTime, cycleDuration);
            !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

            if (yoyo && iteration & 1) {
              time = dur - time;
              isYoyo = 1;
            }
            /*
            make sure children at the end/beginning of the timeline are rendered properly. If, for example,
            a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
            would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
            could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
            we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
            ensure that zero-duration tweens at the very beginning or end of the Timeline work.
            */


            if (iteration !== prevIteration && !this._lock) {
              var rewinding = yoyo && prevIteration & 1,
                  doesWrap = rewinding === (yoyo && iteration & 1);
              iteration < prevIteration && (rewinding = !rewinding);
              prevTime = rewinding ? 0 : dur;
              this._lock = 1;
              this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
              this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

              !suppressEvents && this.parent && _callback$1(this, "onRepeat");
              this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

              if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
                return this;
              }

              dur = this._dur; // in case the duration changed in the onRepeat

              tDur = this._tDur;

              if (doesWrap) {
                this._lock = 2;
                prevTime = rewinding ? dur : -0.0001;
                this.render(prevTime, true);
                this.vars.repeatRefresh && !isYoyo && this.invalidate();
              }

              this._lock = 0;

              if (!this._ts && !prevPaused) {
                return this;
              } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


              _propagateYoyoEase(this, isYoyo);
            }
          }

          if (this._hasPause && !this._forcing && this._lock < 2) {
            pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

            if (pauseTween) {
              tTime -= time - (time = pauseTween._start);
            }
          }

          this._tTime = tTime;
          this._time = time;
          this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

          if (!this._initted) {
            this._onUpdate = this.vars.onUpdate;
            this._initted = 1;
            this._zTime = totalTime;
            prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
          }

          if (!prevTime && time && !suppressEvents) {
            _callback$1(this, "onStart");

            if (this._tTime !== tTime) {
              // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
              return this;
            }
          }

          if (time >= prevTime && totalTime >= 0) {
            child = this._first;

            while (child) {
              next = child._next;

              if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                  return this.render(totalTime, suppressEvents, force);
                }

                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

                if (time !== this._time || !this._ts && !prevPaused) {
                  //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                  pauseTween = 0;
                  next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

                  break;
                }
              }

              child = next;
            }
          } else {
            child = this._last;
            var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

            while (child) {
              next = child._prev;

              if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                  return this.render(totalTime, suppressEvents, force);
                }

                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

                if (time !== this._time || !this._ts && !prevPaused) {
                  //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                  pauseTween = 0;
                  next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

                  break;
                }
              }

              child = next;
            }
          }

          if (pauseTween && !suppressEvents) {
            this.pause();
            pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

            if (this._ts) {
              //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
              this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

              _setEnd(this);

              return this.render(totalTime, suppressEvents, force);
            }
          }

          this._onUpdate && !suppressEvents && _callback$1(this, "onUpdate", true);
          if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
            // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
              _callback$1(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }

        return this;
      };

      _proto2.add = function add(child, position) {
        var _this2 = this;

        _isNumber$1(position) || (position = _parsePosition$1(this, position, child));

        if (!(child instanceof Animation)) {
          if (_isArray(child)) {
            child.forEach(function (obj) {
              return _this2.add(obj, position);
            });
            return this;
          }

          if (_isString$1(child)) {
            return this.addLabel(child, position);
          }

          if (_isFunction$1(child)) {
            child = Tween.delayedCall(0, child);
          } else {
            return this;
          }
        }

        return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
      };

      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
        if (nested === void 0) {
          nested = true;
        }

        if (tweens === void 0) {
          tweens = true;
        }

        if (timelines === void 0) {
          timelines = true;
        }

        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = -_bigNum$1;
        }

        var a = [],
            child = this._first;

        while (child) {
          if (child._start >= ignoreBeforeTime) {
            if (child instanceof Tween) {
              tweens && a.push(child);
            } else {
              timelines && a.push(child);
              nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
            }
          }

          child = child._next;
        }

        return a;
      };

      _proto2.getById = function getById(id) {
        var animations = this.getChildren(1, 1, 1),
            i = animations.length;

        while (i--) {
          if (animations[i].vars.id === id) {
            return animations[i];
          }
        }
      };

      _proto2.remove = function remove(child) {
        if (_isString$1(child)) {
          return this.removeLabel(child);
        }

        if (_isFunction$1(child)) {
          return this.killTweensOf(child);
        }

        _removeLinkedListItem(this, child);

        if (child === this._recent) {
          this._recent = this._last;
        }

        return _uncache(this);
      };

      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
        if (!arguments.length) {
          return this._tTime;
        }

        this._forcing = 1;

        if (!this._dp && this._ts) {
          //special case for the global timeline (or any other that has no parent or detached parent).
          this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
        }

        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

        this._forcing = 0;
        return this;
      };

      _proto2.addLabel = function addLabel(label, position) {
        this.labels[label] = _parsePosition$1(this, position);
        return this;
      };

      _proto2.removeLabel = function removeLabel(label) {
        delete this.labels[label];
        return this;
      };

      _proto2.addPause = function addPause(position, callback, params) {
        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
        t.data = "isPause";
        this._hasPause = 1;
        return _addToTimeline(this, t, _parsePosition$1(this, position));
      };

      _proto2.removePause = function removePause(position) {
        var child = this._first;
        position = _parsePosition$1(this, position);

        while (child) {
          if (child._start === position && child.data === "isPause") {
            _removeFromParent(child);
          }

          child = child._next;
        }
      };

      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        var tweens = this.getTweensOf(targets, onlyActive),
            i = tweens.length;

        while (i--) {
          _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
        }

        return this;
      };

      _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
        var a = [],
            parsedTargets = toArray(targets),
            child = this._first,
            isGlobalTime = _isNumber$1(onlyActive),
            // a number is interpreted as a global time. If the animation spans
        children;

        while (child) {
          if (child instanceof Tween) {
            if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
              // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
              a.push(child);
            }
          } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
            a.push.apply(a, children);
          }

          child = child._next;
        }

        return a;
      } // potential future feature - targets() on timelines
      // targets() {
      // 	let result = [];
      // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
      // 	return result.filter((v, i) => result.indexOf(v) === i);
      // }
      ;

      _proto2.tweenTo = function tweenTo(position, vars) {
        vars = vars || {};

        var tl = this,
            endTime = _parsePosition$1(tl, position),
            _vars = vars,
            startAt = _vars.startAt,
            _onStart = _vars.onStart,
            onStartParams = _vars.onStartParams,
            immediateRender = _vars.immediateRender,
            initted,
            tween = Tween.to(tl, _setDefaults$1({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();

            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }

            _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
          }
        }, vars));

        return immediateRender ? tween.render(0) : tween;
      };

      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
        return this.tweenTo(toPosition, _setDefaults$1({
          startAt: {
            time: _parsePosition$1(this, fromPosition)
          }
        }, vars));
      };

      _proto2.recent = function recent() {
        return this._recent;
      };

      _proto2.nextLabel = function nextLabel(afterTime) {
        if (afterTime === void 0) {
          afterTime = this._time;
        }

        return _getLabelInDirection(this, _parsePosition$1(this, afterTime));
      };

      _proto2.previousLabel = function previousLabel(beforeTime) {
        if (beforeTime === void 0) {
          beforeTime = this._time;
        }

        return _getLabelInDirection(this, _parsePosition$1(this, beforeTime), 1);
      };

      _proto2.currentLabel = function currentLabel(value) {
        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
      };

      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = 0;
        }

        var child = this._first,
            labels = this.labels,
            p;

        while (child) {
          if (child._start >= ignoreBeforeTime) {
            child._start += amount;
            child._end += amount;
          }

          child = child._next;
        }

        if (adjustLabels) {
          for (p in labels) {
            if (labels[p] >= ignoreBeforeTime) {
              labels[p] += amount;
            }
          }
        }

        return _uncache(this);
      };

      _proto2.invalidate = function invalidate() {
        var child = this._first;
        this._lock = 0;

        while (child) {
          child.invalidate();
          child = child._next;
        }

        return _Animation.prototype.invalidate.call(this);
      };

      _proto2.clear = function clear(includeLabels) {
        if (includeLabels === void 0) {
          includeLabels = true;
        }

        var child = this._first,
            next;

        while (child) {
          next = child._next;
          this.remove(child);
          child = next;
        }

        this._dp && (this._time = this._tTime = this._pTime = 0);
        includeLabels && (this.labels = {});
        return _uncache(this);
      };

      _proto2.totalDuration = function totalDuration(value) {
        var max = 0,
            self = this,
            child = self._last,
            prevStart = _bigNum$1,
            prev,
            start,
            parent;

        if (arguments.length) {
          return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
        }

        if (self._dirty) {
          parent = self.parent;

          while (child) {
            prev = child._prev; //record it here in case the tween changes position in the sequence...

            child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

            start = child._start;

            if (start > prevStart && self._sort && child._ts && !self._lock) {
              //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
              self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

              _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
            } else {
              prevStart = start;
            }

            if (start < 0 && child._ts) {
              //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
              max -= start;

              if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                self._start += start / self._ts;
                self._time -= start;
                self._tTime -= start;
              }

              self.shiftChildren(-start, false, -1e999);
              prevStart = 0;
            }

            child._end > max && child._ts && (max = child._end);
            child = prev;
          }

          _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

          self._dirty = 0;
        }

        return self._tDur;
      };

      Timeline.updateRoot = function updateRoot(time) {
        if (_globalTimeline._ts) {
          _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

          _lastRenderedFrame = _ticker.frame;
        }

        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var child = _globalTimeline._first;
          if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }

            child || _ticker.sleep();
          }
        }
      };

      return Timeline;
    }(Animation);

    _setDefaults$1(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });

    var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
      //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
      var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
          index = 0,
          matchIndex = 0,
          result,
          startNums,
          color,
          endNum,
          chunk,
          startNum,
          hasRandom,
          a;
      pt.b = start;
      pt.e = end;
      start += ""; //ensure values are strings

      end += "";

      if (hasRandom = ~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }

      if (stringFilter) {
        a = [start, end];
        stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

        start = a[0];
        end = a[1];
      }

      startNums = start.match(_complexStringNumExp) || [];

      while (result = _complexStringNumExp.exec(end)) {
        endNum = result[0];
        chunk = end.substring(index, result.index);

        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(") {
          color = 1;
        }

        if (endNum !== startNums[matchIndex++]) {
          startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
            m: color && color < 4 ? Math.round : 0
          };
          index = _complexStringNumExp.lastIndex;
        }
      }

      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

      pt.fp = funcParam;

      if (_relExp.test(end) || hasRandom) {
        pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
      }

      this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

      return pt;
    },
        _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
      _isFunction$1(end) && (end = end(index || 0, target, targets));
      var currentValue = target[prop],
          parsedStart = start !== "get" ? start : !_isFunction$1(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction$1(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
          setter = !_isFunction$1(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
          pt;

      if (_isString$1(end)) {
        if (~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }

        if (end.charAt(1) === "=") {
          pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

          if (pt || pt === 0) {
            // to avoid isNaN, like if someone passes in a value like "!= whatever"
            end = pt;
          }
        }
      }

      if (parsedStart !== end || _forceAllPropTweens) {
        if (!isNaN(parsedStart * end) && end !== "") {
          // fun fact: any number multiplied by "" is evaluated as the number 0!
          pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
          funcParam && (pt.fp = funcParam);
          modifier && pt.modifier(modifier, this, target);
          return this._pt = pt;
        }

        !currentValue && !(prop in target) && _missingPlugin(prop, end);
        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
      }
    },
        //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
    _processVars = function _processVars(vars, index, target, targets, tween) {
      _isFunction$1(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

      if (!_isObject$1(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
        return _isString$1(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
      }

      var copy = {},
          p;

      for (p in vars) {
        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
      }

      return copy;
    },
        _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
      var plugin, pt, ptLookup, i;

      if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

        if (tween !== _quickTween) {
          ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

          i = plugin._props.length;

          while (i--) {
            ptLookup[plugin._props[i]] = pt;
          }
        }
      }

      return plugin;
    },
        _overwritingTween,
        //store a reference temporarily so we can avoid overwriting itself.
    _forceAllPropTweens,
        _initTween = function _initTween(tween, time) {
      var vars = tween.vars,
          ease = vars.ease,
          startAt = vars.startAt,
          immediateRender = vars.immediateRender,
          lazy = vars.lazy,
          onUpdate = vars.onUpdate,
          onUpdateParams = vars.onUpdateParams,
          callbackScope = vars.callbackScope,
          runBackwards = vars.runBackwards,
          yoyoEase = vars.yoyoEase,
          keyframes = vars.keyframes,
          autoRevert = vars.autoRevert,
          dur = tween._dur,
          prevStartAt = tween._startAt,
          targets = tween._targets,
          parent = tween.parent,
          fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
          autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites$1,
          tl = tween.timeline,
          cleanVars,
          i,
          p,
          pt,
          target,
          hasPriority,
          gsData,
          harness,
          plugin,
          ptLookup,
          index,
          harnessVars,
          overwritten;
      tl && (!keyframes || !ease) && (ease = "none");
      tween._ease = _parseEase(ease, _defaults$1.ease);
      tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults$1.ease)) : 0;

      if (yoyoEase && tween._yoyo && !tween._repeat) {
        //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
        yoyoEase = tween._yEase;
        tween._yEase = tween._ease;
        tween._ease = yoyoEase;
      }

      tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

      if (!tl || keyframes && !vars.stagger) {
        //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
        harness = targets[0] ? _getCache(targets[0]).harness : 0;
        harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

        cleanVars = _copyExcluding(vars, _reservedProps);

        if (prevStartAt) {
          _removeFromParent(prevStartAt.render(-1, true));

          prevStartAt._lazy = 0;
        }

        if (startAt) {
          _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults$1({
            data: "isStart",
            overwrite: false,
            parent: parent,
            immediateRender: true,
            lazy: _isNotFalse(lazy),
            startAt: null,
            delay: 0,
            onUpdate: onUpdate,
            onUpdateParams: onUpdateParams,
            callbackScope: callbackScope,
            stagger: 0
          }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


          time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

          if (immediateRender) {
            time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

            if (dur && time <= 0) {
              time && (tween._zTime = time);
              return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
            } // if (time > 0) {
            // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
            // } else if (dur && !(time < 0 && prevStartAt)) {
            // 	time && (tween._zTime = time);
            // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
            // }

          } else if (autoRevert === false) {
            tween._startAt = 0;
          }
        } else if (runBackwards && dur) {
          //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
          if (prevStartAt) {
            !autoRevert && (tween._startAt = 0);
          } else {
            time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

            p = _setDefaults$1({
              overwrite: false,
              data: "isFromStart",
              //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
              lazy: immediateRender && _isNotFalse(lazy),
              immediateRender: immediateRender,
              //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
              stagger: 0,
              parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

            }, cleanVars);
            harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

            _removeFromParent(tween._startAt = Tween.set(targets, p));

            time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

            tween._zTime = time;

            if (!immediateRender) {
              _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

            } else if (!time) {
              return;
            }
          }
        }

        tween._pt = tween._ptCache = 0;
        lazy = dur && _isNotFalse(lazy) || lazy && !dur;

        for (i = 0; i < targets.length; i++) {
          target = targets[i];
          gsData = target._gsap || _harness(targets)[i]._gsap;
          tween._ptLookup[i] = ptLookup = {};
          _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

          index = fullTargets === targets ? i : fullTargets.indexOf(target);

          if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
            tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

            plugin._props.forEach(function (name) {
              ptLookup[name] = pt;
            });

            plugin.priority && (hasPriority = 1);
          }

          if (!harness || harnessVars) {
            for (p in cleanVars) {
              if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                plugin.priority && (hasPriority = 1);
              } else {
                ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
              }
            }
          }

          tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

          if (autoOverwrite && tween._pt) {
            _overwritingTween = tween;

            _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


            overwritten = !tween.parent;
            _overwritingTween = 0;
          }

          tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
        }

        hasPriority && _sortPropTweensByPriority(tween);
        tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
      }

      tween._onUpdate = onUpdate;
      tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

      keyframes && time <= 0 && tl.render(_bigNum$1, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
    },
        _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
      var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
          pt,
          lookup,
          i;

      if (!ptCache) {
        ptCache = tween._ptCache[property] = [];
        lookup = tween._ptLookup;
        i = tween._targets.length;

        while (i--) {
          pt = lookup[i][property];

          if (pt && pt.d && pt.d._pt) {
            // it's a plugin, so find the nested PropTween
            pt = pt.d._pt;

            while (pt && pt.p !== property) {
              pt = pt._next;
            }
          }

          if (!pt) {
            // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
            // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
            _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

            tween.vars[property] = "+=0";

            _initTween(tween, time);

            _forceAllPropTweens = 0;
            return 1;
          }

          ptCache.push(pt);
        }
      }

      i = ptCache.length;

      while (i--) {
        pt = ptCache[i];
        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
        pt.c = value - pt.s;
        pt.e && (pt.e = _round$1(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)

        pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
      }
    },
        _addAliasesToVars = function _addAliasesToVars(targets, vars) {
      var harness = targets[0] ? _getCache(targets[0]).harness : 0,
          propertyAliases = harness && harness.aliases,
          copy,
          p,
          i,
          aliases;

      if (!propertyAliases) {
        return vars;
      }

      copy = _merge({}, vars);

      for (p in propertyAliases) {
        if (p in copy) {
          aliases = propertyAliases[p].split(",");
          i = aliases.length;

          while (i--) {
            copy[aliases[i]] = copy[p];
          }
        }
      }

      return copy;
    },
        // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
    _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
      var ease = obj.ease || easeEach || "power1.inOut",
          p,
          a;

      if (_isArray(obj)) {
        a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

        obj.forEach(function (value, i) {
          return a.push({
            t: i / (obj.length - 1) * 100,
            v: value,
            e: ease
          });
        });
      } else {
        for (p in obj) {
          a = allProps[p] || (allProps[p] = []);
          p === "ease" || a.push({
            t: parseFloat(prop),
            v: obj[p],
            e: ease
          });
        }
      }
    },
        _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
      return _isFunction$1(value) ? value.call(tween, i, target, targets) : _isString$1(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
    },
        _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        _staggerPropsToSkip = {};

    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
      return _staggerPropsToSkip[name] = 1;
    });
    /*
     * --------------------------------------------------------------------------------------
     * TWEEN
     * --------------------------------------------------------------------------------------
     */


    var Tween = /*#__PURE__*/function (_Animation2) {
      _inheritsLoose(Tween, _Animation2);

      function Tween(targets, vars, position, skipInherit) {
        var _this3;

        if (typeof vars === "number") {
          position.duration = vars;
          vars = position;
          position = null;
        }

        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
        var _this3$vars = _this3.vars,
            duration = _this3$vars.duration,
            delay = _this3$vars.delay,
            immediateRender = _this3$vars.immediateRender,
            stagger = _this3$vars.stagger,
            overwrite = _this3$vars.overwrite,
            keyframes = _this3$vars.keyframes,
            defaults = _this3$vars.defaults,
            scrollTrigger = _this3$vars.scrollTrigger,
            yoyoEase = _this3$vars.yoyoEase,
            parent = vars.parent || _globalTimeline,
            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber$1(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
            tl,
            i,
            copy,
            l,
            p,
            curTarget,
            staggerFunc,
            staggerVarsToMerge;
        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
        _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

        _this3._overwrite = overwrite;

        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          vars = _this3.vars;
          tl = _this3.timeline = new Timeline({
            data: "nested",
            defaults: defaults || {}
          });
          tl.kill();
          tl.parent = tl._dp = _assertThisInitialized(_this3);
          tl._start = 0;

          if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            l = parsedTargets.length;
            staggerFunc = stagger && distribute(stagger);

            if (_isObject$1(stagger)) {
              //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
              for (p in stagger) {
                if (~_staggerTweenProps.indexOf(p)) {
                  staggerVarsToMerge || (staggerVarsToMerge = {});
                  staggerVarsToMerge[p] = stagger[p];
                }
              }
            }

            for (i = 0; i < l; i++) {
              copy = _copyExcluding(vars, _staggerPropsToSkip);
              copy.stagger = 0;
              yoyoEase && (copy.yoyoEase = yoyoEase);
              staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
              curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

              copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
              copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

              if (!stagger && l === 1 && copy.delay) {
                // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
                _this3._delay = delay = copy.delay;
                _this3._start += delay;
                copy.delay = 0;
              }

              tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
              tl._ease = _easeMap.none;
            }

            tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
          } else if (keyframes) {
            _inheritDefaults(_setDefaults$1(tl.vars.defaults, {
              ease: "none"
            }));

            tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
            var time = 0,
                a,
                kf,
                v;

            if (_isArray(keyframes)) {
              keyframes.forEach(function (frame) {
                return tl.to(parsedTargets, frame, ">");
              });
            } else {
              copy = {};

              for (p in keyframes) {
                p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
              }

              for (p in copy) {
                a = copy[p].sort(function (a, b) {
                  return a.t - b.t;
                });
                time = 0;

                for (i = 0; i < a.length; i++) {
                  kf = a[i];
                  v = {
                    ease: kf.e,
                    duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                  };
                  v[p] = kf.v;
                  tl.to(parsedTargets, v, time);
                  time += v.duration;
                }
              }

              tl.duration() < duration && tl.to({}, {
                duration: duration - tl.duration()
              }); // in case keyframes didn't go to 100%
            }
          }

          duration || _this3.duration(duration = tl.duration());
        } else {
          _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
        }

        if (overwrite === true && !_suppressOverwrites$1) {
          _overwritingTween = _assertThisInitialized(_this3);

          _globalTimeline.killTweensOf(parsedTargets);

          _overwritingTween = 0;
        }

        _addToTimeline(parent, _assertThisInitialized(_this3), position);

        vars.reversed && _this3.reverse();
        vars.paused && _this3.paused(true);

        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
          _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

          _this3.render(Math.max(0, -delay)); //in case delay is negative

        }

        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
        return _this3;
      }

      var _proto3 = Tween.prototype;

      _proto3.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._tDur,
            dur = this._dur,
            tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
            time,
            pt,
            iteration,
            cycleDuration,
            prevIteration,
            isYoyo,
            ratio,
            timeline,
            yoyoEase;

        if (!dur) {
          _renderZeroDurationTween(this, totalTime, suppressEvents, force);
        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
          //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
          time = tTime;
          timeline = this.timeline;

          if (this._repeat) {
            //adjust the time for repeats and yoyos
            cycleDuration = dur + this._rDelay;

            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }

            time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

            if (tTime === tDur) {
              // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);

              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }

              time > dur && (time = dur);
            }

            isYoyo = this._yoyo && iteration & 1;

            if (isYoyo) {
              yoyoEase = this._yEase;
              time = dur - time;
            }

            prevIteration = _animationCycle(this._tTime, cycleDuration);

            if (time === prevTime && !force && this._initted) {
              //could be during the repeatDelay part. No need to render and fire callbacks.
              this._tTime = tTime;
              return this;
            }

            if (iteration !== prevIteration) {
              timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

              if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
              }
            }
          }

          if (!this._initted) {
            if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
              this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

              return this;
            }

            if (prevTime !== this._time) {
              // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
              return this;
            }

            if (dur !== this._dur) {
              // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
              return this.render(totalTime, suppressEvents, force);
            }
          }

          this._tTime = tTime;
          this._time = time;

          if (!this._act && this._ts) {
            this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

            this._lazy = 0;
          }

          this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

          if (this._from) {
            this.ratio = ratio = 1 - ratio;
          }

          if (time && !prevTime && !suppressEvents) {
            _callback$1(this, "onStart");

            if (this._tTime !== tTime) {
              // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
              return this;
            }
          }

          pt = this._pt;

          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }

          timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

          if (this._onUpdate && !suppressEvents) {
            totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

            _callback$1(this, "onUpdate");
          }

          this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback$1(this, "onRepeat");

          if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
            totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
            (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
              // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
              _callback$1(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }

        return this;
      };

      _proto3.targets = function targets() {
        return this._targets;
      };

      _proto3.invalidate = function invalidate() {
        this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
        this._ptLookup = [];
        this.timeline && this.timeline.invalidate();
        return _Animation2.prototype.invalidate.call(this);
      };

      _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
        _tickerActive || _ticker.wake();
        this._ts || this.play();
        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            ratio;
        this._initted || _initTween(this, time);
        ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
        // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
        // if (_isObject(property)) { // performance optimization
        // 	for (p in property) {
        // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
        // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
        // 		}
        // 	}
        // } else {

        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
          return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
        } //}


        _alignPlayhead(this, 0);

        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
        return this.render(0);
      };

      _proto3.kill = function kill(targets, vars) {
        if (vars === void 0) {
          vars = "all";
        }

        if (!targets && (!vars || vars === "all")) {
          this._lazy = this._pt = 0;
          return this.parent ? _interrupt(this) : this;
        }

        if (this.timeline) {
          var tDur = this.timeline.totalDuration();
          this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

          this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

          return this;
        }

        var parsedTargets = this._targets,
            killingTargets = targets ? toArray(targets) : parsedTargets,
            propTweenLookup = this._ptLookup,
            firstPT = this._pt,
            overwrittenProps,
            curLookup,
            curOverwriteProps,
            props,
            p,
            pt,
            i;

        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
          vars === "all" && (this._pt = 0);
          return _interrupt(this);
        }

        overwrittenProps = this._op = this._op || [];

        if (vars !== "all") {
          //so people can pass in a comma-delimited list of property names
          if (_isString$1(vars)) {
            p = {};

            _forEachName(vars, function (name) {
              return p[name] = 1;
            });

            vars = p;
          }

          vars = _addAliasesToVars(parsedTargets, vars);
        }

        i = parsedTargets.length;

        while (i--) {
          if (~killingTargets.indexOf(parsedTargets[i])) {
            curLookup = propTweenLookup[i];

            if (vars === "all") {
              overwrittenProps[i] = vars;
              props = curLookup;
              curOverwriteProps = {};
            } else {
              curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
              props = vars;
            }

            for (p in props) {
              pt = curLookup && curLookup[p];

              if (pt) {
                if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                  _removeLinkedListItem(this, pt, "_pt");
                }

                delete curLookup[p];
              }

              if (curOverwriteProps !== "all") {
                curOverwriteProps[p] = 1;
              }
            }
          }
        }

        this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

        return this;
      };

      Tween.to = function to(targets, vars) {
        return new Tween(targets, vars, arguments[2]);
      };

      Tween.from = function from(targets, vars) {
        return _createTweenType(1, arguments);
      };

      Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
        return new Tween(callback, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay: delay,
          onComplete: callback,
          onReverseComplete: callback,
          onCompleteParams: params,
          onReverseCompleteParams: params,
          callbackScope: scope
        });
      };

      Tween.fromTo = function fromTo(targets, fromVars, toVars) {
        return _createTweenType(2, arguments);
      };

      Tween.set = function set(targets, vars) {
        vars.duration = 0;
        vars.repeatDelay || (vars.repeat = 0);
        return new Tween(targets, vars);
      };

      Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        return _globalTimeline.killTweensOf(targets, props, onlyActive);
      };

      return Tween;
    }(Animation);

    _setDefaults$1(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    }); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
    // _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
    // 	Tween.prototype[name] = function() {
    // 		let tl = new Timeline();
    // 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
    // 	}
    // });
    //for backward compatibility. Leverage the timeline calls.


    _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
      Tween[name] = function () {
        var tl = new Timeline(),
            params = _slice.call(arguments, 0);

        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
        return tl[name].apply(tl, params);
      };
    });
    /*
     * --------------------------------------------------------------------------------------
     * PROPTWEEN
     * --------------------------------------------------------------------------------------
     */


    var _setterPlain = function _setterPlain(target, property, value) {
      return target[property] = value;
    },
        _setterFunc = function _setterFunc(target, property, value) {
      return target[property](value);
    },
        _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
      return target[property](data.fp, value);
    },
        _setterAttribute = function _setterAttribute(target, property, value) {
      return target.setAttribute(property, value);
    },
        _getSetter = function _getSetter(target, property) {
      return _isFunction$1(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
    },
        _renderPlain = function _renderPlain(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
    },
        _renderBoolean = function _renderBoolean(ratio, data) {
      return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
    },
        _renderComplexString = function _renderComplexString(ratio, data) {
      var pt = data._pt,
          s = "";

      if (!ratio && data.b) {
        //b = beginning string
        s = data.b;
      } else if (ratio === 1 && data.e) {
        //e = ending string
        s = data.e;
      } else {
        while (pt) {
          s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

          pt = pt._next;
        }

        s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
      }

      data.set(data.t, data.p, s, data);
    },
        _renderPropTweens = function _renderPropTweens(ratio, data) {
      var pt = data._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    },
        _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
      var pt = this._pt,
          next;

      while (pt) {
        next = pt._next;
        pt.p === property && pt.modifier(modifier, tween, target);
        pt = next;
      }
    },
        _killPropTweensOf = function _killPropTweensOf(property) {
      var pt = this._pt,
          hasNonDependentRemaining,
          next;

      while (pt) {
        next = pt._next;

        if (pt.p === property && !pt.op || pt.op === property) {
          _removeLinkedListItem(this, pt, "_pt");
        } else if (!pt.dep) {
          hasNonDependentRemaining = 1;
        }

        pt = next;
      }

      return !hasNonDependentRemaining;
    },
        _setterWithModifier = function _setterWithModifier(target, property, value, data) {
      data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
    },
        _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
      var pt = parent._pt,
          next,
          pt2,
          first,
          last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

      while (pt) {
        next = pt._next;
        pt2 = first;

        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }

        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }

        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }

        pt = next;
      }

      parent._pt = first;
    }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


    var PropTween = /*#__PURE__*/function () {
      function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
        this.t = target;
        this.s = start;
        this.c = change;
        this.p = prop;
        this.r = renderer || _renderPlain;
        this.d = data || this;
        this.set = setter || _setterPlain;
        this.pr = priority || 0;
        this._next = next;

        if (next) {
          next._prev = this;
        }
      }

      var _proto4 = PropTween.prototype;

      _proto4.modifier = function modifier(func, tween, target) {
        this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

        this.set = _setterWithModifier;
        this.m = func;
        this.mt = target; //modifier target

        this.tween = tween;
      };

      return PropTween;
    }(); //Initialization tasks

    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
      return _reservedProps[name] = 1;
    });

    _globals.TweenMax = _globals.TweenLite = Tween;
    _globals.TimelineLite = _globals.TimelineMax = Timeline;
    _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults$1,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    });
    _config.stringFilter = _colorStringFilter;
    /*
     * --------------------------------------------------------------------------------------
     * GSAP
     * --------------------------------------------------------------------------------------
     */

    var _gsap = {
      registerPlugin: function registerPlugin() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        args.forEach(function (config) {
          return _createPlugin(config);
        });
      },
      timeline: function timeline(vars) {
        return new Timeline(vars);
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
        return _globalTimeline.getTweensOf(targets, onlyActive);
      },
      getProperty: function getProperty(target, property, unit, uncache) {
        _isString$1(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

        var getter = _getCache(target || {}).get,
            format = unit ? _passThrough$1 : _numericIfPossible;

        unit === "native" && (unit = "");
        return !target ? target : !property ? function (property, unit, uncache) {
          return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      },
      quickSetter: function quickSetter(target, property, unit) {
        target = toArray(target);

        if (target.length > 1) {
          var setters = target.map(function (t) {
            return gsap$2.quickSetter(t, property, unit);
          }),
              l = setters.length;
          return function (value) {
            var i = l;

            while (i--) {
              setters[i](value);
            }
          };
        }

        target = target[0] || {};

        var Plugin = _plugins[property],
            cache = _getCache(target),
            p = cache.harness && (cache.harness.aliases || {})[property] || property,
            // in case it's an alias, like "rotate" for "rotation".
        setter = Plugin ? function (value) {
          var p = new Plugin();
          _quickTween._pt = 0;
          p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
          p.render(1, p);
          _quickTween._pt && _renderPropTweens(1, _quickTween);
        } : cache.set(target, p);

        return Plugin ? setter : function (value) {
          return setter(target, p, unit ? value + unit : value, cache, 1);
        };
      },
      quickTo: function quickTo(target, property, vars) {
        var _merge2;

        var tween = gsap$2.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
            func = function func(value, start, startIsRelative) {
          return tween.resetTo(property, value, start, startIsRelative);
        };

        func.tween = tween;
        return func;
      },
      isTweening: function isTweening(targets) {
        return _globalTimeline.getTweensOf(targets, true).length > 0;
      },
      defaults: function defaults(value) {
        value && value.ease && (value.ease = _parseEase(value.ease, _defaults$1.ease));
        return _mergeDeep(_defaults$1, value || {});
      },
      config: function config(value) {
        return _mergeDeep(_config, value || {});
      },
      registerEffect: function registerEffect(_ref3) {
        var name = _ref3.name,
            effect = _ref3.effect,
            plugins = _ref3.plugins,
            defaults = _ref3.defaults,
            extendTimeline = _ref3.extendTimeline;
        (plugins || "").split(",").forEach(function (pluginName) {
          return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
        });

        _effects[name] = function (targets, vars, tl) {
          return effect(toArray(targets), _setDefaults$1(vars || {}, defaults), tl);
        };

        if (extendTimeline) {
          Timeline.prototype[name] = function (targets, vars, position) {
            return this.add(_effects[name](targets, _isObject$1(vars) ? vars : (position = vars) && {}, this), position);
          };
        }
      },
      registerEase: function registerEase(name, ease) {
        _easeMap[name] = _parseEase(ease);
      },
      parseEase: function parseEase(ease, defaultEase) {
        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
      },
      getById: function getById(id) {
        return _globalTimeline.getById(id);
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
        if (vars === void 0) {
          vars = {};
        }

        var tl = new Timeline(vars),
            child,
            next;
        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

        _globalTimeline.remove(tl);

        tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

        tl._time = tl._tTime = _globalTimeline._time;
        child = _globalTimeline._first;

        while (child) {
          next = child._next;

          if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
            _addToTimeline(tl, child, child._start - child._delay);
          }

          child = next;
        }

        _addToTimeline(_globalTimeline, tl, 0);

        return tl;
      },
      utils: {
        wrap: wrap,
        wrapYoyo: wrapYoyo,
        distribute: distribute,
        random: random,
        snap: snap,
        normalize: normalize$2,
        getUnit: getUnit,
        clamp: clamp,
        splitColor: splitColor,
        toArray: toArray,
        selector: selector$1,
        mapRange: mapRange,
        pipe: pipe,
        unitize: unitize,
        interpolate: interpolate$3,
        shuffle: shuffle$2
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
        PropTween: PropTween,
        globals: _addGlobal,
        Tween: Tween,
        Timeline: Timeline,
        Animation: Animation,
        getCache: _getCache,
        _removeLinkedListItem: _removeLinkedListItem,
        suppressOverwrites: function suppressOverwrites(value) {
          return _suppressOverwrites$1 = value;
        }
      }
    };

    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
      return _gsap[name] = Tween[name];
    });

    _ticker.add(Timeline.updateRoot);

    _quickTween = _gsap.to({}, {
      duration: 0
    }); // ---- EXTRA PLUGINS --------------------------------------------------------

    var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
      var pt = plugin._pt;

      while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
        pt = pt._next;
      }

      return pt;
    },
        _addModifiers = function _addModifiers(tween, modifiers) {
      var targets = tween._targets,
          p,
          i,
          pt;

      for (p in modifiers) {
        i = targets.length;

        while (i--) {
          pt = tween._ptLookup[i][p];

          if (pt && (pt = pt.d)) {
            if (pt._pt) {
              // is a plugin
              pt = _getPluginPropTween(pt, p);
            }

            pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
          }
        }
      }
    },
        _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
      return {
        name: name,
        rawVars: 1,
        //don't pre-process function-based values or "random()" strings.
        init: function init(target, vars, tween) {
          tween._onInit = function (tween) {
            var temp, p;

            if (_isString$1(vars)) {
              temp = {};

              _forEachName(vars, function (name) {
                return temp[name] = 1;
              }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


              vars = temp;
            }

            if (modifier) {
              temp = {};

              for (p in vars) {
                temp[p] = modifier(vars[p]);
              }

              vars = temp;
            }

            _addModifiers(tween, vars);
          };
        }
      };
    }; //register core plugins


    var gsap$2 = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index, targets) {
        var p, pt;

        for (p in vars) {
          pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
          pt && (pt.op = p);

          this._props.push(p);
        }
      }
    }, {
      name: "endArray",
      init: function init(target, value) {
        var i = value.length;

        while (i--) {
          this.add(target, i, target[i] || 0, value[i]);
        }
      }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

    Tween.version = Timeline.version = gsap$2.version = "3.10.4";
    _coreReady = 1;
    _windowExists$2() && _wake();
    _easeMap.Power0;
        _easeMap.Power1;
        _easeMap.Power2;
        _easeMap.Power3;
        _easeMap.Power4;
        _easeMap.Linear;
        var Quad$1 = _easeMap.Quad;
        _easeMap.Cubic;
        _easeMap.Quart;
        var Quint = _easeMap.Quint;
        _easeMap.Strong;
        _easeMap.Elastic;
        _easeMap.Back;
        _easeMap.SteppedEase;
        _easeMap.Bounce;
        _easeMap.Sine;
        var Expo = _easeMap.Expo;
        _easeMap.Circ;

    /*!
     * CSSPlugin 3.10.4
     * https://greensock.com
     *
     * Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */

    var _win$2,
        _doc$2,
        _docElement,
        _pluginInitted,
        _tempDiv,
        _recentSetterPlugin,
        _windowExists$1 = function _windowExists() {
      return typeof window !== "undefined";
    },
        _transformProps = {},
        _RAD2DEG = 180 / Math.PI,
        _DEG2RAD = Math.PI / 180,
        _atan2 = Math.atan2,
        _bigNum = 1e8,
        _capsExp$1 = /([A-Z])/g,
        _horizontalExp = /(left|right|width|margin|padding|x)/i,
        _complexExp = /[\s,\(]\S/,
        _propertyAliases = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    },
        _renderCSSProp = function _renderCSSProp(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
      return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
      return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
    },
        //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
    _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
      var value = data.s + data.c * ratio;
      data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
    },
        _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
      return data.set(data.t, data.p, ratio ? data.e : data.b, data);
    },
        _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
      return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
    },
        _setterCSSStyle = function _setterCSSStyle(target, property, value) {
      return target.style[property] = value;
    },
        _setterCSSProp = function _setterCSSProp(target, property, value) {
      return target.style.setProperty(property, value);
    },
        _setterTransform = function _setterTransform(target, property, value) {
      return target._gsap[property] = value;
    },
        _setterScale = function _setterScale(target, property, value) {
      return target._gsap.scaleX = target._gsap.scaleY = value;
    },
        _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache.scaleX = cache.scaleY = value;
      cache.renderTransform(ratio, cache);
    },
        _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache[property] = value;
      cache.renderTransform(ratio, cache);
    },
        _transformProp$1 = "transform",
        _transformOriginProp = _transformProp$1 + "Origin",
        _supports3D,
        _createElement = function _createElement(type, ns) {
      var e = _doc$2.createElementNS ? _doc$2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$2.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

      return e.style ? e : _doc$2.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
    },
        _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
      var cs = getComputedStyle(target);
      return cs[property] || cs.getPropertyValue(property.replace(_capsExp$1, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
    },
        _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
        _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
      var e = element || _tempDiv,
          s = e.style,
          i = 5;

      if (property in s && !preferPrefix) {
        return property;
      }

      property = property.charAt(0).toUpperCase() + property.substr(1);

      while (i-- && !(_prefixes[i] + property in s)) {}

      return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
    },
        _initCore$1 = function _initCore() {
      if (_windowExists$1() && window.document) {
        _win$2 = window;
        _doc$2 = _win$2.document;
        _docElement = _doc$2.documentElement;
        _tempDiv = _createElement("div") || {
          style: {}
        };
        _createElement("div");
        _transformProp$1 = _checkPropPrefix(_transformProp$1);
        _transformOriginProp = _transformProp$1 + "Origin";
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

        _supports3D = !!_checkPropPrefix("perspective");
        _pluginInitted = 1;
      }
    },
        _getBBoxHack = function _getBBoxHack(swapIfPossible) {
      //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
      var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
          oldParent = this.parentNode,
          oldSibling = this.nextSibling,
          oldCSS = this.style.cssText,
          bbox;

      _docElement.appendChild(svg);

      svg.appendChild(this);
      this.style.display = "block";

      if (swapIfPossible) {
        try {
          bbox = this.getBBox();
          this._gsapBBox = this.getBBox; //store the original

          this.getBBox = _getBBoxHack;
        } catch (e) {}
      } else if (this._gsapBBox) {
        bbox = this._gsapBBox();
      }

      if (oldParent) {
        if (oldSibling) {
          oldParent.insertBefore(this, oldSibling);
        } else {
          oldParent.appendChild(this);
        }
      }

      _docElement.removeChild(svg);

      this.style.cssText = oldCSS;
      return bbox;
    },
        _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
      var i = attributesArray.length;

      while (i--) {
        if (target.hasAttribute(attributesArray[i])) {
          return target.getAttribute(attributesArray[i]);
        }
      }
    },
        _getBBox = function _getBBox(target) {
      var bounds;

      try {
        bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
      } catch (error) {
        bounds = _getBBoxHack.call(target, true);
      }

      bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

      return bounds && !bounds.width && !bounds.x && !bounds.y ? {
        x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
        y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      } : bounds;
    },
        _isSVG = function _isSVG(e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
    },
        //reports if the element is an SVG on which getBBox() actually works
    _removeProperty = function _removeProperty(target, property) {
      if (property) {
        var style = target.style;

        if (property in _transformProps && property !== _transformOriginProp) {
          property = _transformProp$1;
        }

        if (style.removeProperty) {
          if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
            //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
            property = "-" + property;
          }

          style.removeProperty(property.replace(_capsExp$1, "-$1").toLowerCase());
        } else {
          //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
          style.removeAttribute(property);
        }
      }
    },
        _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
      var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
      plugin._pt = pt;
      pt.b = beginning;
      pt.e = end;

      plugin._props.push(property);

      return pt;
    },
        _nonConvertibleUnits = {
      deg: 1,
      rad: 1,
      turn: 1
    },
        //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
    _convertToUnit = function _convertToUnit(target, property, value, unit) {
      var curValue = parseFloat(value) || 0,
          curUnit = (value + "").trim().substr((curValue + "").length) || "px",
          // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
      style = _tempDiv.style,
          horizontal = _horizontalExp.test(property),
          isRootSVG = target.tagName.toLowerCase() === "svg",
          measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
          amount = 100,
          toPixels = unit === "px",
          toPercent = unit === "%",
          px,
          parent,
          cache,
          isSVG;

      if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
        return curValue;
      }

      curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
      isSVG = target.getCTM && _isSVG(target);

      if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
        px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
        return _round$1(toPercent ? curValue / px * amount : curValue / 100 * px);
      }

      style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
      parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

      if (isSVG) {
        parent = (target.ownerSVGElement || {}).parentNode;
      }

      if (!parent || parent === _doc$2 || !parent.appendChild) {
        parent = _doc$2.body;
      }

      cache = parent._gsap;

      if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
        return _round$1(curValue / cache.width * amount);
      } else {
        (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";

        if (horizontal && toPercent) {
          cache = _getCache(parent);
          cache.time = _ticker.time;
          cache.width = parent[measureProperty];
        }
      }

      return _round$1(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
    },
        _get = function _get(target, property, unit, uncache) {
      var value;
      _pluginInitted || _initCore$1();

      if (property in _propertyAliases && property !== "transform") {
        property = _propertyAliases[property];

        if (~property.indexOf(",")) {
          property = property.split(",")[0];
        }
      }

      if (_transformProps[property] && property !== "transform") {
        value = _parseTransform(target, uncache);
        value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
      } else {
        value = target.style[property];

        if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
          value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
        }
      }

      return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
    },
        _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
      // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
      if (!start || start === "none") {
        // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
        var p = _checkPropPrefix(prop, target, 1),
            s = p && _getComputedProperty(target, p, 1);

        if (s && s !== start) {
          prop = p;
          start = s;
        } else if (prop === "borderColor") {
          start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
        }
      }

      var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
          index = 0,
          matchIndex = 0,
          a,
          result,
          startValues,
          startNum,
          color,
          startValue,
          endValue,
          endNum,
          chunk,
          endUnit,
          startUnit,
          endValues;
      pt.b = start;
      pt.e = end;
      start += ""; // ensure values are strings

      end += "";

      if (end === "auto") {
        target.style[prop] = end;
        end = _getComputedProperty(target, prop) || end;
        target.style[prop] = start;
      }

      a = [start, end];

      _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


      start = a[0];
      end = a[1];
      startValues = start.match(_numWithUnitExp) || [];
      endValues = end.match(_numWithUnitExp) || [];

      if (endValues.length) {
        while (result = _numWithUnitExp.exec(end)) {
          endValue = result[0];
          chunk = end.substring(index, result.index);

          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
            color = 1;
          }

          if (endValue !== (startValue = startValues[matchIndex++] || "")) {
            startNum = parseFloat(startValue) || 0;
            startUnit = startValue.substr((startNum + "").length);
            endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
            endNum = parseFloat(endValue);
            endUnit = endValue.substr((endNum + "").length);
            index = _numWithUnitExp.lastIndex - endUnit.length;

            if (!endUnit) {
              //if something like "perspective:300" is passed in and we must add a unit to the end
              endUnit = endUnit || _config.units[prop] || startUnit;

              if (index === end.length) {
                end += endUnit;
                pt.e += endUnit;
              }
            }

            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
            } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
              s: startNum,
              c: endNum - startNum,
              m: color && color < 4 || prop === "zIndex" ? Math.round : 0
            };
          }
        }

        pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
      } else {
        pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
      }

      _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

      this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

      return pt;
    },
        _keywordToPercent = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    },
        _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
      var split = value.split(" "),
          x = split[0],
          y = split[1] || "50%";

      if (x === "top" || x === "bottom" || y === "left" || y === "right") {
        //the user provided them in the wrong order, so flip them
        value = x;
        x = y;
        y = value;
      }

      split[0] = _keywordToPercent[x] || x;
      split[1] = _keywordToPercent[y] || y;
      return split.join(" ");
    },
        _renderClearProps = function _renderClearProps(ratio, data) {
      if (data.tween && data.tween._time === data.tween._dur) {
        var target = data.t,
            style = target.style,
            props = data.u,
            cache = target._gsap,
            prop,
            clearTransforms,
            i;

        if (props === "all" || props === true) {
          style.cssText = "";
          clearTransforms = 1;
        } else {
          props = props.split(",");
          i = props.length;

          while (--i > -1) {
            prop = props[i];

            if (_transformProps[prop]) {
              clearTransforms = 1;
              prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp$1;
            }

            _removeProperty(target, prop);
          }
        }

        if (clearTransforms) {
          _removeProperty(target, _transformProp$1);

          if (cache) {
            cache.svg && target.removeAttribute("transform");

            _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


            cache.uncache = 1;
          }
        }
      }
    },
        // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
    _specialProps = {
      clearProps: function clearProps(plugin, target, property, endValue, tween) {
        if (tween.data !== "isFromStart") {
          var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
          pt.u = endValue;
          pt.pr = -10;
          pt.tween = tween;

          plugin._props.push(property);

          return 1;
        }
      }
      /* className feature (about 0.4kb gzipped).
      , className(plugin, target, property, endValue, tween) {
      	let _renderClassName = (ratio, data) => {
      			data.css.render(ratio, data.css);
      			if (!ratio || ratio === 1) {
      				let inline = data.rmv,
      					target = data.t,
      					p;
      				target.setAttribute("class", ratio ? data.e : data.b);
      				for (p in inline) {
      					_removeProperty(target, p);
      				}
      			}
      		},
      		_getAllStyles = (target) => {
      			let styles = {},
      				computed = getComputedStyle(target),
      				p;
      			for (p in computed) {
      				if (isNaN(p) && p !== "cssText" && p !== "length") {
      					styles[p] = computed[p];
      				}
      			}
      			_setDefaults(styles, _parseTransform(target, 1));
      			return styles;
      		},
      		startClassList = target.getAttribute("class"),
      		style = target.style,
      		cssText = style.cssText,
      		cache = target._gsap,
      		classPT = cache.classPT,
      		inlineToRemoveAtEnd = {},
      		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
      		changingVars = {},
      		startVars = _getAllStyles(target),
      		transformRelated = /(transform|perspective)/i,
      		endVars, p;
      	if (classPT) {
      		classPT.r(1, classPT.d);
      		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
      	}
      	target.setAttribute("class", data.e);
      	endVars = _getAllStyles(target, true);
      	target.setAttribute("class", startClassList);
      	for (p in endVars) {
      		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
      			changingVars[p] = endVars[p];
      			if (!style[p] && style[p] !== "0") {
      				inlineToRemoveAtEnd[p] = 1;
      			}
      		}
      	}
      	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
      	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
      		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
      	}
      	_parseTransform(target, true); //to clear the caching of transforms
      	data.css = new gsap.plugins.css();
      	data.css.init(target, changingVars, tween);
      	plugin._props.push(...data.css._props);
      	return 1;
      }
      */

    },

    /*
     * --------------------------------------------------------------------------------------
     * TRANSFORMS
     * --------------------------------------------------------------------------------------
     */
    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
        _rotationalProperties = {},
        _isNullTransform = function _isNullTransform(value) {
      return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
    },
        _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
      var matrixString = _getComputedProperty(target, _transformProp$1);

      return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round$1);
    },
        _getMatrix = function _getMatrix(target, force2D) {
      var cache = target._gsap || _getCache(target),
          style = target.style,
          matrix = _getComputedTransformMatrixAsArray(target),
          parent,
          nextSibling,
          temp,
          addedToDOM;

      if (cache.svg && target.getAttribute("transform")) {
        temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

        matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
        return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
      } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
        //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
        //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
        temp = style.display;
        style.display = "block";
        parent = target.parentNode;

        if (!parent || !target.offsetParent) {
          // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
          addedToDOM = 1; //flag

          nextSibling = target.nextSibling;

          _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

        }

        matrix = _getComputedTransformMatrixAsArray(target);
        temp ? style.display = temp : _removeProperty(target, "display");

        if (addedToDOM) {
          nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
        }
      }

      return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
    },
        _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
      var cache = target._gsap,
          matrix = matrixArray || _getMatrix(target, true),
          xOriginOld = cache.xOrigin || 0,
          yOriginOld = cache.yOrigin || 0,
          xOffsetOld = cache.xOffset || 0,
          yOffsetOld = cache.yOffset || 0,
          a = matrix[0],
          b = matrix[1],
          c = matrix[2],
          d = matrix[3],
          tx = matrix[4],
          ty = matrix[5],
          originSplit = origin.split(" "),
          xOrigin = parseFloat(originSplit[0]) || 0,
          yOrigin = parseFloat(originSplit[1]) || 0,
          bounds,
          determinant,
          x,
          y;

      if (!originIsAbsolute) {
        bounds = _getBBox(target);
        xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
      } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
        //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = x;
        yOrigin = y;
      }

      if (smooth || smooth !== false && cache.smooth) {
        tx = xOrigin - xOriginOld;
        ty = yOrigin - yOriginOld;
        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
      } else {
        cache.xOffset = cache.yOffset = 0;
      }

      cache.xOrigin = xOrigin;
      cache.yOrigin = yOrigin;
      cache.smooth = !!smooth;
      cache.origin = origin;
      cache.originIsAbsolute = !!originIsAbsolute;
      target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

      if (pluginToAddPropTweensTo) {
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
      }

      target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
    },
        _parseTransform = function _parseTransform(target, uncache) {
      var cache = target._gsap || new GSCache(target);

      if ("x" in cache && !uncache && !cache.uncache) {
        return cache;
      }

      var style = target.style,
          invertedScaleX = cache.scaleX < 0,
          px = "px",
          deg = "deg",
          origin = _getComputedProperty(target, _transformOriginProp) || "0",
          x,
          y,
          z,
          scaleX,
          scaleY,
          rotation,
          rotationX,
          rotationY,
          skewX,
          skewY,
          perspective,
          xOrigin,
          yOrigin,
          matrix,
          angle,
          cos,
          sin,
          a,
          b,
          c,
          d,
          a12,
          a22,
          t1,
          t2,
          t3,
          a13,
          a23,
          a33,
          a42,
          a43,
          a32;
      x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
      scaleX = scaleY = 1;
      cache.svg = !!(target.getCTM && _isSVG(target));
      matrix = _getMatrix(target, cache.svg);

      if (cache.svg) {
        t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
      }

      xOrigin = cache.xOrigin || 0;
      yOrigin = cache.yOrigin || 0;

      if (matrix !== _identity2DMatrix) {
        a = matrix[0]; //a11

        b = matrix[1]; //a21

        c = matrix[2]; //a31

        d = matrix[3]; //a41

        x = a12 = matrix[4];
        y = a22 = matrix[5]; //2D matrix

        if (matrix.length === 6) {
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

          skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
          skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

          if (cache.svg) {
            x -= xOrigin - (xOrigin * a + yOrigin * c);
            y -= yOrigin - (xOrigin * b + yOrigin * d);
          } //3D matrix

        } else {
          a32 = matrix[6];
          a42 = matrix[7];
          a13 = matrix[8];
          a23 = matrix[9];
          a33 = matrix[10];
          a43 = matrix[11];
          x = matrix[12];
          y = matrix[13];
          z = matrix[14];
          angle = _atan2(a32, a33);
          rotationX = angle * _RAD2DEG; //rotationX

          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a12 * cos + a13 * sin;
            t2 = a22 * cos + a23 * sin;
            t3 = a32 * cos + a33 * sin;
            a13 = a12 * -sin + a13 * cos;
            a23 = a22 * -sin + a23 * cos;
            a33 = a32 * -sin + a33 * cos;
            a43 = a42 * -sin + a43 * cos;
            a12 = t1;
            a22 = t2;
            a32 = t3;
          } //rotationY


          angle = _atan2(-c, a33);
          rotationY = angle * _RAD2DEG;

          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a * cos - a13 * sin;
            t2 = b * cos - a23 * sin;
            t3 = c * cos - a33 * sin;
            a43 = d * sin + a43 * cos;
            a = t1;
            b = t2;
            c = t3;
          } //rotationZ


          angle = _atan2(b, a);
          rotation = angle * _RAD2DEG;

          if (angle) {
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            t1 = a * cos + b * sin;
            t2 = a12 * cos + a22 * sin;
            b = b * cos - a * sin;
            a22 = a22 * cos - a12 * sin;
            a = t1;
            a12 = t2;
          }

          if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
            //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
            rotationX = rotation = 0;
            rotationY = 180 - rotationY;
          }

          scaleX = _round$1(Math.sqrt(a * a + b * b + c * c));
          scaleY = _round$1(Math.sqrt(a22 * a22 + a32 * a32));
          angle = _atan2(a12, a22);
          skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
          perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        }

        if (cache.svg) {
          //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
          t1 = target.getAttribute("transform");
          cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp$1));
          t1 && target.setAttribute("transform", t1);
        }
      }

      if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
        if (invertedScaleX) {
          scaleX *= -1;
          skewX += rotation <= 0 ? 180 : -180;
          rotation += rotation <= 0 ? 180 : -180;
        } else {
          scaleY *= -1;
          skewX += skewX <= 0 ? 180 : -180;
        }
      }

      uncache = uncache || cache.uncache;
      cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
      cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
      cache.z = z + px;
      cache.scaleX = _round$1(scaleX);
      cache.scaleY = _round$1(scaleY);
      cache.rotation = _round$1(rotation) + deg;
      cache.rotationX = _round$1(rotationX) + deg;
      cache.rotationY = _round$1(rotationY) + deg;
      cache.skewX = skewX + deg;
      cache.skewY = skewY + deg;
      cache.transformPerspective = perspective + px;

      if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
        style[_transformOriginProp] = _firstTwoOnly(origin);
      }

      cache.xOffset = cache.yOffset = 0;
      cache.force3D = _config.force3D;
      cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
      cache.uncache = 0;
      return cache;
    },
        _firstTwoOnly = function _firstTwoOnly(value) {
      return (value = value.split(" "))[0] + " " + value[1];
    },
        //for handling transformOrigin values, stripping out the 3rd dimension
    _addPxTranslate = function _addPxTranslate(target, start, value) {
      var unit = getUnit(start);
      return _round$1(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
    },
        _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
      cache.z = "0px";
      cache.rotationY = cache.rotationX = "0deg";
      cache.force3D = 0;

      _renderCSSTransforms(ratio, cache);
    },
        _zeroDeg = "0deg",
        _zeroPx = "0px",
        _endParenthesis = ") ",
        _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
      var _ref = cache || this,
          xPercent = _ref.xPercent,
          yPercent = _ref.yPercent,
          x = _ref.x,
          y = _ref.y,
          z = _ref.z,
          rotation = _ref.rotation,
          rotationY = _ref.rotationY,
          rotationX = _ref.rotationX,
          skewX = _ref.skewX,
          skewY = _ref.skewY,
          scaleX = _ref.scaleX,
          scaleY = _ref.scaleY,
          transformPerspective = _ref.transformPerspective,
          force3D = _ref.force3D,
          target = _ref.target,
          zOrigin = _ref.zOrigin,
          transforms = "",
          use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


      if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
        var angle = parseFloat(rotationY) * _DEG2RAD,
            a13 = Math.sin(angle),
            a33 = Math.cos(angle),
            cos;

        angle = parseFloat(rotationX) * _DEG2RAD;
        cos = Math.cos(angle);
        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
      }

      if (transformPerspective !== _zeroPx) {
        transforms += "perspective(" + transformPerspective + _endParenthesis;
      }

      if (xPercent || yPercent) {
        transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
      }

      if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
        transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
      }

      if (rotation !== _zeroDeg) {
        transforms += "rotate(" + rotation + _endParenthesis;
      }

      if (rotationY !== _zeroDeg) {
        transforms += "rotateY(" + rotationY + _endParenthesis;
      }

      if (rotationX !== _zeroDeg) {
        transforms += "rotateX(" + rotationX + _endParenthesis;
      }

      if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
        transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
      }

      if (scaleX !== 1 || scaleY !== 1) {
        transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
      }

      target.style[_transformProp$1] = transforms || "translate(0, 0)";
    },
        _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
      var _ref2 = cache || this,
          xPercent = _ref2.xPercent,
          yPercent = _ref2.yPercent,
          x = _ref2.x,
          y = _ref2.y,
          rotation = _ref2.rotation,
          skewX = _ref2.skewX,
          skewY = _ref2.skewY,
          scaleX = _ref2.scaleX,
          scaleY = _ref2.scaleY,
          target = _ref2.target,
          xOrigin = _ref2.xOrigin,
          yOrigin = _ref2.yOrigin,
          xOffset = _ref2.xOffset,
          yOffset = _ref2.yOffset,
          forceCSS = _ref2.forceCSS,
          tx = parseFloat(x),
          ty = parseFloat(y),
          a11,
          a21,
          a12,
          a22,
          temp;

      rotation = parseFloat(rotation);
      skewX = parseFloat(skewX);
      skewY = parseFloat(skewY);

      if (skewY) {
        //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
        skewY = parseFloat(skewY);
        skewX += skewY;
        rotation += skewY;
      }

      if (rotation || skewX) {
        rotation *= _DEG2RAD;
        skewX *= _DEG2RAD;
        a11 = Math.cos(rotation) * scaleX;
        a21 = Math.sin(rotation) * scaleX;
        a12 = Math.sin(rotation - skewX) * -scaleY;
        a22 = Math.cos(rotation - skewX) * scaleY;

        if (skewX) {
          skewY *= _DEG2RAD;
          temp = Math.tan(skewX - skewY);
          temp = Math.sqrt(1 + temp * temp);
          a12 *= temp;
          a22 *= temp;

          if (skewY) {
            temp = Math.tan(skewY);
            temp = Math.sqrt(1 + temp * temp);
            a11 *= temp;
            a21 *= temp;
          }
        }

        a11 = _round$1(a11);
        a21 = _round$1(a21);
        a12 = _round$1(a12);
        a22 = _round$1(a22);
      } else {
        a11 = scaleX;
        a22 = scaleY;
        a21 = a12 = 0;
      }

      if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
        tx = _convertToUnit(target, "x", x, "px");
        ty = _convertToUnit(target, "y", y, "px");
      }

      if (xOrigin || yOrigin || xOffset || yOffset) {
        tx = _round$1(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
        ty = _round$1(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
      }

      if (xPercent || yPercent) {
        //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
        temp = target.getBBox();
        tx = _round$1(tx + xPercent / 100 * temp.width);
        ty = _round$1(ty + yPercent / 100 * temp.height);
      }

      temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
      target.setAttribute("transform", temp);
      forceCSS && (target.style[_transformProp$1] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
    },
        _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
      var cap = 360,
          isString = _isString$1(endValue),
          endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
          change = endNum - startNum,
          finalValue = startNum + change + "deg",
          direction,
          pt;

      if (isString) {
        direction = endValue.split("_")[1];

        if (direction === "short") {
          change %= cap;

          if (change !== change % (cap / 2)) {
            change += change < 0 ? cap : -cap;
          }
        }

        if (direction === "cw" && change < 0) {
          change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
        } else if (direction === "ccw" && change > 0) {
          change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
        }
      }

      plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
      pt.e = finalValue;
      pt.u = "deg";

      plugin._props.push(property);

      return pt;
    },
        _assign = function _assign(target, source) {
      // Internet Explorer doesn't have Object.assign(), so we recreate it here.
      for (var p in source) {
        target[p] = source[p];
      }

      return target;
    },
        _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
      //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
      var startCache = _assign({}, target._gsap),
          exclude = "perspective,force3D,transformOrigin,svgOrigin",
          style = target.style,
          endCache,
          p,
          startValue,
          endValue,
          startNum,
          endNum,
          startUnit,
          endUnit;

      if (startCache.svg) {
        startValue = target.getAttribute("transform");
        target.setAttribute("transform", "");
        style[_transformProp$1] = transforms;
        endCache = _parseTransform(target, 1);

        _removeProperty(target, _transformProp$1);

        target.setAttribute("transform", startValue);
      } else {
        startValue = getComputedStyle(target)[_transformProp$1];
        style[_transformProp$1] = transforms;
        endCache = _parseTransform(target, 1);
        style[_transformProp$1] = startValue;
      }

      for (p in _transformProps) {
        startValue = startCache[p];
        endValue = endCache[p];

        if (startValue !== endValue && exclude.indexOf(p) < 0) {
          //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
          startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
          endNum = parseFloat(endValue);
          plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
          plugin._pt.u = endUnit || 0;

          plugin._props.push(p);
        }
      }

      _assign(endCache, startCache);
    }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


    _forEachName("padding,margin,Width,Radius", function (name, index) {
      var t = "Top",
          r = "Right",
          b = "Bottom",
          l = "Left",
          props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
        return index < 2 ? name + side : "border" + side + name;
      });

      _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
        var a, vars;

        if (arguments.length < 4) {
          // getter, passed target, property, and unit (from _get())
          a = props.map(function (prop) {
            return _get(plugin, prop, property);
          });
          vars = a.join(" ");
          return vars.split(a[0]).length === 5 ? a[0] : vars;
        }

        a = (endValue + "").split(" ");
        vars = {};
        props.forEach(function (prop, i) {
          return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
        });
        plugin.init(target, vars, tween);
      };
    });

    var CSSPlugin = {
      name: "css",
      register: _initCore$1,
      targetTest: function targetTest(target) {
        return target.style && target.nodeType;
      },
      init: function init(target, vars, tween, index, targets) {
        var props = this._props,
            style = target.style,
            startAt = tween.vars.startAt,
            startValue,
            endValue,
            endNum,
            startNum,
            type,
            specialProp,
            p,
            startUnit,
            endUnit,
            relative,
            isTransformRelated,
            transformPropTween,
            cache,
            smooth,
            hasPriority;
        _pluginInitted || _initCore$1();

        for (p in vars) {
          if (p === "autoRound") {
            continue;
          }

          endValue = vars[p];

          if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
            // plugins
            continue;
          }

          type = typeof endValue;
          specialProp = _specialProps[p];

          if (type === "function") {
            endValue = endValue.call(tween, index, target, targets);
            type = typeof endValue;
          }

          if (type === "string" && ~endValue.indexOf("random(")) {
            endValue = _replaceRandom(endValue);
          }

          if (specialProp) {
            specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
          } else if (p.substr(0, 2) === "--") {
            //CSS variable
            startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
            endValue += "";
            _colorExp.lastIndex = 0;

            if (!_colorExp.test(startValue)) {
              // colors don't have units
              startUnit = getUnit(startValue);
              endUnit = getUnit(endValue);
            }

            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
            this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
            props.push(p);
          } else if (type !== "undefined") {
            if (startAt && p in startAt) {
              // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
              startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
              _isString$1(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
              getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

              (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
            } else {
              startValue = _get(target, p);
            }

            startNum = parseFloat(startValue);
            relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
            relative && (endValue = endValue.substr(2));
            endNum = parseFloat(endValue);

            if (p in _propertyAliases) {
              if (p === "autoAlpha") {
                //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                  //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                  startNum = 0;
                }

                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
              }

              if (p !== "scale" && p !== "transform") {
                p = _propertyAliases[p];
                ~p.indexOf(",") && (p = p.split(",")[0]);
              }
            }

            isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

            if (isTransformRelated) {
              if (!transformPropTween) {
                cache = target._gsap;
                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

                smooth = vars.smoothOrigin !== false && cache.smooth;
                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp$1, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

                transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
              }

              if (p === "scale") {
                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
                props.push("scaleY", p);
                p += "X";
              } else if (p === "transformOrigin") {
                endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

                if (cache.svg) {
                  _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                } else {
                  endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

                  endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

                  _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                }

                continue;
              } else if (p === "svgOrigin") {
                _applySVGOrigin(target, endValue, 1, smooth, 0, this);

                continue;
              } else if (p in _rotationalProperties) {
                _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);

                continue;
              } else if (p === "smoothOrigin") {
                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

                continue;
              } else if (p === "force3D") {
                cache[p] = endValue;
                continue;
              } else if (p === "transform") {
                _addRawTransformPTs(this, endValue, target);

                continue;
              }
            } else if (!(p in style)) {
              p = _checkPropPrefix(p) || p;
            }

            if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
              startUnit = (startValue + "").substr((startNum + "").length);
              endNum || (endNum = 0); // protect against NaN

              endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
              startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
              this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
              this._pt.u = endUnit || 0;

              if (startUnit !== endUnit && endUnit !== "%") {
                //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
                this._pt.b = startValue;
                this._pt.r = _renderCSSPropWithBeginning;
              }
            } else if (!(p in style)) {
              if (p in target) {
                //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
                this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
              } else {
                _missingPlugin(p, endValue);

                continue;
              }
            } else {
              _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
            }

            props.push(p);
          }
        }

        hasPriority && _sortPropTweensByPriority(this);
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
        var p = _propertyAliases[property];
        p && p.indexOf(",") < 0 && (property = p);
        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
      },
      core: {
        _removeProperty: _removeProperty,
        _getMatrix: _getMatrix
      }
    };
    gsap$2.utils.checkPrefix = _checkPropPrefix;

    (function (positionAndScale, rotation, others, aliases) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
        _transformProps[name] = 1;
      });

      _forEachName(rotation, function (name) {
        _config.units[name] = "deg";
        _rotationalProperties[name] = 1;
      });

      _propertyAliases[all[13]] = positionAndScale + "," + rotation;

      _forEachName(aliases, function (name) {
        var split = name.split(":");
        _propertyAliases[split[1]] = all[split[0]];
      });
    })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
      _config.units[name] = "px";
    });

    gsap$2.registerPlugin(CSSPlugin);

    var gsapWithCSS$1 = gsap$2.registerPlugin(CSSPlugin) || gsap$2;
        // to protect from tree shaking
    gsapWithCSS$1.core.Tween;

    /** 
    * Revealer classes and animation adpated from Codrops example at https://tympanus.net/codrops/2019/04/18/how-to-create-and-animate-rotated-overlays/ | Licensed under the MIT license.  http://www.opensource.org/licenses/mit-license.php  | Copyright 2019, Codrops  http://www.codrops.com
    */

    class Revealer {
        constructor(el, options) {
            this.options = { angle: 0 };
            Object.assign(this.options, options);

            this.DOM = {};
            this.DOM.el = el;
            this.DOM.inner = this.DOM.el.firstElementChild;
            
            this.DOM.inner.style.width = `calc(100vw * ${Math.abs(Math.cos(this.options.angle * Math.PI/180))} + 102.5vh * ${Math.abs(Math.sin(this.options.angle * Math.PI/180))})`;
            this.DOM.inner.style.height = `calc(100vw * ${Math.abs(Math.sin(this.options.angle * Math.PI/180))} + 102.5vh * ${Math.abs(Math.cos(this.options.angle * Math.PI/180))})`;
            this.DOM.el.style.transform = `rotate3d(0,0,1,${this.options.angle}deg)`;

            this.DOM.reverse = this.DOM.inner.querySelector('.content__reverse');
            if ( this.DOM.reverse ) {
                gsapWithCSS$1.set(this.DOM.reverse, {rotation: -1 * this.options.angle});
            }
        }
    }

    /* src/components/shared/Logo.svelte generated by Svelte v3.48.0 */

    const file$v = "src/components/shared/Logo.svelte";

    function create_fragment$v(ctx) {
    	let svg;
    	let g0;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let g1;
    	let path4;
    	let path5;
    	let path6;
    	let path7;
    	let path8;
    	let path9;
    	let path10;
    	let path11;
    	let path12;
    	let path13;
    	let path14;
    	let path15;
    	let svg_width_value;
    	let svg_height_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			g1 = svg_element("g");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			attr_dev(path0, "d", "M.25 18.65v3.96h22.3L.25 61.84h30.79v-3.96H7.02l22.34-39.23H.25z");
    			attr_dev(path0, "class", "z svelte-huk8x3");
    			add_location(path0, file$v, 6, 8, 231);
    			attr_dev(path1, "d", "M41.43 28.28v33.56h-3.96V18.65h3.96v2.77c3.28-3.44 7.83-5.38 12.58-5.37 9.17-.41 16.94 6.69 17.36 15.86.02.35.02.69.01 1.04v28.9h-3.96V33.3c.05-3.55-1.39-6.96-3.98-9.39-5.21-5.16-13.6-5.19-18.85-.07a14.987 14.987 0 0 0-3.16 4.44");
    			add_location(path1, file$v, 7, 8, 326);
    			attr_dev(path2, "d", "M111.29 22.92c-8.84-6.59-21.34-4.77-27.93 4.07a19.95 19.95 0 0 0 0 23.86l27.93-27.93zM86.05 53.75c3.6 3.35 8.36 5.18 13.28 5.1 5.31.08 10.42-2.03 14.12-5.85.5-.5.97-1.01 1.41-1.54l4.18 1.5c-.78 1.08-1.65 2.1-2.6 3.04-9.46 9.39-24.74 9.34-34.13-.11-9.39-9.46-9.34-24.74.11-34.13 8.64-8.58 22.32-9.38 31.91-1.87.7.59 1.41 1.23 2.11 1.93.27.26.51.53.75.79l-2.99 2.99-28.15 28.15z");
    			add_location(path2, file$v, 8, 8, 575);
    			attr_dev(path3, "d", "M128.99.27v18.38h-8.8v3.96h8.8v39.23h3.96V22.61h8.8v-3.96h-8.8V.27h-3.96z");
    			add_location(path3, file$v, 9, 8, 972);
    			attr_dev(g0, "class", "logo-title svelte-huk8x3");
    			add_location(g0, file$v, 5, 4, 200);
    			attr_dev(path4, "d", "M6.33 67.82v3.4H2.02v-3.4H1.3v7.71h.72v-3.66h4.31v3.66h.72v-7.71h-.72z");
    			add_location(path4, file$v, 12, 8, 1105);
    			attr_dev(path5, "d", "M13.25 67.82v7.71h4.89v-.65h-4.17v-3h3.74v-.65h-3.74v-2.74h4v-.65l-4.72-.02z");
    			add_location(path5, file$v, 13, 8, 1196);
    			attr_dev(path6, "d", "M24.53 71.22h1.63c.2 0 .4-.02.6-.07.19-.04.36-.12.52-.23.16-.11.28-.25.37-.42.1-.2.15-.42.14-.64.01-.22-.04-.44-.15-.63-.09-.17-.22-.32-.38-.43-.16-.11-.34-.2-.54-.24-.2-.05-.4-.08-.61-.08h-1.59l.01 2.74zm-.72-3.4h2.22c.28 0 .57.03.84.09.29.06.56.17.81.32.25.16.45.37.6.63.17.31.25.65.23 1 .01.31-.06.62-.19.9-.12.25-.29.46-.51.63-.22.17-.47.29-.74.36-.29.08-.58.12-.88.12h-1.67v3.66h-.72l.01-7.71z");
    			add_location(path6, file$v, 14, 8, 1293);
    			attr_dev(path7, "d", "M34.86 74.88h1.64c.35.01.69-.04 1.02-.15.22-.08.43-.21.59-.38.13-.14.22-.3.28-.48.04-.15.07-.31.07-.46.01-.25-.05-.5-.17-.73-.1-.2-.25-.36-.42-.49-.18-.13-.38-.22-.59-.28-.22-.06-.44-.09-.67-.09h-1.75v3.06zm0-3.72h1.49c.31.01.61-.04.9-.14.2-.07.39-.19.55-.33.12-.12.21-.26.26-.42.04-.13.06-.27.07-.41.01-.23-.04-.46-.14-.67-.08-.17-.21-.32-.36-.42-.16-.11-.34-.19-.53-.22-.21-.04-.43-.07-.64-.07h-1.59l-.01 2.68zm-.72-3.34h2.22c.3 0 .59.02.88.07.28.04.56.14.8.29.24.15.44.37.58.62.16.32.24.69.22 1.05.01.37-.12.73-.35 1.02-.27.31-.63.51-1.03.58v.02c.24.02.48.08.7.18.2.09.39.23.54.39.16.17.28.37.35.58.09.24.13.49.13.74.02.38-.07.75-.26 1.08-.16.27-.38.49-.64.66-.26.16-.54.27-.84.33-.28.06-.56.09-.84.09h-2.46v-7.7z");
    			add_location(path7, file$v, 15, 8, 1712);
    			attr_dev(path8, "d", "M50.66 72.58c0 .4-.05.8-.14 1.19-.09.36-.25.7-.47 1-.23.3-.53.54-.87.7-.85.35-1.8.35-2.64 0-.34-.16-.64-.4-.87-.7-.23-.3-.39-.64-.47-1-.1-.39-.14-.79-.14-1.19v-4.76h.72v4.57c0 .3.03.59.08.88.05.31.15.6.3.87s.37.5.63.66c.68.35 1.49.35 2.17 0 .26-.16.48-.39.63-.66.15-.27.25-.57.3-.87.05-.29.07-.59.08-.88v-4.57h.72l-.03 4.76z");
    			add_location(path8, file$v, 16, 8, 2449);
    			attr_dev(path9, "d", "M57.54 71.22h1.52c.31.01.62-.04.92-.14.21-.07.39-.19.55-.35.12-.13.21-.28.27-.45.09-.28.09-.59 0-.87-.05-.17-.14-.32-.27-.45-.16-.15-.34-.27-.55-.35-.29-.11-.61-.15-.92-.14h-1.52v2.75zm-.72-3.4h2.02c.1 0 .24 0 .41.01.19.01.38.03.57.07.21.04.42.1.62.17.21.08.4.2.57.35a1.85 1.85 0 0 1 .57 1.43c.01.32-.05.63-.19.92-.12.23-.28.42-.48.58-.19.15-.41.26-.64.33-.22.07-.44.12-.66.15l2.24 3.7h-.82l-2.17-3.66h-1.34v3.67h-.71l.01-7.72z");
    			add_location(path9, file$v, 17, 8, 2794);
    			attr_dev(path10, "d", "M73.29 67.82v6.75h-.02l-4.69-6.75h-.92v7.71h.72v-6.75h.02l4.69 6.75h.92v-7.71h-.72z");
    			add_location(path10, file$v, 18, 8, 3242);
    			attr_dev(path11, "d", "M87.21 74.11c.17.31.43.56.73.73.32.16.67.25 1.03.24.23 0 .46-.03.67-.11.2-.07.39-.17.55-.3.15-.13.28-.29.37-.47.09-.2.14-.41.14-.63.01-.23-.05-.46-.17-.66-.11-.18-.27-.32-.45-.43-.2-.12-.42-.21-.64-.29-.23-.08-.48-.16-.73-.24s-.49-.17-.73-.27c-.23-.1-.45-.23-.64-.4s-.35-.38-.45-.61c-.12-.29-.18-.6-.17-.92-.01-.61.26-1.2.74-1.57.24-.18.5-.32.79-.4.3-.09.62-.14.93-.14.4 0 .8.07 1.17.22.37.16.69.42.93.75l-.62.45a1.76 1.76 0 0 0-.64-.57c-.27-.13-.57-.2-.86-.19-.22 0-.45.03-.66.09-.2.06-.38.15-.55.27a1.301 1.301 0 0 0-.52 1.09c-.02.32.08.64.29.89.21.21.46.38.73.49.31.13.63.23.96.32.33.09.65.21.96.36.29.15.54.37.73.64.21.34.32.73.29 1.13 0 .32-.06.64-.2.93-.13.26-.31.49-.53.68-.23.19-.49.33-.77.42-.29.09-.59.14-.9.14-.48 0-.96-.09-1.4-.27-.44-.19-.83-.5-1.1-.9l.72-.47z");
    			add_location(path11, file$v, 19, 8, 3346);
    			attr_dev(path12, "d", "M102.4 67.82v3.4h-4.31v-3.4h-.72v7.71h.72v-3.66h4.31v3.66h.72v-7.71h-.72z");
    			add_location(path12, file$v, 20, 8, 4140);
    			attr_dev(path13, "d", "M109.59 67.82h.72v7.71h-.72z");
    			add_location(path13, file$v, 21, 8, 4234);
    			attr_dev(path14, "d", "M117.5 71.22h1.52c.31.01.62-.04.92-.14.21-.07.39-.19.55-.35.12-.13.22-.28.27-.45.09-.28.09-.59 0-.87-.05-.17-.14-.32-.27-.45-.16-.15-.34-.27-.55-.35-.29-.11-.61-.15-.92-.14h-1.52v2.75zm-.72-3.4h2.02c.1 0 .24 0 .41.01.19.01.38.03.57.07.21.04.42.1.62.17.21.08.4.2.57.35a1.85 1.85 0 0 1 .57 1.43c.01.32-.05.63-.19.92-.12.23-.28.42-.48.58-.19.15-.41.26-.64.33-.22.07-.44.12-.66.15l2.24 3.7H121l-2.17-3.65h-1.34v3.66h-.72l.01-7.72z");
    			add_location(path14, file$v, 22, 8, 4283);
    			attr_dev(path15, "d", "M127.6 67.82v7.71h4.89v-.65h-4.17v-3h3.74v-.65h-3.74v-2.74h4v-.65l-4.72-.02z");
    			add_location(path15, file$v, 23, 8, 4730);
    			attr_dev(g1, "class", "logo-subtitle svelte-huk8x3");
    			add_location(g1, file$v, 11, 4, 1071);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", svg_width_value = /*type*/ ctx[0] === 'width' ? '100%' : null);
    			attr_dev(svg, "height", svg_height_value = /*type*/ ctx[0] === 'height' ? '100%' : null);
    			attr_dev(svg, "viewBox", "0 0 142 76");
    			add_location(svg, file$v, 4, 0, 50);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(g0, path0);
    			append_dev(g0, path1);
    			append_dev(g0, path2);
    			append_dev(g0, path3);
    			append_dev(svg, g1);
    			append_dev(g1, path4);
    			append_dev(g1, path5);
    			append_dev(g1, path6);
    			append_dev(g1, path7);
    			append_dev(g1, path8);
    			append_dev(g1, path9);
    			append_dev(g1, path10);
    			append_dev(g1, path11);
    			append_dev(g1, path12);
    			append_dev(g1, path13);
    			append_dev(g1, path14);
    			append_dev(g1, path15);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*type*/ 1 && svg_width_value !== (svg_width_value = /*type*/ ctx[0] === 'width' ? '100%' : null)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*type*/ 1 && svg_height_value !== (svg_height_value = /*type*/ ctx[0] === 'height' ? '100%' : null)) {
    				attr_dev(svg, "height", svg_height_value);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Logo', slots, []);
    	let { type = 'width' } = $$props;
    	const writable_props = ['type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Logo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(0, type = $$props.type);
    	};

    	$$self.$capture_state = () => ({ type });

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(0, type = $$props.type);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [type];
    }

    class Logo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$v, create_fragment$v, safe_not_equal, { type: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logo",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get type() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/Title.svelte generated by Svelte v3.48.0 */
    const file$u = "src/components/byPage/postcards/postcard/Title.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (14:8) {#if actionData["Project leads"]}
    function create_if_block$c(ctx) {
    	let h3;
    	let t;
    	let each_value = /*actionData*/ ctx[0]["Project leads"].map(/*func*/ ctx[2]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t = text$1("Led by            \n            ");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "svelte-8gygjn");
    			add_location(h3, file$u, 14, 8, 410);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(h3, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*actionData, $data*/ 3) {
    				each_value = /*actionData*/ ctx[0]["Project leads"].map(/*func*/ ctx[2]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(h3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(14:8) {#if actionData[\\\"Project leads\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (17:16) {#if i  > 0}
    function create_if_block_1$a(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[5] === /*actionData*/ ctx[0]["Project leads"].length - 1) return create_if_block_2$8;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(17:16) {#if i  > 0}",
    		ctx
    	});

    	return block;
    }

    // (18:80) {:else}
    function create_else_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(",");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(18:80) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:20) {#if i === actionData["Project leads"].length - 1}
    function create_if_block_2$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(" and");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(18:20) {#if i === actionData[\\\"Project leads\\\"].length - 1}",
    		ctx
    	});

    	return block;
    }

    // (16:12) {#each actionData["Project leads"].map(d => $data.stakeholders.filter(e => e.recordID === d)[0].Name)  as lead, i}
    function create_each_block$h(ctx) {
    	let t;
    	let html_tag;
    	let raw_value = /*lead*/ ctx[3] + "";
    	let html_anchor;
    	let if_block = /*i*/ ctx[5] > 0 && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			html_tag = new HtmlTag(false);
    			html_anchor = empty$3();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[5] > 0) if_block.p(ctx, dirty);
    			if (dirty & /*actionData, $data*/ 3 && raw_value !== (raw_value = /*lead*/ ctx[3] + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(16:12) {#each actionData[\\\"Project leads\\\"].map(d => $data.stakeholders.filter(e => e.recordID === d)[0].Name)  as lead, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let section;
    	let div;
    	let h1;
    	let raw_value = /*actionData*/ ctx[0].Name + "";
    	let t;
    	let if_block = /*actionData*/ ctx[0]["Project leads"] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			h1 = element("h1");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(h1, "class", "svelte-8gygjn");
    			toggle_class(h1, "three-line", /*actionData*/ ctx[0].Name.length > 70);
    			add_location(h1, file$u, 12, 8, 278);
    			attr_dev(div, "class", "main-title svelte-8gygjn");
    			add_location(div, file$u, 11, 4, 243);
    			attr_dev(section, "class", "title svelte-8gygjn");
    			add_location(section, file$u, 10, 0, 214);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			append_dev(div, h1);
    			h1.innerHTML = raw_value;
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*actionData*/ 1 && raw_value !== (raw_value = /*actionData*/ ctx[0].Name + "")) h1.innerHTML = raw_value;
    			if (dirty & /*actionData*/ 1) {
    				toggle_class(h1, "three-line", /*actionData*/ ctx[0].Name.length > 70);
    			}

    			if (/*actionData*/ ctx[0]["Project leads"]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Title', slots, []);
    	let { actionData } = $$props;
    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Title> was created with unknown prop '${key}'`);
    	});

    	const func = d => $data.stakeholders.filter(e => e.recordID === d)[0].Name;

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({ Logo, data, actionData, $data });

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actionData, $data, func];
    }

    class Title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$u, create_fragment$u, safe_not_equal, { actionData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[0] === undefined && !('actionData' in props)) {
    			console.warn("<Title> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    var showdown = createCommonjsModule(function (module) {
    (function(){
    /**
     * Created by Tivie on 13-07-2015.
     */

    function getDefaultOpts (simple) {

      var defaultOptions = {
        omitExtraWLInCodeBlocks: {
          defaultValue: false,
          describe: 'Omit the default extra whiteline added to code blocks',
          type: 'boolean'
        },
        noHeaderId: {
          defaultValue: false,
          describe: 'Turn on/off generated header id',
          type: 'boolean'
        },
        prefixHeaderId: {
          defaultValue: false,
          describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
          type: 'string'
        },
        rawPrefixHeaderId: {
          defaultValue: false,
          describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
          type: 'boolean'
        },
        ghCompatibleHeaderId: {
          defaultValue: false,
          describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
          type: 'boolean'
        },
        rawHeaderId: {
          defaultValue: false,
          describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
          type: 'boolean'
        },
        headerLevelStart: {
          defaultValue: false,
          describe: 'The header blocks level start',
          type: 'integer'
        },
        parseImgDimensions: {
          defaultValue: false,
          describe: 'Turn on/off image dimension parsing',
          type: 'boolean'
        },
        simplifiedAutoLink: {
          defaultValue: false,
          describe: 'Turn on/off GFM autolink style',
          type: 'boolean'
        },
        excludeTrailingPunctuationFromURLs: {
          defaultValue: false,
          describe: 'Excludes trailing punctuation from links generated with autoLinking',
          type: 'boolean'
        },
        literalMidWordUnderscores: {
          defaultValue: false,
          describe: 'Parse midword underscores as literal underscores',
          type: 'boolean'
        },
        literalMidWordAsterisks: {
          defaultValue: false,
          describe: 'Parse midword asterisks as literal asterisks',
          type: 'boolean'
        },
        strikethrough: {
          defaultValue: false,
          describe: 'Turn on/off strikethrough support',
          type: 'boolean'
        },
        tables: {
          defaultValue: false,
          describe: 'Turn on/off tables support',
          type: 'boolean'
        },
        tablesHeaderId: {
          defaultValue: false,
          describe: 'Add an id to table headers',
          type: 'boolean'
        },
        ghCodeBlocks: {
          defaultValue: true,
          describe: 'Turn on/off GFM fenced code blocks support',
          type: 'boolean'
        },
        tasklists: {
          defaultValue: false,
          describe: 'Turn on/off GFM tasklist support',
          type: 'boolean'
        },
        smoothLivePreview: {
          defaultValue: false,
          describe: 'Prevents weird effects in live previews due to incomplete input',
          type: 'boolean'
        },
        smartIndentationFix: {
          defaultValue: false,
          describe: 'Tries to smartly fix indentation in es6 strings',
          type: 'boolean'
        },
        disableForced4SpacesIndentedSublists: {
          defaultValue: false,
          describe: 'Disables the requirement of indenting nested sublists by 4 spaces',
          type: 'boolean'
        },
        simpleLineBreaks: {
          defaultValue: false,
          describe: 'Parses simple line breaks as <br> (GFM Style)',
          type: 'boolean'
        },
        requireSpaceBeforeHeadingText: {
          defaultValue: false,
          describe: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
          type: 'boolean'
        },
        ghMentions: {
          defaultValue: false,
          describe: 'Enables github @mentions',
          type: 'boolean'
        },
        ghMentionsLink: {
          defaultValue: 'https://github.com/{u}',
          describe: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
          type: 'string'
        },
        encodeEmails: {
          defaultValue: true,
          describe: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
          type: 'boolean'
        },
        openLinksInNewWindow: {
          defaultValue: false,
          describe: 'Open all links in new windows',
          type: 'boolean'
        },
        backslashEscapesHTMLTags: {
          defaultValue: false,
          describe: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
          type: 'boolean'
        },
        emoji: {
          defaultValue: false,
          describe: 'Enable emoji support. Ex: `this is a :smile: emoji`',
          type: 'boolean'
        },
        underline: {
          defaultValue: false,
          describe: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
          type: 'boolean'
        },
        ellipsis: {
          defaultValue: true,
          describe: 'Replaces three dots with the ellipsis unicode character',
          type: 'boolean'
        },
        completeHTMLDocument: {
          defaultValue: false,
          describe: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
          type: 'boolean'
        },
        metadata: {
          defaultValue: false,
          describe: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
          type: 'boolean'
        },
        splitAdjacentBlockquotes: {
          defaultValue: false,
          describe: 'Split adjacent blockquote blocks',
          type: 'boolean'
        }
      };
      if (simple === false) {
        return JSON.parse(JSON.stringify(defaultOptions));
      }
      var ret = {};
      for (var opt in defaultOptions) {
        if (defaultOptions.hasOwnProperty(opt)) {
          ret[opt] = defaultOptions[opt].defaultValue;
        }
      }
      return ret;
    }

    function allOptionsOn () {
      var options = getDefaultOpts(true),
          ret = {};
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          ret[opt] = true;
        }
      }
      return ret;
    }

    /**
     * Created by Tivie on 06-01-2015.
     */

    // Private properties
    var showdown = {},
        parsers = {},
        extensions = {},
        globalOptions = getDefaultOpts(true),
        setFlavor = 'vanilla',
        flavor = {
          github: {
            omitExtraWLInCodeBlocks:              true,
            simplifiedAutoLink:                   true,
            excludeTrailingPunctuationFromURLs:   true,
            literalMidWordUnderscores:            true,
            strikethrough:                        true,
            tables:                               true,
            tablesHeaderId:                       true,
            ghCodeBlocks:                         true,
            tasklists:                            true,
            disableForced4SpacesIndentedSublists: true,
            simpleLineBreaks:                     true,
            requireSpaceBeforeHeadingText:        true,
            ghCompatibleHeaderId:                 true,
            ghMentions:                           true,
            backslashEscapesHTMLTags:             true,
            emoji:                                true,
            splitAdjacentBlockquotes:             true
          },
          original: {
            noHeaderId:                           true,
            ghCodeBlocks:                         false
          },
          ghost: {
            omitExtraWLInCodeBlocks:              true,
            parseImgDimensions:                   true,
            simplifiedAutoLink:                   true,
            excludeTrailingPunctuationFromURLs:   true,
            literalMidWordUnderscores:            true,
            strikethrough:                        true,
            tables:                               true,
            tablesHeaderId:                       true,
            ghCodeBlocks:                         true,
            tasklists:                            true,
            smoothLivePreview:                    true,
            simpleLineBreaks:                     true,
            requireSpaceBeforeHeadingText:        true,
            ghMentions:                           false,
            encodeEmails:                         true
          },
          vanilla: getDefaultOpts(true),
          allOn: allOptionsOn()
        };

    /**
     * helper namespace
     * @type {{}}
     */
    showdown.helper = {};

    /**
     * TODO LEGACY SUPPORT CODE
     * @type {{}}
     */
    showdown.extensions = {};

    /**
     * Set a global option
     * @static
     * @param {string} key
     * @param {*} value
     * @returns {showdown}
     */
    showdown.setOption = function (key, value) {
      globalOptions[key] = value;
      return this;
    };

    /**
     * Get a global option
     * @static
     * @param {string} key
     * @returns {*}
     */
    showdown.getOption = function (key) {
      return globalOptions[key];
    };

    /**
     * Get the global options
     * @static
     * @returns {{}}
     */
    showdown.getOptions = function () {
      return globalOptions;
    };

    /**
     * Reset global options to the default values
     * @static
     */
    showdown.resetOptions = function () {
      globalOptions = getDefaultOpts(true);
    };

    /**
     * Set the flavor showdown should use as default
     * @param {string} name
     */
    showdown.setFlavor = function (name) {
      if (!flavor.hasOwnProperty(name)) {
        throw Error(name + ' flavor was not found');
      }
      showdown.resetOptions();
      var preset = flavor[name];
      setFlavor = name;
      for (var option in preset) {
        if (preset.hasOwnProperty(option)) {
          globalOptions[option] = preset[option];
        }
      }
    };

    /**
     * Get the currently set flavor
     * @returns {string}
     */
    showdown.getFlavor = function () {
      return setFlavor;
    };

    /**
     * Get the options of a specified flavor. Returns undefined if the flavor was not found
     * @param {string} name Name of the flavor
     * @returns {{}|undefined}
     */
    showdown.getFlavorOptions = function (name) {
      if (flavor.hasOwnProperty(name)) {
        return flavor[name];
      }
    };

    /**
     * Get the default options
     * @static
     * @param {boolean} [simple=true]
     * @returns {{}}
     */
    showdown.getDefaultOptions = function (simple) {
      return getDefaultOpts(simple);
    };

    /**
     * Get or set a subParser
     *
     * subParser(name)       - Get a registered subParser
     * subParser(name, func) - Register a subParser
     * @static
     * @param {string} name
     * @param {function} [func]
     * @returns {*}
     */
    showdown.subParser = function (name, func) {
      if (showdown.helper.isString(name)) {
        if (typeof func !== 'undefined') {
          parsers[name] = func;
        } else {
          if (parsers.hasOwnProperty(name)) {
            return parsers[name];
          } else {
            throw Error('SubParser named ' + name + ' not registered!');
          }
        }
      }
    };

    /**
     * Gets or registers an extension
     * @static
     * @param {string} name
     * @param {object|object[]|function=} ext
     * @returns {*}
     */
    showdown.extension = function (name, ext) {

      if (!showdown.helper.isString(name)) {
        throw Error('Extension \'name\' must be a string');
      }

      name = showdown.helper.stdExtName(name);

      // Getter
      if (showdown.helper.isUndefined(ext)) {
        if (!extensions.hasOwnProperty(name)) {
          throw Error('Extension named ' + name + ' is not registered!');
        }
        return extensions[name];

        // Setter
      } else {
        // Expand extension if it's wrapped in a function
        if (typeof ext === 'function') {
          ext = ext();
        }

        // Ensure extension is an array
        if (!showdown.helper.isArray(ext)) {
          ext = [ext];
        }

        var validExtension = validate(ext, name);

        if (validExtension.valid) {
          extensions[name] = ext;
        } else {
          throw Error(validExtension.error);
        }
      }
    };

    /**
     * Gets all extensions registered
     * @returns {{}}
     */
    showdown.getAllExtensions = function () {
      return extensions;
    };

    /**
     * Remove an extension
     * @param {string} name
     */
    showdown.removeExtension = function (name) {
      delete extensions[name];
    };

    /**
     * Removes all extensions
     */
    showdown.resetExtensions = function () {
      extensions = {};
    };

    /**
     * Validate extension
     * @param {array} extension
     * @param {string} name
     * @returns {{valid: boolean, error: string}}
     */
    function validate (extension, name) {

      var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
          ret = {
            valid: true,
            error: ''
          };

      if (!showdown.helper.isArray(extension)) {
        extension = [extension];
      }

      for (var i = 0; i < extension.length; ++i) {
        var baseMsg = errMsg + ' sub-extension ' + i + ': ',
            ext = extension[i];
        if (typeof ext !== 'object') {
          ret.valid = false;
          ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
          return ret;
        }

        if (!showdown.helper.isString(ext.type)) {
          ret.valid = false;
          ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
          return ret;
        }

        var type = ext.type = ext.type.toLowerCase();

        // normalize extension type
        if (type === 'language') {
          type = ext.type = 'lang';
        }

        if (type === 'html') {
          type = ext.type = 'output';
        }

        if (type !== 'lang' && type !== 'output' && type !== 'listener') {
          ret.valid = false;
          ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
          return ret;
        }

        if (type === 'listener') {
          if (showdown.helper.isUndefined(ext.listeners)) {
            ret.valid = false;
            ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
            return ret;
          }
        } else {
          if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
            ret.valid = false;
            ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
            return ret;
          }
        }

        if (ext.listeners) {
          if (typeof ext.listeners !== 'object') {
            ret.valid = false;
            ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
            return ret;
          }
          for (var ln in ext.listeners) {
            if (ext.listeners.hasOwnProperty(ln)) {
              if (typeof ext.listeners[ln] !== 'function') {
                ret.valid = false;
                ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
                  ' must be a function but ' + typeof ext.listeners[ln] + ' given';
                return ret;
              }
            }
          }
        }

        if (ext.filter) {
          if (typeof ext.filter !== 'function') {
            ret.valid = false;
            ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
            return ret;
          }
        } else if (ext.regex) {
          if (showdown.helper.isString(ext.regex)) {
            ext.regex = new RegExp(ext.regex, 'g');
          }
          if (!(ext.regex instanceof RegExp)) {
            ret.valid = false;
            ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
            return ret;
          }
          if (showdown.helper.isUndefined(ext.replace)) {
            ret.valid = false;
            ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
            return ret;
          }
        }
      }
      return ret;
    }

    /**
     * Validate extension
     * @param {object} ext
     * @returns {boolean}
     */
    showdown.validateExtension = function (ext) {

      var validateExtension = validate(ext, null);
      if (!validateExtension.valid) {
        console.warn(validateExtension.error);
        return false;
      }
      return true;
    };

    /**
     * showdownjs helper functions
     */

    if (!showdown.hasOwnProperty('helper')) {
      showdown.helper = {};
    }

    /**
     * Check if var is string
     * @static
     * @param {string} a
     * @returns {boolean}
     */
    showdown.helper.isString = function (a) {
      return (typeof a === 'string' || a instanceof String);
    };

    /**
     * Check if var is a function
     * @static
     * @param {*} a
     * @returns {boolean}
     */
    showdown.helper.isFunction = function (a) {
      var getType = {};
      return a && getType.toString.call(a) === '[object Function]';
    };

    /**
     * isArray helper function
     * @static
     * @param {*} a
     * @returns {boolean}
     */
    showdown.helper.isArray = function (a) {
      return Array.isArray(a);
    };

    /**
     * Check if value is undefined
     * @static
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     */
    showdown.helper.isUndefined = function (value) {
      return typeof value === 'undefined';
    };

    /**
     * ForEach helper function
     * Iterates over Arrays and Objects (own properties only)
     * @static
     * @param {*} obj
     * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
     */
    showdown.helper.forEach = function (obj, callback) {
      // check if obj is defined
      if (showdown.helper.isUndefined(obj)) {
        throw new Error('obj param is required');
      }

      if (showdown.helper.isUndefined(callback)) {
        throw new Error('callback param is required');
      }

      if (!showdown.helper.isFunction(callback)) {
        throw new Error('callback param must be a function/closure');
      }

      if (typeof obj.forEach === 'function') {
        obj.forEach(callback);
      } else if (showdown.helper.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          callback(obj[i], i, obj);
        }
      } else if (typeof (obj) === 'object') {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            callback(obj[prop], prop, obj);
          }
        }
      } else {
        throw new Error('obj does not seem to be an array or an iterable object');
      }
    };

    /**
     * Standardidize extension name
     * @static
     * @param {string} s extension name
     * @returns {string}
     */
    showdown.helper.stdExtName = function (s) {
      return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
    };

    function escapeCharactersCallback (wholeMatch, m1) {
      var charCodeToEscape = m1.charCodeAt(0);
      return '¨E' + charCodeToEscape + 'E';
    }

    /**
     * Callback used to escape characters when passing through String.replace
     * @static
     * @param {string} wholeMatch
     * @param {string} m1
     * @returns {string}
     */
    showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

    /**
     * Escape characters in a string
     * @static
     * @param {string} text
     * @param {string} charsToEscape
     * @param {boolean} afterBackslash
     * @returns {XML|string|void|*}
     */
    showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
      // First we have to escape the escape characters so that
      // we can build a character class out of them
      var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

      if (afterBackslash) {
        regexString = '\\\\' + regexString;
      }

      var regex = new RegExp(regexString, 'g');
      text = text.replace(regex, escapeCharactersCallback);

      return text;
    };

    /**
     * Unescape HTML entities
     * @param txt
     * @returns {string}
     */
    showdown.helper.unescapeHTMLEntities = function (txt) {

      return txt
        .replace(/&quot;/g, '"')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
    };

    var rgxFindMatchPos = function (str, left, right, flags) {
      var f = flags || '',
          g = f.indexOf('g') > -1,
          x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
          l = new RegExp(left, f.replace(/g/g, '')),
          pos = [],
          t, s, m, start, end;

      do {
        t = 0;
        while ((m = x.exec(str))) {
          if (l.test(m[0])) {
            if (!(t++)) {
              s = x.lastIndex;
              start = s - m[0].length;
            }
          } else if (t) {
            if (!--t) {
              end = m.index + m[0].length;
              var obj = {
                left: {start: start, end: s},
                match: {start: s, end: m.index},
                right: {start: m.index, end: end},
                wholeMatch: {start: start, end: end}
              };
              pos.push(obj);
              if (!g) {
                return pos;
              }
            }
          }
        }
      } while (t && (x.lastIndex = s));

      return pos;
    };

    /**
     * matchRecursiveRegExp
     *
     * (c) 2007 Steven Levithan <stevenlevithan.com>
     * MIT License
     *
     * Accepts a string to search, a left and right format delimiter
     * as regex patterns, and optional regex flags. Returns an array
     * of matches, allowing nested instances of left/right delimiters.
     * Use the "g" flag to return all matches, otherwise only the
     * first is returned. Be careful to ensure that the left and
     * right format delimiters produce mutually exclusive matches.
     * Backreferences are not supported within the right delimiter
     * due to how it is internally combined with the left delimiter.
     * When matching strings whose format delimiters are unbalanced
     * to the left or right, the output is intentionally as a
     * conventional regex library with recursion support would
     * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
     * "<" and ">" as the delimiters (both strings contain a single,
     * balanced instance of "<x>").
     *
     * examples:
     * matchRecursiveRegExp("test", "\\(", "\\)")
     * returns: []
     * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
     * returns: ["t<<e>><s>", ""]
     * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
     * returns: ["test"]
     */
    showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {

      var matchPos = rgxFindMatchPos (str, left, right, flags),
          results = [];

      for (var i = 0; i < matchPos.length; ++i) {
        results.push([
          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
          str.slice(matchPos[i].match.start, matchPos[i].match.end),
          str.slice(matchPos[i].left.start, matchPos[i].left.end),
          str.slice(matchPos[i].right.start, matchPos[i].right.end)
        ]);
      }
      return results;
    };

    /**
     *
     * @param {string} str
     * @param {string|function} replacement
     * @param {string} left
     * @param {string} right
     * @param {string} flags
     * @returns {string}
     */
    showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {

      if (!showdown.helper.isFunction(replacement)) {
        var repStr = replacement;
        replacement = function () {
          return repStr;
        };
      }

      var matchPos = rgxFindMatchPos(str, left, right, flags),
          finalStr = str,
          lng = matchPos.length;

      if (lng > 0) {
        var bits = [];
        if (matchPos[0].wholeMatch.start !== 0) {
          bits.push(str.slice(0, matchPos[0].wholeMatch.start));
        }
        for (var i = 0; i < lng; ++i) {
          bits.push(
            replacement(
              str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
              str.slice(matchPos[i].match.start, matchPos[i].match.end),
              str.slice(matchPos[i].left.start, matchPos[i].left.end),
              str.slice(matchPos[i].right.start, matchPos[i].right.end)
            )
          );
          if (i < lng - 1) {
            bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
          }
        }
        if (matchPos[lng - 1].wholeMatch.end < str.length) {
          bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
        }
        finalStr = bits.join('');
      }
      return finalStr;
    };

    /**
     * Returns the index within the passed String object of the first occurrence of the specified regex,
     * starting the search at fromIndex. Returns -1 if the value is not found.
     *
     * @param {string} str string to search
     * @param {RegExp} regex Regular expression to search
     * @param {int} [fromIndex = 0] Index to start the search
     * @returns {Number}
     * @throws InvalidArgumentError
     */
    showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
      if (!showdown.helper.isString(str)) {
        throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
      }
      if (regex instanceof RegExp === false) {
        throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
      }
      var indexOf = str.substring(fromIndex || 0).search(regex);
      return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
    };

    /**
     * Splits the passed string object at the defined index, and returns an array composed of the two substrings
     * @param {string} str string to split
     * @param {int} index index to split string at
     * @returns {[string,string]}
     * @throws InvalidArgumentError
     */
    showdown.helper.splitAtIndex = function (str, index) {
      if (!showdown.helper.isString(str)) {
        throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
      }
      return [str.substring(0, index), str.substring(index)];
    };

    /**
     * Obfuscate an e-mail address through the use of Character Entities,
     * transforming ASCII characters into their equivalent decimal or hex entities.
     *
     * Since it has a random component, subsequent calls to this function produce different results
     *
     * @param {string} mail
     * @returns {string}
     */
    showdown.helper.encodeEmailAddress = function (mail) {
      var encode = [
        function (ch) {
          return '&#' + ch.charCodeAt(0) + ';';
        },
        function (ch) {
          return '&#x' + ch.charCodeAt(0).toString(16) + ';';
        },
        function (ch) {
          return ch;
        }
      ];

      mail = mail.replace(/./g, function (ch) {
        if (ch === '@') {
          // this *must* be encoded. I insist.
          ch = encode[Math.floor(Math.random() * 2)](ch);
        } else {
          var r = Math.random();
          // roughly 10% raw, 45% hex, 45% dec
          ch = (
            r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
          );
        }
        return ch;
      });

      return mail;
    };

    /**
     *
     * @param str
     * @param targetLength
     * @param padString
     * @returns {string}
     */
    showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
      /*jshint bitwise: false*/
      // eslint-disable-next-line space-infix-ops
      targetLength = targetLength>>0; //floor if number or convert non-number to 0;
      /*jshint bitwise: true*/
      padString = String(padString || ' ');
      if (str.length > targetLength) {
        return String(str);
      } else {
        targetLength = targetLength - str.length;
        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
        }
        return String(str) + padString.slice(0,targetLength);
      }
    };

    /**
     * POLYFILLS
     */
    // use this instead of builtin is undefined for IE8 compatibility
    if (typeof (console) === 'undefined') {
      console = {
        warn: function (msg) {
          alert(msg);
        },
        log: function (msg) {
          alert(msg);
        },
        error: function (msg) {
          throw msg;
        }
      };
    }

    /**
     * Common regexes.
     * We declare some common regexes to improve performance
     */
    showdown.helper.regexes = {
      asteriskDashAndColon: /([*_:~])/g
    };

    /**
     * EMOJIS LIST
     */
    showdown.helper.emojis = {
      '+1':'\ud83d\udc4d',
      '-1':'\ud83d\udc4e',
      '100':'\ud83d\udcaf',
      '1234':'\ud83d\udd22',
      '1st_place_medal':'\ud83e\udd47',
      '2nd_place_medal':'\ud83e\udd48',
      '3rd_place_medal':'\ud83e\udd49',
      '8ball':'\ud83c\udfb1',
      'a':'\ud83c\udd70\ufe0f',
      'ab':'\ud83c\udd8e',
      'abc':'\ud83d\udd24',
      'abcd':'\ud83d\udd21',
      'accept':'\ud83c\ude51',
      'aerial_tramway':'\ud83d\udea1',
      'airplane':'\u2708\ufe0f',
      'alarm_clock':'\u23f0',
      'alembic':'\u2697\ufe0f',
      'alien':'\ud83d\udc7d',
      'ambulance':'\ud83d\ude91',
      'amphora':'\ud83c\udffa',
      'anchor':'\u2693\ufe0f',
      'angel':'\ud83d\udc7c',
      'anger':'\ud83d\udca2',
      'angry':'\ud83d\ude20',
      'anguished':'\ud83d\ude27',
      'ant':'\ud83d\udc1c',
      'apple':'\ud83c\udf4e',
      'aquarius':'\u2652\ufe0f',
      'aries':'\u2648\ufe0f',
      'arrow_backward':'\u25c0\ufe0f',
      'arrow_double_down':'\u23ec',
      'arrow_double_up':'\u23eb',
      'arrow_down':'\u2b07\ufe0f',
      'arrow_down_small':'\ud83d\udd3d',
      'arrow_forward':'\u25b6\ufe0f',
      'arrow_heading_down':'\u2935\ufe0f',
      'arrow_heading_up':'\u2934\ufe0f',
      'arrow_left':'\u2b05\ufe0f',
      'arrow_lower_left':'\u2199\ufe0f',
      'arrow_lower_right':'\u2198\ufe0f',
      'arrow_right':'\u27a1\ufe0f',
      'arrow_right_hook':'\u21aa\ufe0f',
      'arrow_up':'\u2b06\ufe0f',
      'arrow_up_down':'\u2195\ufe0f',
      'arrow_up_small':'\ud83d\udd3c',
      'arrow_upper_left':'\u2196\ufe0f',
      'arrow_upper_right':'\u2197\ufe0f',
      'arrows_clockwise':'\ud83d\udd03',
      'arrows_counterclockwise':'\ud83d\udd04',
      'art':'\ud83c\udfa8',
      'articulated_lorry':'\ud83d\ude9b',
      'artificial_satellite':'\ud83d\udef0',
      'astonished':'\ud83d\ude32',
      'athletic_shoe':'\ud83d\udc5f',
      'atm':'\ud83c\udfe7',
      'atom_symbol':'\u269b\ufe0f',
      'avocado':'\ud83e\udd51',
      'b':'\ud83c\udd71\ufe0f',
      'baby':'\ud83d\udc76',
      'baby_bottle':'\ud83c\udf7c',
      'baby_chick':'\ud83d\udc24',
      'baby_symbol':'\ud83d\udebc',
      'back':'\ud83d\udd19',
      'bacon':'\ud83e\udd53',
      'badminton':'\ud83c\udff8',
      'baggage_claim':'\ud83d\udec4',
      'baguette_bread':'\ud83e\udd56',
      'balance_scale':'\u2696\ufe0f',
      'balloon':'\ud83c\udf88',
      'ballot_box':'\ud83d\uddf3',
      'ballot_box_with_check':'\u2611\ufe0f',
      'bamboo':'\ud83c\udf8d',
      'banana':'\ud83c\udf4c',
      'bangbang':'\u203c\ufe0f',
      'bank':'\ud83c\udfe6',
      'bar_chart':'\ud83d\udcca',
      'barber':'\ud83d\udc88',
      'baseball':'\u26be\ufe0f',
      'basketball':'\ud83c\udfc0',
      'basketball_man':'\u26f9\ufe0f',
      'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
      'bat':'\ud83e\udd87',
      'bath':'\ud83d\udec0',
      'bathtub':'\ud83d\udec1',
      'battery':'\ud83d\udd0b',
      'beach_umbrella':'\ud83c\udfd6',
      'bear':'\ud83d\udc3b',
      'bed':'\ud83d\udecf',
      'bee':'\ud83d\udc1d',
      'beer':'\ud83c\udf7a',
      'beers':'\ud83c\udf7b',
      'beetle':'\ud83d\udc1e',
      'beginner':'\ud83d\udd30',
      'bell':'\ud83d\udd14',
      'bellhop_bell':'\ud83d\udece',
      'bento':'\ud83c\udf71',
      'biking_man':'\ud83d\udeb4',
      'bike':'\ud83d\udeb2',
      'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
      'bikini':'\ud83d\udc59',
      'biohazard':'\u2623\ufe0f',
      'bird':'\ud83d\udc26',
      'birthday':'\ud83c\udf82',
      'black_circle':'\u26ab\ufe0f',
      'black_flag':'\ud83c\udff4',
      'black_heart':'\ud83d\udda4',
      'black_joker':'\ud83c\udccf',
      'black_large_square':'\u2b1b\ufe0f',
      'black_medium_small_square':'\u25fe\ufe0f',
      'black_medium_square':'\u25fc\ufe0f',
      'black_nib':'\u2712\ufe0f',
      'black_small_square':'\u25aa\ufe0f',
      'black_square_button':'\ud83d\udd32',
      'blonde_man':'\ud83d\udc71',
      'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
      'blossom':'\ud83c\udf3c',
      'blowfish':'\ud83d\udc21',
      'blue_book':'\ud83d\udcd8',
      'blue_car':'\ud83d\ude99',
      'blue_heart':'\ud83d\udc99',
      'blush':'\ud83d\ude0a',
      'boar':'\ud83d\udc17',
      'boat':'\u26f5\ufe0f',
      'bomb':'\ud83d\udca3',
      'book':'\ud83d\udcd6',
      'bookmark':'\ud83d\udd16',
      'bookmark_tabs':'\ud83d\udcd1',
      'books':'\ud83d\udcda',
      'boom':'\ud83d\udca5',
      'boot':'\ud83d\udc62',
      'bouquet':'\ud83d\udc90',
      'bowing_man':'\ud83d\ude47',
      'bow_and_arrow':'\ud83c\udff9',
      'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
      'bowling':'\ud83c\udfb3',
      'boxing_glove':'\ud83e\udd4a',
      'boy':'\ud83d\udc66',
      'bread':'\ud83c\udf5e',
      'bride_with_veil':'\ud83d\udc70',
      'bridge_at_night':'\ud83c\udf09',
      'briefcase':'\ud83d\udcbc',
      'broken_heart':'\ud83d\udc94',
      'bug':'\ud83d\udc1b',
      'building_construction':'\ud83c\udfd7',
      'bulb':'\ud83d\udca1',
      'bullettrain_front':'\ud83d\ude85',
      'bullettrain_side':'\ud83d\ude84',
      'burrito':'\ud83c\udf2f',
      'bus':'\ud83d\ude8c',
      'business_suit_levitating':'\ud83d\udd74',
      'busstop':'\ud83d\ude8f',
      'bust_in_silhouette':'\ud83d\udc64',
      'busts_in_silhouette':'\ud83d\udc65',
      'butterfly':'\ud83e\udd8b',
      'cactus':'\ud83c\udf35',
      'cake':'\ud83c\udf70',
      'calendar':'\ud83d\udcc6',
      'call_me_hand':'\ud83e\udd19',
      'calling':'\ud83d\udcf2',
      'camel':'\ud83d\udc2b',
      'camera':'\ud83d\udcf7',
      'camera_flash':'\ud83d\udcf8',
      'camping':'\ud83c\udfd5',
      'cancer':'\u264b\ufe0f',
      'candle':'\ud83d\udd6f',
      'candy':'\ud83c\udf6c',
      'canoe':'\ud83d\udef6',
      'capital_abcd':'\ud83d\udd20',
      'capricorn':'\u2651\ufe0f',
      'car':'\ud83d\ude97',
      'card_file_box':'\ud83d\uddc3',
      'card_index':'\ud83d\udcc7',
      'card_index_dividers':'\ud83d\uddc2',
      'carousel_horse':'\ud83c\udfa0',
      'carrot':'\ud83e\udd55',
      'cat':'\ud83d\udc31',
      'cat2':'\ud83d\udc08',
      'cd':'\ud83d\udcbf',
      'chains':'\u26d3',
      'champagne':'\ud83c\udf7e',
      'chart':'\ud83d\udcb9',
      'chart_with_downwards_trend':'\ud83d\udcc9',
      'chart_with_upwards_trend':'\ud83d\udcc8',
      'checkered_flag':'\ud83c\udfc1',
      'cheese':'\ud83e\uddc0',
      'cherries':'\ud83c\udf52',
      'cherry_blossom':'\ud83c\udf38',
      'chestnut':'\ud83c\udf30',
      'chicken':'\ud83d\udc14',
      'children_crossing':'\ud83d\udeb8',
      'chipmunk':'\ud83d\udc3f',
      'chocolate_bar':'\ud83c\udf6b',
      'christmas_tree':'\ud83c\udf84',
      'church':'\u26ea\ufe0f',
      'cinema':'\ud83c\udfa6',
      'circus_tent':'\ud83c\udfaa',
      'city_sunrise':'\ud83c\udf07',
      'city_sunset':'\ud83c\udf06',
      'cityscape':'\ud83c\udfd9',
      'cl':'\ud83c\udd91',
      'clamp':'\ud83d\udddc',
      'clap':'\ud83d\udc4f',
      'clapper':'\ud83c\udfac',
      'classical_building':'\ud83c\udfdb',
      'clinking_glasses':'\ud83e\udd42',
      'clipboard':'\ud83d\udccb',
      'clock1':'\ud83d\udd50',
      'clock10':'\ud83d\udd59',
      'clock1030':'\ud83d\udd65',
      'clock11':'\ud83d\udd5a',
      'clock1130':'\ud83d\udd66',
      'clock12':'\ud83d\udd5b',
      'clock1230':'\ud83d\udd67',
      'clock130':'\ud83d\udd5c',
      'clock2':'\ud83d\udd51',
      'clock230':'\ud83d\udd5d',
      'clock3':'\ud83d\udd52',
      'clock330':'\ud83d\udd5e',
      'clock4':'\ud83d\udd53',
      'clock430':'\ud83d\udd5f',
      'clock5':'\ud83d\udd54',
      'clock530':'\ud83d\udd60',
      'clock6':'\ud83d\udd55',
      'clock630':'\ud83d\udd61',
      'clock7':'\ud83d\udd56',
      'clock730':'\ud83d\udd62',
      'clock8':'\ud83d\udd57',
      'clock830':'\ud83d\udd63',
      'clock9':'\ud83d\udd58',
      'clock930':'\ud83d\udd64',
      'closed_book':'\ud83d\udcd5',
      'closed_lock_with_key':'\ud83d\udd10',
      'closed_umbrella':'\ud83c\udf02',
      'cloud':'\u2601\ufe0f',
      'cloud_with_lightning':'\ud83c\udf29',
      'cloud_with_lightning_and_rain':'\u26c8',
      'cloud_with_rain':'\ud83c\udf27',
      'cloud_with_snow':'\ud83c\udf28',
      'clown_face':'\ud83e\udd21',
      'clubs':'\u2663\ufe0f',
      'cocktail':'\ud83c\udf78',
      'coffee':'\u2615\ufe0f',
      'coffin':'\u26b0\ufe0f',
      'cold_sweat':'\ud83d\ude30',
      'comet':'\u2604\ufe0f',
      'computer':'\ud83d\udcbb',
      'computer_mouse':'\ud83d\uddb1',
      'confetti_ball':'\ud83c\udf8a',
      'confounded':'\ud83d\ude16',
      'confused':'\ud83d\ude15',
      'congratulations':'\u3297\ufe0f',
      'construction':'\ud83d\udea7',
      'construction_worker_man':'\ud83d\udc77',
      'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
      'control_knobs':'\ud83c\udf9b',
      'convenience_store':'\ud83c\udfea',
      'cookie':'\ud83c\udf6a',
      'cool':'\ud83c\udd92',
      'policeman':'\ud83d\udc6e',
      'copyright':'\u00a9\ufe0f',
      'corn':'\ud83c\udf3d',
      'couch_and_lamp':'\ud83d\udecb',
      'couple':'\ud83d\udc6b',
      'couple_with_heart_woman_man':'\ud83d\udc91',
      'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
      'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
      'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
      'couplekiss_man_woman':'\ud83d\udc8f',
      'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
      'cow':'\ud83d\udc2e',
      'cow2':'\ud83d\udc04',
      'cowboy_hat_face':'\ud83e\udd20',
      'crab':'\ud83e\udd80',
      'crayon':'\ud83d\udd8d',
      'credit_card':'\ud83d\udcb3',
      'crescent_moon':'\ud83c\udf19',
      'cricket':'\ud83c\udfcf',
      'crocodile':'\ud83d\udc0a',
      'croissant':'\ud83e\udd50',
      'crossed_fingers':'\ud83e\udd1e',
      'crossed_flags':'\ud83c\udf8c',
      'crossed_swords':'\u2694\ufe0f',
      'crown':'\ud83d\udc51',
      'cry':'\ud83d\ude22',
      'crying_cat_face':'\ud83d\ude3f',
      'crystal_ball':'\ud83d\udd2e',
      'cucumber':'\ud83e\udd52',
      'cupid':'\ud83d\udc98',
      'curly_loop':'\u27b0',
      'currency_exchange':'\ud83d\udcb1',
      'curry':'\ud83c\udf5b',
      'custard':'\ud83c\udf6e',
      'customs':'\ud83d\udec3',
      'cyclone':'\ud83c\udf00',
      'dagger':'\ud83d\udde1',
      'dancer':'\ud83d\udc83',
      'dancing_women':'\ud83d\udc6f',
      'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
      'dango':'\ud83c\udf61',
      'dark_sunglasses':'\ud83d\udd76',
      'dart':'\ud83c\udfaf',
      'dash':'\ud83d\udca8',
      'date':'\ud83d\udcc5',
      'deciduous_tree':'\ud83c\udf33',
      'deer':'\ud83e\udd8c',
      'department_store':'\ud83c\udfec',
      'derelict_house':'\ud83c\udfda',
      'desert':'\ud83c\udfdc',
      'desert_island':'\ud83c\udfdd',
      'desktop_computer':'\ud83d\udda5',
      'male_detective':'\ud83d\udd75\ufe0f',
      'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
      'diamonds':'\u2666\ufe0f',
      'disappointed':'\ud83d\ude1e',
      'disappointed_relieved':'\ud83d\ude25',
      'dizzy':'\ud83d\udcab',
      'dizzy_face':'\ud83d\ude35',
      'do_not_litter':'\ud83d\udeaf',
      'dog':'\ud83d\udc36',
      'dog2':'\ud83d\udc15',
      'dollar':'\ud83d\udcb5',
      'dolls':'\ud83c\udf8e',
      'dolphin':'\ud83d\udc2c',
      'door':'\ud83d\udeaa',
      'doughnut':'\ud83c\udf69',
      'dove':'\ud83d\udd4a',
      'dragon':'\ud83d\udc09',
      'dragon_face':'\ud83d\udc32',
      'dress':'\ud83d\udc57',
      'dromedary_camel':'\ud83d\udc2a',
      'drooling_face':'\ud83e\udd24',
      'droplet':'\ud83d\udca7',
      'drum':'\ud83e\udd41',
      'duck':'\ud83e\udd86',
      'dvd':'\ud83d\udcc0',
      'e-mail':'\ud83d\udce7',
      'eagle':'\ud83e\udd85',
      'ear':'\ud83d\udc42',
      'ear_of_rice':'\ud83c\udf3e',
      'earth_africa':'\ud83c\udf0d',
      'earth_americas':'\ud83c\udf0e',
      'earth_asia':'\ud83c\udf0f',
      'egg':'\ud83e\udd5a',
      'eggplant':'\ud83c\udf46',
      'eight_pointed_black_star':'\u2734\ufe0f',
      'eight_spoked_asterisk':'\u2733\ufe0f',
      'electric_plug':'\ud83d\udd0c',
      'elephant':'\ud83d\udc18',
      'email':'\u2709\ufe0f',
      'end':'\ud83d\udd1a',
      'envelope_with_arrow':'\ud83d\udce9',
      'euro':'\ud83d\udcb6',
      'european_castle':'\ud83c\udff0',
      'european_post_office':'\ud83c\udfe4',
      'evergreen_tree':'\ud83c\udf32',
      'exclamation':'\u2757\ufe0f',
      'expressionless':'\ud83d\ude11',
      'eye':'\ud83d\udc41',
      'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
      'eyeglasses':'\ud83d\udc53',
      'eyes':'\ud83d\udc40',
      'face_with_head_bandage':'\ud83e\udd15',
      'face_with_thermometer':'\ud83e\udd12',
      'fist_oncoming':'\ud83d\udc4a',
      'factory':'\ud83c\udfed',
      'fallen_leaf':'\ud83c\udf42',
      'family_man_woman_boy':'\ud83d\udc6a',
      'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
      'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
      'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
      'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
      'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
      'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
      'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
      'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
      'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
      'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
      'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
      'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
      'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
      'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
      'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
      'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
      'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
      'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
      'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
      'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
      'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
      'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
      'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
      'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
      'fast_forward':'\u23e9',
      'fax':'\ud83d\udce0',
      'fearful':'\ud83d\ude28',
      'feet':'\ud83d\udc3e',
      'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
      'ferris_wheel':'\ud83c\udfa1',
      'ferry':'\u26f4',
      'field_hockey':'\ud83c\udfd1',
      'file_cabinet':'\ud83d\uddc4',
      'file_folder':'\ud83d\udcc1',
      'film_projector':'\ud83d\udcfd',
      'film_strip':'\ud83c\udf9e',
      'fire':'\ud83d\udd25',
      'fire_engine':'\ud83d\ude92',
      'fireworks':'\ud83c\udf86',
      'first_quarter_moon':'\ud83c\udf13',
      'first_quarter_moon_with_face':'\ud83c\udf1b',
      'fish':'\ud83d\udc1f',
      'fish_cake':'\ud83c\udf65',
      'fishing_pole_and_fish':'\ud83c\udfa3',
      'fist_raised':'\u270a',
      'fist_left':'\ud83e\udd1b',
      'fist_right':'\ud83e\udd1c',
      'flags':'\ud83c\udf8f',
      'flashlight':'\ud83d\udd26',
      'fleur_de_lis':'\u269c\ufe0f',
      'flight_arrival':'\ud83d\udeec',
      'flight_departure':'\ud83d\udeeb',
      'floppy_disk':'\ud83d\udcbe',
      'flower_playing_cards':'\ud83c\udfb4',
      'flushed':'\ud83d\ude33',
      'fog':'\ud83c\udf2b',
      'foggy':'\ud83c\udf01',
      'football':'\ud83c\udfc8',
      'footprints':'\ud83d\udc63',
      'fork_and_knife':'\ud83c\udf74',
      'fountain':'\u26f2\ufe0f',
      'fountain_pen':'\ud83d\udd8b',
      'four_leaf_clover':'\ud83c\udf40',
      'fox_face':'\ud83e\udd8a',
      'framed_picture':'\ud83d\uddbc',
      'free':'\ud83c\udd93',
      'fried_egg':'\ud83c\udf73',
      'fried_shrimp':'\ud83c\udf64',
      'fries':'\ud83c\udf5f',
      'frog':'\ud83d\udc38',
      'frowning':'\ud83d\ude26',
      'frowning_face':'\u2639\ufe0f',
      'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
      'frowning_woman':'\ud83d\ude4d',
      'middle_finger':'\ud83d\udd95',
      'fuelpump':'\u26fd\ufe0f',
      'full_moon':'\ud83c\udf15',
      'full_moon_with_face':'\ud83c\udf1d',
      'funeral_urn':'\u26b1\ufe0f',
      'game_die':'\ud83c\udfb2',
      'gear':'\u2699\ufe0f',
      'gem':'\ud83d\udc8e',
      'gemini':'\u264a\ufe0f',
      'ghost':'\ud83d\udc7b',
      'gift':'\ud83c\udf81',
      'gift_heart':'\ud83d\udc9d',
      'girl':'\ud83d\udc67',
      'globe_with_meridians':'\ud83c\udf10',
      'goal_net':'\ud83e\udd45',
      'goat':'\ud83d\udc10',
      'golf':'\u26f3\ufe0f',
      'golfing_man':'\ud83c\udfcc\ufe0f',
      'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
      'gorilla':'\ud83e\udd8d',
      'grapes':'\ud83c\udf47',
      'green_apple':'\ud83c\udf4f',
      'green_book':'\ud83d\udcd7',
      'green_heart':'\ud83d\udc9a',
      'green_salad':'\ud83e\udd57',
      'grey_exclamation':'\u2755',
      'grey_question':'\u2754',
      'grimacing':'\ud83d\ude2c',
      'grin':'\ud83d\ude01',
      'grinning':'\ud83d\ude00',
      'guardsman':'\ud83d\udc82',
      'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
      'guitar':'\ud83c\udfb8',
      'gun':'\ud83d\udd2b',
      'haircut_woman':'\ud83d\udc87',
      'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
      'hamburger':'\ud83c\udf54',
      'hammer':'\ud83d\udd28',
      'hammer_and_pick':'\u2692',
      'hammer_and_wrench':'\ud83d\udee0',
      'hamster':'\ud83d\udc39',
      'hand':'\u270b',
      'handbag':'\ud83d\udc5c',
      'handshake':'\ud83e\udd1d',
      'hankey':'\ud83d\udca9',
      'hatched_chick':'\ud83d\udc25',
      'hatching_chick':'\ud83d\udc23',
      'headphones':'\ud83c\udfa7',
      'hear_no_evil':'\ud83d\ude49',
      'heart':'\u2764\ufe0f',
      'heart_decoration':'\ud83d\udc9f',
      'heart_eyes':'\ud83d\ude0d',
      'heart_eyes_cat':'\ud83d\ude3b',
      'heartbeat':'\ud83d\udc93',
      'heartpulse':'\ud83d\udc97',
      'hearts':'\u2665\ufe0f',
      'heavy_check_mark':'\u2714\ufe0f',
      'heavy_division_sign':'\u2797',
      'heavy_dollar_sign':'\ud83d\udcb2',
      'heavy_heart_exclamation':'\u2763\ufe0f',
      'heavy_minus_sign':'\u2796',
      'heavy_multiplication_x':'\u2716\ufe0f',
      'heavy_plus_sign':'\u2795',
      'helicopter':'\ud83d\ude81',
      'herb':'\ud83c\udf3f',
      'hibiscus':'\ud83c\udf3a',
      'high_brightness':'\ud83d\udd06',
      'high_heel':'\ud83d\udc60',
      'hocho':'\ud83d\udd2a',
      'hole':'\ud83d\udd73',
      'honey_pot':'\ud83c\udf6f',
      'horse':'\ud83d\udc34',
      'horse_racing':'\ud83c\udfc7',
      'hospital':'\ud83c\udfe5',
      'hot_pepper':'\ud83c\udf36',
      'hotdog':'\ud83c\udf2d',
      'hotel':'\ud83c\udfe8',
      'hotsprings':'\u2668\ufe0f',
      'hourglass':'\u231b\ufe0f',
      'hourglass_flowing_sand':'\u23f3',
      'house':'\ud83c\udfe0',
      'house_with_garden':'\ud83c\udfe1',
      'houses':'\ud83c\udfd8',
      'hugs':'\ud83e\udd17',
      'hushed':'\ud83d\ude2f',
      'ice_cream':'\ud83c\udf68',
      'ice_hockey':'\ud83c\udfd2',
      'ice_skate':'\u26f8',
      'icecream':'\ud83c\udf66',
      'id':'\ud83c\udd94',
      'ideograph_advantage':'\ud83c\ude50',
      'imp':'\ud83d\udc7f',
      'inbox_tray':'\ud83d\udce5',
      'incoming_envelope':'\ud83d\udce8',
      'tipping_hand_woman':'\ud83d\udc81',
      'information_source':'\u2139\ufe0f',
      'innocent':'\ud83d\ude07',
      'interrobang':'\u2049\ufe0f',
      'iphone':'\ud83d\udcf1',
      'izakaya_lantern':'\ud83c\udfee',
      'jack_o_lantern':'\ud83c\udf83',
      'japan':'\ud83d\uddfe',
      'japanese_castle':'\ud83c\udfef',
      'japanese_goblin':'\ud83d\udc7a',
      'japanese_ogre':'\ud83d\udc79',
      'jeans':'\ud83d\udc56',
      'joy':'\ud83d\ude02',
      'joy_cat':'\ud83d\ude39',
      'joystick':'\ud83d\udd79',
      'kaaba':'\ud83d\udd4b',
      'key':'\ud83d\udd11',
      'keyboard':'\u2328\ufe0f',
      'keycap_ten':'\ud83d\udd1f',
      'kick_scooter':'\ud83d\udef4',
      'kimono':'\ud83d\udc58',
      'kiss':'\ud83d\udc8b',
      'kissing':'\ud83d\ude17',
      'kissing_cat':'\ud83d\ude3d',
      'kissing_closed_eyes':'\ud83d\ude1a',
      'kissing_heart':'\ud83d\ude18',
      'kissing_smiling_eyes':'\ud83d\ude19',
      'kiwi_fruit':'\ud83e\udd5d',
      'koala':'\ud83d\udc28',
      'koko':'\ud83c\ude01',
      'label':'\ud83c\udff7',
      'large_blue_circle':'\ud83d\udd35',
      'large_blue_diamond':'\ud83d\udd37',
      'large_orange_diamond':'\ud83d\udd36',
      'last_quarter_moon':'\ud83c\udf17',
      'last_quarter_moon_with_face':'\ud83c\udf1c',
      'latin_cross':'\u271d\ufe0f',
      'laughing':'\ud83d\ude06',
      'leaves':'\ud83c\udf43',
      'ledger':'\ud83d\udcd2',
      'left_luggage':'\ud83d\udec5',
      'left_right_arrow':'\u2194\ufe0f',
      'leftwards_arrow_with_hook':'\u21a9\ufe0f',
      'lemon':'\ud83c\udf4b',
      'leo':'\u264c\ufe0f',
      'leopard':'\ud83d\udc06',
      'level_slider':'\ud83c\udf9a',
      'libra':'\u264e\ufe0f',
      'light_rail':'\ud83d\ude88',
      'link':'\ud83d\udd17',
      'lion':'\ud83e\udd81',
      'lips':'\ud83d\udc44',
      'lipstick':'\ud83d\udc84',
      'lizard':'\ud83e\udd8e',
      'lock':'\ud83d\udd12',
      'lock_with_ink_pen':'\ud83d\udd0f',
      'lollipop':'\ud83c\udf6d',
      'loop':'\u27bf',
      'loud_sound':'\ud83d\udd0a',
      'loudspeaker':'\ud83d\udce2',
      'love_hotel':'\ud83c\udfe9',
      'love_letter':'\ud83d\udc8c',
      'low_brightness':'\ud83d\udd05',
      'lying_face':'\ud83e\udd25',
      'm':'\u24c2\ufe0f',
      'mag':'\ud83d\udd0d',
      'mag_right':'\ud83d\udd0e',
      'mahjong':'\ud83c\udc04\ufe0f',
      'mailbox':'\ud83d\udceb',
      'mailbox_closed':'\ud83d\udcea',
      'mailbox_with_mail':'\ud83d\udcec',
      'mailbox_with_no_mail':'\ud83d\udced',
      'man':'\ud83d\udc68',
      'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
      'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
      'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
      'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
      'man_dancing':'\ud83d\udd7a',
      'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
      'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
      'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
      'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
      'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
      'man_in_tuxedo':'\ud83e\udd35',
      'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
      'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
      'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
      'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
      'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
      'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
      'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
      'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
      'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
      'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
      'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
      'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
      'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
      'man_with_gua_pi_mao':'\ud83d\udc72',
      'man_with_turban':'\ud83d\udc73',
      'tangerine':'\ud83c\udf4a',
      'mans_shoe':'\ud83d\udc5e',
      'mantelpiece_clock':'\ud83d\udd70',
      'maple_leaf':'\ud83c\udf41',
      'martial_arts_uniform':'\ud83e\udd4b',
      'mask':'\ud83d\ude37',
      'massage_woman':'\ud83d\udc86',
      'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
      'meat_on_bone':'\ud83c\udf56',
      'medal_military':'\ud83c\udf96',
      'medal_sports':'\ud83c\udfc5',
      'mega':'\ud83d\udce3',
      'melon':'\ud83c\udf48',
      'memo':'\ud83d\udcdd',
      'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
      'menorah':'\ud83d\udd4e',
      'mens':'\ud83d\udeb9',
      'metal':'\ud83e\udd18',
      'metro':'\ud83d\ude87',
      'microphone':'\ud83c\udfa4',
      'microscope':'\ud83d\udd2c',
      'milk_glass':'\ud83e\udd5b',
      'milky_way':'\ud83c\udf0c',
      'minibus':'\ud83d\ude90',
      'minidisc':'\ud83d\udcbd',
      'mobile_phone_off':'\ud83d\udcf4',
      'money_mouth_face':'\ud83e\udd11',
      'money_with_wings':'\ud83d\udcb8',
      'moneybag':'\ud83d\udcb0',
      'monkey':'\ud83d\udc12',
      'monkey_face':'\ud83d\udc35',
      'monorail':'\ud83d\ude9d',
      'moon':'\ud83c\udf14',
      'mortar_board':'\ud83c\udf93',
      'mosque':'\ud83d\udd4c',
      'motor_boat':'\ud83d\udee5',
      'motor_scooter':'\ud83d\udef5',
      'motorcycle':'\ud83c\udfcd',
      'motorway':'\ud83d\udee3',
      'mount_fuji':'\ud83d\uddfb',
      'mountain':'\u26f0',
      'mountain_biking_man':'\ud83d\udeb5',
      'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
      'mountain_cableway':'\ud83d\udea0',
      'mountain_railway':'\ud83d\ude9e',
      'mountain_snow':'\ud83c\udfd4',
      'mouse':'\ud83d\udc2d',
      'mouse2':'\ud83d\udc01',
      'movie_camera':'\ud83c\udfa5',
      'moyai':'\ud83d\uddff',
      'mrs_claus':'\ud83e\udd36',
      'muscle':'\ud83d\udcaa',
      'mushroom':'\ud83c\udf44',
      'musical_keyboard':'\ud83c\udfb9',
      'musical_note':'\ud83c\udfb5',
      'musical_score':'\ud83c\udfbc',
      'mute':'\ud83d\udd07',
      'nail_care':'\ud83d\udc85',
      'name_badge':'\ud83d\udcdb',
      'national_park':'\ud83c\udfde',
      'nauseated_face':'\ud83e\udd22',
      'necktie':'\ud83d\udc54',
      'negative_squared_cross_mark':'\u274e',
      'nerd_face':'\ud83e\udd13',
      'neutral_face':'\ud83d\ude10',
      'new':'\ud83c\udd95',
      'new_moon':'\ud83c\udf11',
      'new_moon_with_face':'\ud83c\udf1a',
      'newspaper':'\ud83d\udcf0',
      'newspaper_roll':'\ud83d\uddde',
      'next_track_button':'\u23ed',
      'ng':'\ud83c\udd96',
      'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
      'no_good_woman':'\ud83d\ude45',
      'night_with_stars':'\ud83c\udf03',
      'no_bell':'\ud83d\udd15',
      'no_bicycles':'\ud83d\udeb3',
      'no_entry':'\u26d4\ufe0f',
      'no_entry_sign':'\ud83d\udeab',
      'no_mobile_phones':'\ud83d\udcf5',
      'no_mouth':'\ud83d\ude36',
      'no_pedestrians':'\ud83d\udeb7',
      'no_smoking':'\ud83d\udead',
      'non-potable_water':'\ud83d\udeb1',
      'nose':'\ud83d\udc43',
      'notebook':'\ud83d\udcd3',
      'notebook_with_decorative_cover':'\ud83d\udcd4',
      'notes':'\ud83c\udfb6',
      'nut_and_bolt':'\ud83d\udd29',
      'o':'\u2b55\ufe0f',
      'o2':'\ud83c\udd7e\ufe0f',
      'ocean':'\ud83c\udf0a',
      'octopus':'\ud83d\udc19',
      'oden':'\ud83c\udf62',
      'office':'\ud83c\udfe2',
      'oil_drum':'\ud83d\udee2',
      'ok':'\ud83c\udd97',
      'ok_hand':'\ud83d\udc4c',
      'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
      'ok_woman':'\ud83d\ude46',
      'old_key':'\ud83d\udddd',
      'older_man':'\ud83d\udc74',
      'older_woman':'\ud83d\udc75',
      'om':'\ud83d\udd49',
      'on':'\ud83d\udd1b',
      'oncoming_automobile':'\ud83d\ude98',
      'oncoming_bus':'\ud83d\ude8d',
      'oncoming_police_car':'\ud83d\ude94',
      'oncoming_taxi':'\ud83d\ude96',
      'open_file_folder':'\ud83d\udcc2',
      'open_hands':'\ud83d\udc50',
      'open_mouth':'\ud83d\ude2e',
      'open_umbrella':'\u2602\ufe0f',
      'ophiuchus':'\u26ce',
      'orange_book':'\ud83d\udcd9',
      'orthodox_cross':'\u2626\ufe0f',
      'outbox_tray':'\ud83d\udce4',
      'owl':'\ud83e\udd89',
      'ox':'\ud83d\udc02',
      'package':'\ud83d\udce6',
      'page_facing_up':'\ud83d\udcc4',
      'page_with_curl':'\ud83d\udcc3',
      'pager':'\ud83d\udcdf',
      'paintbrush':'\ud83d\udd8c',
      'palm_tree':'\ud83c\udf34',
      'pancakes':'\ud83e\udd5e',
      'panda_face':'\ud83d\udc3c',
      'paperclip':'\ud83d\udcce',
      'paperclips':'\ud83d\udd87',
      'parasol_on_ground':'\u26f1',
      'parking':'\ud83c\udd7f\ufe0f',
      'part_alternation_mark':'\u303d\ufe0f',
      'partly_sunny':'\u26c5\ufe0f',
      'passenger_ship':'\ud83d\udef3',
      'passport_control':'\ud83d\udec2',
      'pause_button':'\u23f8',
      'peace_symbol':'\u262e\ufe0f',
      'peach':'\ud83c\udf51',
      'peanuts':'\ud83e\udd5c',
      'pear':'\ud83c\udf50',
      'pen':'\ud83d\udd8a',
      'pencil2':'\u270f\ufe0f',
      'penguin':'\ud83d\udc27',
      'pensive':'\ud83d\ude14',
      'performing_arts':'\ud83c\udfad',
      'persevere':'\ud83d\ude23',
      'person_fencing':'\ud83e\udd3a',
      'pouting_woman':'\ud83d\ude4e',
      'phone':'\u260e\ufe0f',
      'pick':'\u26cf',
      'pig':'\ud83d\udc37',
      'pig2':'\ud83d\udc16',
      'pig_nose':'\ud83d\udc3d',
      'pill':'\ud83d\udc8a',
      'pineapple':'\ud83c\udf4d',
      'ping_pong':'\ud83c\udfd3',
      'pisces':'\u2653\ufe0f',
      'pizza':'\ud83c\udf55',
      'place_of_worship':'\ud83d\uded0',
      'plate_with_cutlery':'\ud83c\udf7d',
      'play_or_pause_button':'\u23ef',
      'point_down':'\ud83d\udc47',
      'point_left':'\ud83d\udc48',
      'point_right':'\ud83d\udc49',
      'point_up':'\u261d\ufe0f',
      'point_up_2':'\ud83d\udc46',
      'police_car':'\ud83d\ude93',
      'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
      'poodle':'\ud83d\udc29',
      'popcorn':'\ud83c\udf7f',
      'post_office':'\ud83c\udfe3',
      'postal_horn':'\ud83d\udcef',
      'postbox':'\ud83d\udcee',
      'potable_water':'\ud83d\udeb0',
      'potato':'\ud83e\udd54',
      'pouch':'\ud83d\udc5d',
      'poultry_leg':'\ud83c\udf57',
      'pound':'\ud83d\udcb7',
      'rage':'\ud83d\ude21',
      'pouting_cat':'\ud83d\ude3e',
      'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
      'pray':'\ud83d\ude4f',
      'prayer_beads':'\ud83d\udcff',
      'pregnant_woman':'\ud83e\udd30',
      'previous_track_button':'\u23ee',
      'prince':'\ud83e\udd34',
      'princess':'\ud83d\udc78',
      'printer':'\ud83d\udda8',
      'purple_heart':'\ud83d\udc9c',
      'purse':'\ud83d\udc5b',
      'pushpin':'\ud83d\udccc',
      'put_litter_in_its_place':'\ud83d\udeae',
      'question':'\u2753',
      'rabbit':'\ud83d\udc30',
      'rabbit2':'\ud83d\udc07',
      'racehorse':'\ud83d\udc0e',
      'racing_car':'\ud83c\udfce',
      'radio':'\ud83d\udcfb',
      'radio_button':'\ud83d\udd18',
      'radioactive':'\u2622\ufe0f',
      'railway_car':'\ud83d\ude83',
      'railway_track':'\ud83d\udee4',
      'rainbow':'\ud83c\udf08',
      'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
      'raised_back_of_hand':'\ud83e\udd1a',
      'raised_hand_with_fingers_splayed':'\ud83d\udd90',
      'raised_hands':'\ud83d\ude4c',
      'raising_hand_woman':'\ud83d\ude4b',
      'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
      'ram':'\ud83d\udc0f',
      'ramen':'\ud83c\udf5c',
      'rat':'\ud83d\udc00',
      'record_button':'\u23fa',
      'recycle':'\u267b\ufe0f',
      'red_circle':'\ud83d\udd34',
      'registered':'\u00ae\ufe0f',
      'relaxed':'\u263a\ufe0f',
      'relieved':'\ud83d\ude0c',
      'reminder_ribbon':'\ud83c\udf97',
      'repeat':'\ud83d\udd01',
      'repeat_one':'\ud83d\udd02',
      'rescue_worker_helmet':'\u26d1',
      'restroom':'\ud83d\udebb',
      'revolving_hearts':'\ud83d\udc9e',
      'rewind':'\u23ea',
      'rhinoceros':'\ud83e\udd8f',
      'ribbon':'\ud83c\udf80',
      'rice':'\ud83c\udf5a',
      'rice_ball':'\ud83c\udf59',
      'rice_cracker':'\ud83c\udf58',
      'rice_scene':'\ud83c\udf91',
      'right_anger_bubble':'\ud83d\uddef',
      'ring':'\ud83d\udc8d',
      'robot':'\ud83e\udd16',
      'rocket':'\ud83d\ude80',
      'rofl':'\ud83e\udd23',
      'roll_eyes':'\ud83d\ude44',
      'roller_coaster':'\ud83c\udfa2',
      'rooster':'\ud83d\udc13',
      'rose':'\ud83c\udf39',
      'rosette':'\ud83c\udff5',
      'rotating_light':'\ud83d\udea8',
      'round_pushpin':'\ud83d\udccd',
      'rowing_man':'\ud83d\udea3',
      'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
      'rugby_football':'\ud83c\udfc9',
      'running_man':'\ud83c\udfc3',
      'running_shirt_with_sash':'\ud83c\udfbd',
      'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
      'sa':'\ud83c\ude02\ufe0f',
      'sagittarius':'\u2650\ufe0f',
      'sake':'\ud83c\udf76',
      'sandal':'\ud83d\udc61',
      'santa':'\ud83c\udf85',
      'satellite':'\ud83d\udce1',
      'saxophone':'\ud83c\udfb7',
      'school':'\ud83c\udfeb',
      'school_satchel':'\ud83c\udf92',
      'scissors':'\u2702\ufe0f',
      'scorpion':'\ud83e\udd82',
      'scorpius':'\u264f\ufe0f',
      'scream':'\ud83d\ude31',
      'scream_cat':'\ud83d\ude40',
      'scroll':'\ud83d\udcdc',
      'seat':'\ud83d\udcba',
      'secret':'\u3299\ufe0f',
      'see_no_evil':'\ud83d\ude48',
      'seedling':'\ud83c\udf31',
      'selfie':'\ud83e\udd33',
      'shallow_pan_of_food':'\ud83e\udd58',
      'shamrock':'\u2618\ufe0f',
      'shark':'\ud83e\udd88',
      'shaved_ice':'\ud83c\udf67',
      'sheep':'\ud83d\udc11',
      'shell':'\ud83d\udc1a',
      'shield':'\ud83d\udee1',
      'shinto_shrine':'\u26e9',
      'ship':'\ud83d\udea2',
      'shirt':'\ud83d\udc55',
      'shopping':'\ud83d\udecd',
      'shopping_cart':'\ud83d\uded2',
      'shower':'\ud83d\udebf',
      'shrimp':'\ud83e\udd90',
      'signal_strength':'\ud83d\udcf6',
      'six_pointed_star':'\ud83d\udd2f',
      'ski':'\ud83c\udfbf',
      'skier':'\u26f7',
      'skull':'\ud83d\udc80',
      'skull_and_crossbones':'\u2620\ufe0f',
      'sleeping':'\ud83d\ude34',
      'sleeping_bed':'\ud83d\udecc',
      'sleepy':'\ud83d\ude2a',
      'slightly_frowning_face':'\ud83d\ude41',
      'slightly_smiling_face':'\ud83d\ude42',
      'slot_machine':'\ud83c\udfb0',
      'small_airplane':'\ud83d\udee9',
      'small_blue_diamond':'\ud83d\udd39',
      'small_orange_diamond':'\ud83d\udd38',
      'small_red_triangle':'\ud83d\udd3a',
      'small_red_triangle_down':'\ud83d\udd3b',
      'smile':'\ud83d\ude04',
      'smile_cat':'\ud83d\ude38',
      'smiley':'\ud83d\ude03',
      'smiley_cat':'\ud83d\ude3a',
      'smiling_imp':'\ud83d\ude08',
      'smirk':'\ud83d\ude0f',
      'smirk_cat':'\ud83d\ude3c',
      'smoking':'\ud83d\udeac',
      'snail':'\ud83d\udc0c',
      'snake':'\ud83d\udc0d',
      'sneezing_face':'\ud83e\udd27',
      'snowboarder':'\ud83c\udfc2',
      'snowflake':'\u2744\ufe0f',
      'snowman':'\u26c4\ufe0f',
      'snowman_with_snow':'\u2603\ufe0f',
      'sob':'\ud83d\ude2d',
      'soccer':'\u26bd\ufe0f',
      'soon':'\ud83d\udd1c',
      'sos':'\ud83c\udd98',
      'sound':'\ud83d\udd09',
      'space_invader':'\ud83d\udc7e',
      'spades':'\u2660\ufe0f',
      'spaghetti':'\ud83c\udf5d',
      'sparkle':'\u2747\ufe0f',
      'sparkler':'\ud83c\udf87',
      'sparkles':'\u2728',
      'sparkling_heart':'\ud83d\udc96',
      'speak_no_evil':'\ud83d\ude4a',
      'speaker':'\ud83d\udd08',
      'speaking_head':'\ud83d\udde3',
      'speech_balloon':'\ud83d\udcac',
      'speedboat':'\ud83d\udea4',
      'spider':'\ud83d\udd77',
      'spider_web':'\ud83d\udd78',
      'spiral_calendar':'\ud83d\uddd3',
      'spiral_notepad':'\ud83d\uddd2',
      'spoon':'\ud83e\udd44',
      'squid':'\ud83e\udd91',
      'stadium':'\ud83c\udfdf',
      'star':'\u2b50\ufe0f',
      'star2':'\ud83c\udf1f',
      'star_and_crescent':'\u262a\ufe0f',
      'star_of_david':'\u2721\ufe0f',
      'stars':'\ud83c\udf20',
      'station':'\ud83d\ude89',
      'statue_of_liberty':'\ud83d\uddfd',
      'steam_locomotive':'\ud83d\ude82',
      'stew':'\ud83c\udf72',
      'stop_button':'\u23f9',
      'stop_sign':'\ud83d\uded1',
      'stopwatch':'\u23f1',
      'straight_ruler':'\ud83d\udccf',
      'strawberry':'\ud83c\udf53',
      'stuck_out_tongue':'\ud83d\ude1b',
      'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
      'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
      'studio_microphone':'\ud83c\udf99',
      'stuffed_flatbread':'\ud83e\udd59',
      'sun_behind_large_cloud':'\ud83c\udf25',
      'sun_behind_rain_cloud':'\ud83c\udf26',
      'sun_behind_small_cloud':'\ud83c\udf24',
      'sun_with_face':'\ud83c\udf1e',
      'sunflower':'\ud83c\udf3b',
      'sunglasses':'\ud83d\ude0e',
      'sunny':'\u2600\ufe0f',
      'sunrise':'\ud83c\udf05',
      'sunrise_over_mountains':'\ud83c\udf04',
      'surfing_man':'\ud83c\udfc4',
      'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
      'sushi':'\ud83c\udf63',
      'suspension_railway':'\ud83d\ude9f',
      'sweat':'\ud83d\ude13',
      'sweat_drops':'\ud83d\udca6',
      'sweat_smile':'\ud83d\ude05',
      'sweet_potato':'\ud83c\udf60',
      'swimming_man':'\ud83c\udfca',
      'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
      'symbols':'\ud83d\udd23',
      'synagogue':'\ud83d\udd4d',
      'syringe':'\ud83d\udc89',
      'taco':'\ud83c\udf2e',
      'tada':'\ud83c\udf89',
      'tanabata_tree':'\ud83c\udf8b',
      'taurus':'\u2649\ufe0f',
      'taxi':'\ud83d\ude95',
      'tea':'\ud83c\udf75',
      'telephone_receiver':'\ud83d\udcde',
      'telescope':'\ud83d\udd2d',
      'tennis':'\ud83c\udfbe',
      'tent':'\u26fa\ufe0f',
      'thermometer':'\ud83c\udf21',
      'thinking':'\ud83e\udd14',
      'thought_balloon':'\ud83d\udcad',
      'ticket':'\ud83c\udfab',
      'tickets':'\ud83c\udf9f',
      'tiger':'\ud83d\udc2f',
      'tiger2':'\ud83d\udc05',
      'timer_clock':'\u23f2',
      'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
      'tired_face':'\ud83d\ude2b',
      'tm':'\u2122\ufe0f',
      'toilet':'\ud83d\udebd',
      'tokyo_tower':'\ud83d\uddfc',
      'tomato':'\ud83c\udf45',
      'tongue':'\ud83d\udc45',
      'top':'\ud83d\udd1d',
      'tophat':'\ud83c\udfa9',
      'tornado':'\ud83c\udf2a',
      'trackball':'\ud83d\uddb2',
      'tractor':'\ud83d\ude9c',
      'traffic_light':'\ud83d\udea5',
      'train':'\ud83d\ude8b',
      'train2':'\ud83d\ude86',
      'tram':'\ud83d\ude8a',
      'triangular_flag_on_post':'\ud83d\udea9',
      'triangular_ruler':'\ud83d\udcd0',
      'trident':'\ud83d\udd31',
      'triumph':'\ud83d\ude24',
      'trolleybus':'\ud83d\ude8e',
      'trophy':'\ud83c\udfc6',
      'tropical_drink':'\ud83c\udf79',
      'tropical_fish':'\ud83d\udc20',
      'truck':'\ud83d\ude9a',
      'trumpet':'\ud83c\udfba',
      'tulip':'\ud83c\udf37',
      'tumbler_glass':'\ud83e\udd43',
      'turkey':'\ud83e\udd83',
      'turtle':'\ud83d\udc22',
      'tv':'\ud83d\udcfa',
      'twisted_rightwards_arrows':'\ud83d\udd00',
      'two_hearts':'\ud83d\udc95',
      'two_men_holding_hands':'\ud83d\udc6c',
      'two_women_holding_hands':'\ud83d\udc6d',
      'u5272':'\ud83c\ude39',
      'u5408':'\ud83c\ude34',
      'u55b6':'\ud83c\ude3a',
      'u6307':'\ud83c\ude2f\ufe0f',
      'u6708':'\ud83c\ude37\ufe0f',
      'u6709':'\ud83c\ude36',
      'u6e80':'\ud83c\ude35',
      'u7121':'\ud83c\ude1a\ufe0f',
      'u7533':'\ud83c\ude38',
      'u7981':'\ud83c\ude32',
      'u7a7a':'\ud83c\ude33',
      'umbrella':'\u2614\ufe0f',
      'unamused':'\ud83d\ude12',
      'underage':'\ud83d\udd1e',
      'unicorn':'\ud83e\udd84',
      'unlock':'\ud83d\udd13',
      'up':'\ud83c\udd99',
      'upside_down_face':'\ud83d\ude43',
      'v':'\u270c\ufe0f',
      'vertical_traffic_light':'\ud83d\udea6',
      'vhs':'\ud83d\udcfc',
      'vibration_mode':'\ud83d\udcf3',
      'video_camera':'\ud83d\udcf9',
      'video_game':'\ud83c\udfae',
      'violin':'\ud83c\udfbb',
      'virgo':'\u264d\ufe0f',
      'volcano':'\ud83c\udf0b',
      'volleyball':'\ud83c\udfd0',
      'vs':'\ud83c\udd9a',
      'vulcan_salute':'\ud83d\udd96',
      'walking_man':'\ud83d\udeb6',
      'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
      'waning_crescent_moon':'\ud83c\udf18',
      'waning_gibbous_moon':'\ud83c\udf16',
      'warning':'\u26a0\ufe0f',
      'wastebasket':'\ud83d\uddd1',
      'watch':'\u231a\ufe0f',
      'water_buffalo':'\ud83d\udc03',
      'watermelon':'\ud83c\udf49',
      'wave':'\ud83d\udc4b',
      'wavy_dash':'\u3030\ufe0f',
      'waxing_crescent_moon':'\ud83c\udf12',
      'wc':'\ud83d\udebe',
      'weary':'\ud83d\ude29',
      'wedding':'\ud83d\udc92',
      'weight_lifting_man':'\ud83c\udfcb\ufe0f',
      'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
      'whale':'\ud83d\udc33',
      'whale2':'\ud83d\udc0b',
      'wheel_of_dharma':'\u2638\ufe0f',
      'wheelchair':'\u267f\ufe0f',
      'white_check_mark':'\u2705',
      'white_circle':'\u26aa\ufe0f',
      'white_flag':'\ud83c\udff3\ufe0f',
      'white_flower':'\ud83d\udcae',
      'white_large_square':'\u2b1c\ufe0f',
      'white_medium_small_square':'\u25fd\ufe0f',
      'white_medium_square':'\u25fb\ufe0f',
      'white_small_square':'\u25ab\ufe0f',
      'white_square_button':'\ud83d\udd33',
      'wilted_flower':'\ud83e\udd40',
      'wind_chime':'\ud83c\udf90',
      'wind_face':'\ud83c\udf2c',
      'wine_glass':'\ud83c\udf77',
      'wink':'\ud83d\ude09',
      'wolf':'\ud83d\udc3a',
      'woman':'\ud83d\udc69',
      'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
      'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
      'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
      'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
      'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
      'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
      'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
      'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
      'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
      'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
      'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
      'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
      'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
      'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
      'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
      'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
      'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
      'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
      'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
      'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
      'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
      'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
      'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
      'womans_clothes':'\ud83d\udc5a',
      'womans_hat':'\ud83d\udc52',
      'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
      'womens':'\ud83d\udeba',
      'world_map':'\ud83d\uddfa',
      'worried':'\ud83d\ude1f',
      'wrench':'\ud83d\udd27',
      'writing_hand':'\u270d\ufe0f',
      'x':'\u274c',
      'yellow_heart':'\ud83d\udc9b',
      'yen':'\ud83d\udcb4',
      'yin_yang':'\u262f\ufe0f',
      'yum':'\ud83d\ude0b',
      'zap':'\u26a1\ufe0f',
      'zipper_mouth_face':'\ud83e\udd10',
      'zzz':'\ud83d\udca4',

      /* special emojis :P */
      'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
      'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
    };

    /**
     * Created by Estevao on 31-05-2015.
     */

    /**
     * Showdown Converter class
     * @class
     * @param {object} [converterOptions]
     * @returns {Converter}
     */
    showdown.Converter = function (converterOptions) {

      var
          /**
           * Options used by this converter
           * @private
           * @type {{}}
           */
          options = {},

          /**
           * Language extensions used by this converter
           * @private
           * @type {Array}
           */
          langExtensions = [],

          /**
           * Output modifiers extensions used by this converter
           * @private
           * @type {Array}
           */
          outputModifiers = [],

          /**
           * Event listeners
           * @private
           * @type {{}}
           */
          listeners = {},

          /**
           * The flavor set in this converter
           */
          setConvFlavor = setFlavor,

          /**
           * Metadata of the document
           * @type {{parsed: {}, raw: string, format: string}}
           */
          metadata = {
            parsed: {},
            raw: '',
            format: ''
          };

      _constructor();

      /**
       * Converter constructor
       * @private
       */
      function _constructor () {
        converterOptions = converterOptions || {};

        for (var gOpt in globalOptions) {
          if (globalOptions.hasOwnProperty(gOpt)) {
            options[gOpt] = globalOptions[gOpt];
          }
        }

        // Merge options
        if (typeof converterOptions === 'object') {
          for (var opt in converterOptions) {
            if (converterOptions.hasOwnProperty(opt)) {
              options[opt] = converterOptions[opt];
            }
          }
        } else {
          throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
          ' was passed instead.');
        }

        if (options.extensions) {
          showdown.helper.forEach(options.extensions, _parseExtension);
        }
      }

      /**
       * Parse extension
       * @param {*} ext
       * @param {string} [name='']
       * @private
       */
      function _parseExtension (ext, name) {

        name = name || null;
        // If it's a string, the extension was previously loaded
        if (showdown.helper.isString(ext)) {
          ext = showdown.helper.stdExtName(ext);
          name = ext;

          // LEGACY_SUPPORT CODE
          if (showdown.extensions[ext]) {
            console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
              'Please inform the developer that the extension should be updated!');
            legacyExtensionLoading(showdown.extensions[ext], ext);
            return;
            // END LEGACY SUPPORT CODE

          } else if (!showdown.helper.isUndefined(extensions[ext])) {
            ext = extensions[ext];

          } else {
            throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
          }
        }

        if (typeof ext === 'function') {
          ext = ext();
        }

        if (!showdown.helper.isArray(ext)) {
          ext = [ext];
        }

        var validExt = validate(ext, name);
        if (!validExt.valid) {
          throw Error(validExt.error);
        }

        for (var i = 0; i < ext.length; ++i) {
          switch (ext[i].type) {

            case 'lang':
              langExtensions.push(ext[i]);
              break;

            case 'output':
              outputModifiers.push(ext[i]);
              break;
          }
          if (ext[i].hasOwnProperty('listeners')) {
            for (var ln in ext[i].listeners) {
              if (ext[i].listeners.hasOwnProperty(ln)) {
                listen(ln, ext[i].listeners[ln]);
              }
            }
          }
        }

      }

      /**
       * LEGACY_SUPPORT
       * @param {*} ext
       * @param {string} name
       */
      function legacyExtensionLoading (ext, name) {
        if (typeof ext === 'function') {
          ext = ext(new showdown.Converter());
        }
        if (!showdown.helper.isArray(ext)) {
          ext = [ext];
        }
        var valid = validate(ext, name);

        if (!valid.valid) {
          throw Error(valid.error);
        }

        for (var i = 0; i < ext.length; ++i) {
          switch (ext[i].type) {
            case 'lang':
              langExtensions.push(ext[i]);
              break;
            case 'output':
              outputModifiers.push(ext[i]);
              break;
            default:// should never reach here
              throw Error('Extension loader error: Type unrecognized!!!');
          }
        }
      }

      /**
       * Listen to an event
       * @param {string} name
       * @param {function} callback
       */
      function listen (name, callback) {
        if (!showdown.helper.isString(name)) {
          throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
        }

        if (typeof callback !== 'function') {
          throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
        }

        if (!listeners.hasOwnProperty(name)) {
          listeners[name] = [];
        }
        listeners[name].push(callback);
      }

      function rTrimInputText (text) {
        var rsp = text.match(/^\s*/)[0].length,
            rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
        return text.replace(rgx, '');
      }

      /**
       * Dispatch an event
       * @private
       * @param {string} evtName Event name
       * @param {string} text Text
       * @param {{}} options Converter Options
       * @param {{}} globals
       * @returns {string}
       */
      this._dispatch = function dispatch (evtName, text, options, globals) {
        if (listeners.hasOwnProperty(evtName)) {
          for (var ei = 0; ei < listeners[evtName].length; ++ei) {
            var nText = listeners[evtName][ei](evtName, text, this, options, globals);
            if (nText && typeof nText !== 'undefined') {
              text = nText;
            }
          }
        }
        return text;
      };

      /**
       * Listen to an event
       * @param {string} name
       * @param {function} callback
       * @returns {showdown.Converter}
       */
      this.listen = function (name, callback) {
        listen(name, callback);
        return this;
      };

      /**
       * Converts a markdown string into HTML
       * @param {string} text
       * @returns {*}
       */
      this.makeHtml = function (text) {
        //check if text is not falsy
        if (!text) {
          return text;
        }

        var globals = {
          gHtmlBlocks:     [],
          gHtmlMdBlocks:   [],
          gHtmlSpans:      [],
          gUrls:           {},
          gTitles:         {},
          gDimensions:     {},
          gListLevel:      0,
          hashLinkCounts:  {},
          langExtensions:  langExtensions,
          outputModifiers: outputModifiers,
          converter:       this,
          ghCodeBlocks:    [],
          metadata: {
            parsed: {},
            raw: '',
            format: ''
          }
        };

        // This lets us use ¨ trema as an escape char to avoid md5 hashes
        // The choice of character is arbitrary; anything that isn't
        // magic in Markdown will work.
        text = text.replace(/¨/g, '¨T');

        // Replace $ with ¨D
        // RegExp interprets $ as a special character
        // when it's in a replacement string
        text = text.replace(/\$/g, '¨D');

        // Standardize line endings
        text = text.replace(/\r\n/g, '\n'); // DOS to Unix
        text = text.replace(/\r/g, '\n'); // Mac to Unix

        // Stardardize line spaces
        text = text.replace(/\u00A0/g, '&nbsp;');

        if (options.smartIndentationFix) {
          text = rTrimInputText(text);
        }

        // Make sure text begins and ends with a couple of newlines:
        text = '\n\n' + text + '\n\n';

        // detab
        text = showdown.subParser('detab')(text, options, globals);

        /**
         * Strip any lines consisting only of spaces and tabs.
         * This makes subsequent regexs easier to write, because we can
         * match consecutive blank lines with /\n+/ instead of something
         * contorted like /[ \t]*\n+/
         */
        text = text.replace(/^[ \t]+$/mg, '');

        //run languageExtensions
        showdown.helper.forEach(langExtensions, function (ext) {
          text = showdown.subParser('runExtension')(ext, text, options, globals);
        });

        // run the sub parsers
        text = showdown.subParser('metadata')(text, options, globals);
        text = showdown.subParser('hashPreCodeTags')(text, options, globals);
        text = showdown.subParser('githubCodeBlocks')(text, options, globals);
        text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
        text = showdown.subParser('hashCodeTags')(text, options, globals);
        text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
        text = showdown.subParser('blockGamut')(text, options, globals);
        text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
        text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

        // attacklab: Restore dollar signs
        text = text.replace(/¨D/g, '$$');

        // attacklab: Restore tremas
        text = text.replace(/¨T/g, '¨');

        // render a complete html document instead of a partial if the option is enabled
        text = showdown.subParser('completeHTMLDocument')(text, options, globals);

        // Run output modifiers
        showdown.helper.forEach(outputModifiers, function (ext) {
          text = showdown.subParser('runExtension')(ext, text, options, globals);
        });

        // update metadata
        metadata = globals.metadata;
        return text;
      };

      /**
       * Converts an HTML string into a markdown string
       * @param src
       * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
       * @returns {string}
       */
      this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

        // replace \r\n with \n
        src = src.replace(/\r\n/g, '\n');
        src = src.replace(/\r/g, '\n'); // old macs

        // due to an edge case, we need to find this: > <
        // to prevent removing of non silent white spaces
        // ex: <em>this is</em> <strong>sparta</strong>
        src = src.replace(/>[ \t]+</, '>¨NBSP;<');

        if (!HTMLParser) {
          if (window && window.document) {
            HTMLParser = window.document;
          } else {
            throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
          }
        }

        var doc = HTMLParser.createElement('div');
        doc.innerHTML = src;

        var globals = {
          preList: substitutePreCodeTags(doc)
        };

        // remove all newlines and collapse spaces
        clean(doc);

        // some stuff, like accidental reference links must now be escaped
        // TODO
        // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

        var nodes = doc.childNodes,
            mdDoc = '';

        for (var i = 0; i < nodes.length; i++) {
          mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
        }

        function clean (node) {
          for (var n = 0; n < node.childNodes.length; ++n) {
            var child = node.childNodes[n];
            if (child.nodeType === 3) {
              if (!/\S/.test(child.nodeValue) && !/^[ ]+$/.test(child.nodeValue)) {
                node.removeChild(child);
                --n;
              } else {
                child.nodeValue = child.nodeValue.split('\n').join(' ');
                child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
              }
            } else if (child.nodeType === 1) {
              clean(child);
            }
          }
        }

        // find all pre tags and replace contents with placeholder
        // we need this so that we can remove all indentation from html
        // to ease up parsing
        function substitutePreCodeTags (doc) {

          var pres = doc.querySelectorAll('pre'),
              presPH = [];

          for (var i = 0; i < pres.length; ++i) {

            if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
              var content = pres[i].firstChild.innerHTML.trim(),
                  language = pres[i].firstChild.getAttribute('data-language') || '';

              // if data-language attribute is not defined, then we look for class language-*
              if (language === '') {
                var classes = pres[i].firstChild.className.split(' ');
                for (var c = 0; c < classes.length; ++c) {
                  var matches = classes[c].match(/^language-(.+)$/);
                  if (matches !== null) {
                    language = matches[1];
                    break;
                  }
                }
              }

              // unescape html entities in content
              content = showdown.helper.unescapeHTMLEntities(content);

              presPH.push(content);
              pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
            } else {
              presPH.push(pres[i].innerHTML);
              pres[i].innerHTML = '';
              pres[i].setAttribute('prenum', i.toString());
            }
          }
          return presPH;
        }

        return mdDoc;
      };

      /**
       * Set an option of this Converter instance
       * @param {string} key
       * @param {*} value
       */
      this.setOption = function (key, value) {
        options[key] = value;
      };

      /**
       * Get the option of this Converter instance
       * @param {string} key
       * @returns {*}
       */
      this.getOption = function (key) {
        return options[key];
      };

      /**
       * Get the options of this Converter instance
       * @returns {{}}
       */
      this.getOptions = function () {
        return options;
      };

      /**
       * Add extension to THIS converter
       * @param {{}} extension
       * @param {string} [name=null]
       */
      this.addExtension = function (extension, name) {
        name = name || null;
        _parseExtension(extension, name);
      };

      /**
       * Use a global registered extension with THIS converter
       * @param {string} extensionName Name of the previously registered extension
       */
      this.useExtension = function (extensionName) {
        _parseExtension(extensionName);
      };

      /**
       * Set the flavor THIS converter should use
       * @param {string} name
       */
      this.setFlavor = function (name) {
        if (!flavor.hasOwnProperty(name)) {
          throw Error(name + ' flavor was not found');
        }
        var preset = flavor[name];
        setConvFlavor = name;
        for (var option in preset) {
          if (preset.hasOwnProperty(option)) {
            options[option] = preset[option];
          }
        }
      };

      /**
       * Get the currently set flavor of this converter
       * @returns {string}
       */
      this.getFlavor = function () {
        return setConvFlavor;
      };

      /**
       * Remove an extension from THIS converter.
       * Note: This is a costly operation. It's better to initialize a new converter
       * and specify the extensions you wish to use
       * @param {Array} extension
       */
      this.removeExtension = function (extension) {
        if (!showdown.helper.isArray(extension)) {
          extension = [extension];
        }
        for (var a = 0; a < extension.length; ++a) {
          var ext = extension[a];
          for (var i = 0; i < langExtensions.length; ++i) {
            if (langExtensions[i] === ext) {
              langExtensions.splice(i, 1);
            }
          }
          for (var ii = 0; ii < outputModifiers.length; ++ii) {
            if (outputModifiers[ii] === ext) {
              outputModifiers.splice(ii, 1);
            }
          }
        }
      };

      /**
       * Get all extension of THIS converter
       * @returns {{language: Array, output: Array}}
       */
      this.getAllExtensions = function () {
        return {
          language: langExtensions,
          output: outputModifiers
        };
      };

      /**
       * Get the metadata of the previously parsed document
       * @param raw
       * @returns {string|{}}
       */
      this.getMetadata = function (raw) {
        if (raw) {
          return metadata.raw;
        } else {
          return metadata.parsed;
        }
      };

      /**
       * Get the metadata format of the previously parsed document
       * @returns {string}
       */
      this.getMetadataFormat = function () {
        return metadata.format;
      };

      /**
       * Private: set a single key, value metadata pair
       * @param {string} key
       * @param {string} value
       */
      this._setMetadataPair = function (key, value) {
        metadata.parsed[key] = value;
      };

      /**
       * Private: set metadata format
       * @param {string} format
       */
      this._setMetadataFormat = function (format) {
        metadata.format = format;
      };

      /**
       * Private: set metadata raw text
       * @param {string} raw
       */
      this._setMetadataRaw = function (raw) {
        metadata.raw = raw;
      };
    };

    /**
     * Turn Markdown link shortcuts into XHTML <a> tags.
     */
    showdown.subParser('anchors', function (text, options, globals) {

      text = globals.converter._dispatch('anchors.before', text, options, globals);

      var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
        if (showdown.helper.isUndefined(title)) {
          title = '';
        }
        linkId = linkId.toLowerCase();

        // Special case for explicit empty url
        if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
          url = '';
        } else if (!url) {
          if (!linkId) {
            // lower-case and turn embedded newlines into spaces
            linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
          }
          url = '#' + linkId;

          if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
            url = globals.gUrls[linkId];
            if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
              title = globals.gTitles[linkId];
            }
          } else {
            return wholeMatch;
          }
        }

        //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
        url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

        var result = '<a href="' + url + '"';

        if (title !== '' && title !== null) {
          title = title.replace(/"/g, '&quot;');
          //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
          title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          result += ' title="' + title + '"';
        }

        // optionLinksInNewWindow only applies
        // to external links. Hash links (#) open in same page
        if (options.openLinksInNewWindow && !/^#/.test(url)) {
          // escaped _
          result += ' rel="noopener noreferrer" target="¨E95Eblank"';
        }

        result += '>' + linkText + '</a>';

        return result;
      };

      // First, handle reference-style links: [link text] [id]
      text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

      // Next, inline-style links: [link text](url "optional title")
      // cases with crazy urls like ./image/cat1).png
      text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
        writeAnchorTag);

      // normal cases
      text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
        writeAnchorTag);

      // handle reference-style shortcuts: [link text]
      // These must come last in case you've also got [link test][1]
      // or [link test](/foo)
      text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

      // Lastly handle GithubMentions if option is enabled
      if (options.ghMentions) {
        text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
          if (escape === '\\') {
            return st + mentions;
          }

          //check if options.ghMentionsLink is a string
          if (!showdown.helper.isString(options.ghMentionsLink)) {
            throw new Error('ghMentionsLink option must be a string');
          }
          var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
              target = '';
          if (options.openLinksInNewWindow) {
            target = ' rel="noopener noreferrer" target="¨E95Eblank"';
          }
          return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
        });
      }

      text = globals.converter._dispatch('anchors.after', text, options, globals);
      return text;
    });

    // url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

    var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
        simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
        delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
        simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
        delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

        replaceLink = function (options) {
          return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
            link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
            var lnkTxt = link,
                append = '',
                target = '',
                lmc    = leadingMagicChars || '',
                tmc    = trailingMagicChars || '';
            if (/^www\./i.test(link)) {
              link = link.replace(/^www\./i, 'http://www.');
            }
            if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
              append = trailingPunctuation;
            }
            if (options.openLinksInNewWindow) {
              target = ' rel="noopener noreferrer" target="¨E95Eblank"';
            }
            return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
          };
        },

        replaceMail = function (options, globals) {
          return function (wholeMatch, b, mail) {
            var href = 'mailto:';
            b = b || '';
            mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
            if (options.encodeEmails) {
              href = showdown.helper.encodeEmailAddress(href + mail);
              mail = showdown.helper.encodeEmailAddress(mail);
            } else {
              href = href + mail;
            }
            return b + '<a href="' + href + '">' + mail + '</a>';
          };
        };

    showdown.subParser('autoLinks', function (text, options, globals) {

      text = globals.converter._dispatch('autoLinks.before', text, options, globals);

      text = text.replace(delimUrlRegex, replaceLink(options));
      text = text.replace(delimMailRegex, replaceMail(options, globals));

      text = globals.converter._dispatch('autoLinks.after', text, options, globals);

      return text;
    });

    showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {

      if (!options.simplifiedAutoLink) {
        return text;
      }

      text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

      if (options.excludeTrailingPunctuationFromURLs) {
        text = text.replace(simpleURLRegex2, replaceLink(options));
      } else {
        text = text.replace(simpleURLRegex, replaceLink(options));
      }
      text = text.replace(simpleMailRegex, replaceMail(options, globals));

      text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

      return text;
    });

    /**
     * These are all the transformations that form block-level
     * tags like paragraphs, headers, and list items.
     */
    showdown.subParser('blockGamut', function (text, options, globals) {

      text = globals.converter._dispatch('blockGamut.before', text, options, globals);

      // we parse blockquotes first so that we can have headings and hrs
      // inside blockquotes
      text = showdown.subParser('blockQuotes')(text, options, globals);
      text = showdown.subParser('headers')(text, options, globals);

      // Do Horizontal Rules:
      text = showdown.subParser('horizontalRule')(text, options, globals);

      text = showdown.subParser('lists')(text, options, globals);
      text = showdown.subParser('codeBlocks')(text, options, globals);
      text = showdown.subParser('tables')(text, options, globals);

      // We already ran _HashHTMLBlocks() before, in Markdown(), but that
      // was to escape raw HTML in the original Markdown source. This time,
      // we're escaping the markup we've just created, so that we don't wrap
      // <p> tags around block-level tags.
      text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
      text = showdown.subParser('paragraphs')(text, options, globals);

      text = globals.converter._dispatch('blockGamut.after', text, options, globals);

      return text;
    });

    showdown.subParser('blockQuotes', function (text, options, globals) {

      text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

      // add a couple extra lines after the text and endtext mark
      text = text + '\n\n';

      var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

      if (options.splitAdjacentBlockquotes) {
        rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
      }

      text = text.replace(rgx, function (bq) {
        // attacklab: hack around Konqueror 3.5.4 bug:
        // "----------bug".replace(/^-/g,"") == "bug"
        bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

        // attacklab: clean up hack
        bq = bq.replace(/¨0/g, '');

        bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
        bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
        bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

        bq = bq.replace(/(^|\n)/g, '$1  ');
        // These leading spaces screw with <pre> content, so we need to fix that:
        bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
          var pre = m1;
          // attacklab: hack around Konqueror 3.5.4 bug:
          pre = pre.replace(/^  /mg, '¨0');
          pre = pre.replace(/¨0/g, '');
          return pre;
        });

        return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
      });

      text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
      return text;
    });

    /**
     * Process Markdown `<pre><code>` blocks.
     */
    showdown.subParser('codeBlocks', function (text, options, globals) {

      text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

      // sentinel workarounds for lack of \A and \Z, safari\khtml bug
      text += '¨0';

      var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
      text = text.replace(pattern, function (wholeMatch, m1, m2) {
        var codeblock = m1,
            nextChar = m2,
            end = '\n';

        codeblock = showdown.subParser('outdent')(codeblock, options, globals);
        codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
        codeblock = showdown.subParser('detab')(codeblock, options, globals);
        codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
        codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

        if (options.omitExtraWLInCodeBlocks) {
          end = '';
        }

        codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

        return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
      });

      // strip sentinel
      text = text.replace(/¨0/, '');

      text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
      return text;
    });

    /**
     *
     *   *  Backtick quotes are used for <code></code> spans.
     *
     *   *  You can use multiple backticks as the delimiters if you want to
     *     include literal backticks in the code span. So, this input:
     *
     *         Just type ``foo `bar` baz`` at the prompt.
     *
     *       Will translate to:
     *
     *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
     *
     *    There's no arbitrary limit to the number of backticks you
     *    can use as delimters. If you need three consecutive backticks
     *    in your code, use four for delimiters, etc.
     *
     *  *  You can use spaces to get literal backticks at the edges:
     *
     *         ... type `` `bar` `` ...
     *
     *       Turns to:
     *
     *         ... type <code>`bar`</code> ...
     */
    showdown.subParser('codeSpans', function (text, options, globals) {

      text = globals.converter._dispatch('codeSpans.before', text, options, globals);

      if (typeof (text) === 'undefined') {
        text = '';
      }
      text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
        function (wholeMatch, m1, m2, m3) {
          var c = m3;
          c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
          c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
          c = showdown.subParser('encodeCode')(c, options, globals);
          c = m1 + '<code>' + c + '</code>';
          c = showdown.subParser('hashHTMLSpans')(c, options, globals);
          return c;
        }
      );

      text = globals.converter._dispatch('codeSpans.after', text, options, globals);
      return text;
    });

    /**
     * Create a full HTML document from the processed markdown
     */
    showdown.subParser('completeHTMLDocument', function (text, options, globals) {

      if (!options.completeHTMLDocument) {
        return text;
      }

      text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

      var doctype = 'html',
          doctypeParsed = '<!DOCTYPE HTML>\n',
          title = '',
          charset = '<meta charset="utf-8">\n',
          lang = '',
          metadata = '';

      if (typeof globals.metadata.parsed.doctype !== 'undefined') {
        doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
        doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
        if (doctype === 'html' || doctype === 'html5') {
          charset = '<meta charset="utf-8">';
        }
      }

      for (var meta in globals.metadata.parsed) {
        if (globals.metadata.parsed.hasOwnProperty(meta)) {
          switch (meta.toLowerCase()) {
            case 'doctype':
              break;

            case 'title':
              title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
              break;

            case 'charset':
              if (doctype === 'html' || doctype === 'html5') {
                charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
              } else {
                charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
              }
              break;

            case 'language':
            case 'lang':
              lang = ' lang="' + globals.metadata.parsed[meta] + '"';
              metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
              break;

            default:
              metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
          }
        }
      }

      text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

      text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
      return text;
    });

    /**
     * Convert all tabs to spaces
     */
    showdown.subParser('detab', function (text, options, globals) {
      text = globals.converter._dispatch('detab.before', text, options, globals);

      // expand first n-1 tabs
      text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

      // replace the nth with two sentinels
      text = text.replace(/\t/g, '¨A¨B');

      // use the sentinel to anchor our regex so it doesn't explode
      text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
        var leadingText = m1,
            numSpaces = 4 - leadingText.length % 4;  // g_tab_width

        // there *must* be a better way to do this:
        for (var i = 0; i < numSpaces; i++) {
          leadingText += ' ';
        }

        return leadingText;
      });

      // clean up sentinels
      text = text.replace(/¨A/g, '    ');  // g_tab_width
      text = text.replace(/¨B/g, '');

      text = globals.converter._dispatch('detab.after', text, options, globals);
      return text;
    });

    showdown.subParser('ellipsis', function (text, options, globals) {

      if (!options.ellipsis) {
        return text;
      }

      text = globals.converter._dispatch('ellipsis.before', text, options, globals);

      text = text.replace(/\.\.\./g, '…');

      text = globals.converter._dispatch('ellipsis.after', text, options, globals);

      return text;
    });

    /**
     * Turn emoji codes into emojis
     *
     * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
     */
    showdown.subParser('emoji', function (text, options, globals) {

      if (!options.emoji) {
        return text;
      }

      text = globals.converter._dispatch('emoji.before', text, options, globals);

      var emojiRgx = /:([\S]+?):/g;

      text = text.replace(emojiRgx, function (wm, emojiCode) {
        if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
          return showdown.helper.emojis[emojiCode];
        }
        return wm;
      });

      text = globals.converter._dispatch('emoji.after', text, options, globals);

      return text;
    });

    /**
     * Smart processing for ampersands and angle brackets that need to be encoded.
     */
    showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
      text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

      // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
      // http://bumppo.net/projects/amputator/
      text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

      // Encode naked <'s
      text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

      // Encode <
      text = text.replace(/</g, '&lt;');

      // Encode >
      text = text.replace(/>/g, '&gt;');

      text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
      return text;
    });

    /**
     * Returns the string, with after processing the following backslash escape sequences.
     *
     * attacklab: The polite way to do this is with the new escapeCharacters() function:
     *
     *    text = escapeCharacters(text,"\\",true);
     *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
     *
     * ...but we're sidestepping its use of the (slow) RegExp constructor
     * as an optimization for Firefox.  This function gets called a LOT.
     */
    showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
      text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

      text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
      text = text.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, showdown.helper.escapeCharactersCallback);

      text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
      return text;
    });

    /**
     * Encode/escape certain characters inside Markdown code runs.
     * The point is that in code, these characters are literals,
     * and lose their special Markdown meanings.
     */
    showdown.subParser('encodeCode', function (text, options, globals) {

      text = globals.converter._dispatch('encodeCode.before', text, options, globals);

      // Encode all ampersands; HTML entities are not
      // entities within a Markdown code span.
      text = text
        .replace(/&/g, '&amp;')
      // Do the angle bracket song and dance:
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
      // Now, escape characters that are magic in Markdown:
        .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

      text = globals.converter._dispatch('encodeCode.after', text, options, globals);
      return text;
    });

    /**
     * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
     * don't conflict with their use in Markdown for code, italics and strong.
     */
    showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
      text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

      // Build a regex to find HTML tags.
      var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
          comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

      text = text.replace(tags, function (wholeMatch) {
        return wholeMatch
          .replace(/(.)<\/?code>(?=.)/g, '$1`')
          .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
      });

      text = text.replace(comments, function (wholeMatch) {
        return wholeMatch
          .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
      });

      text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
      return text;
    });

    /**
     * Handle github codeblocks prior to running HashHTML so that
     * HTML contained within the codeblock gets escaped properly
     * Example:
     * ```ruby
     *     def hello_world(x)
     *       puts "Hello, #{x}"
     *     end
     * ```
     */
    showdown.subParser('githubCodeBlocks', function (text, options, globals) {

      // early exit if option is not enabled
      if (!options.ghCodeBlocks) {
        return text;
      }

      text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

      text += '¨0';

      text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
        var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

        // First parse the github code block
        codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
        codeblock = showdown.subParser('detab')(codeblock, options, globals);
        codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
        codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

        codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

        codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

        // Since GHCodeblocks can be false positives, we need to
        // store the primitive text and the parsed text in a global var,
        // and then return a token
        return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
      });

      // attacklab: strip sentinel
      text = text.replace(/¨0/, '');

      return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
    });

    showdown.subParser('hashBlock', function (text, options, globals) {
      text = globals.converter._dispatch('hashBlock.before', text, options, globals);
      text = text.replace(/(^\n+|\n+$)/g, '');
      text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
      text = globals.converter._dispatch('hashBlock.after', text, options, globals);
      return text;
    });

    /**
     * Hash and escape <code> elements that should not be parsed as markdown
     */
    showdown.subParser('hashCodeTags', function (text, options, globals) {
      text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

      var repFunc = function (wholeMatch, match, left, right) {
        var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
        return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
      };

      // Hash naked <code>
      text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

      text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
      return text;
    });

    showdown.subParser('hashElement', function (text, options, globals) {

      return function (wholeMatch, m1) {
        var blockText = m1;

        // Undo double lines
        blockText = blockText.replace(/\n\n/g, '\n');
        blockText = blockText.replace(/^\n/, '');

        // strip trailing blank lines
        blockText = blockText.replace(/\n+$/g, '');

        // Replace the element text with a marker ("¨KxK" where x is its key)
        blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

        return blockText;
      };
    });

    showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
      text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

      var blockTags = [
            'pre',
            'div',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'blockquote',
            'table',
            'dl',
            'ol',
            'ul',
            'script',
            'noscript',
            'form',
            'fieldset',
            'iframe',
            'math',
            'style',
            'section',
            'header',
            'footer',
            'nav',
            'article',
            'aside',
            'address',
            'audio',
            'canvas',
            'figure',
            'hgroup',
            'output',
            'video',
            'p'
          ],
          repFunc = function (wholeMatch, match, left, right) {
            var txt = wholeMatch;
            // check if this html element is marked as markdown
            // if so, it's contents should be parsed as markdown
            if (left.search(/\bmarkdown\b/) !== -1) {
              txt = left + globals.converter.makeHtml(match) + right;
            }
            return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
          };

      if (options.backslashEscapesHTMLTags) {
        // encode backslash escaped HTML tags
        text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
          return '&lt;' + inside + '&gt;';
        });
      }

      // hash HTML Blocks
      for (var i = 0; i < blockTags.length; ++i) {

        var opTagPos,
            rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
            patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
            patRight = '</' + blockTags[i] + '>';
        // 1. Look for the first position of the first opening HTML tag in the text
        while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

          // if the HTML tag is \ escaped, we need to escape it and break


          //2. Split the text in that position
          var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
              //3. Match recursively
              newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

          // prevent an infinite loop
          if (newSubText1 === subTexts[1]) {
            break;
          }
          text = subTexts[0].concat(newSubText1);
        }
      }
      // HR SPECIAL CASE
      text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
        showdown.subParser('hashElement')(text, options, globals));

      // Special case for standalone HTML comments
      text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
      }, '^ {0,3}<!--', '-->', 'gm');

      // PHP and ASP-style processor instructions (<?...?> and <%...%>)
      text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
        showdown.subParser('hashElement')(text, options, globals));

      text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
      return text;
    });

    /**
     * Hash span elements that should not be parsed as markdown
     */
    showdown.subParser('hashHTMLSpans', function (text, options, globals) {
      text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

      function hashHTMLSpan (html) {
        return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
      }

      // Hash Self Closing tags
      text = text.replace(/<[^>]+?\/>/gi, function (wm) {
        return hashHTMLSpan(wm);
      });

      // Hash tags without properties
      text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
        return hashHTMLSpan(wm);
      });

      // Hash tags with properties
      text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
        return hashHTMLSpan(wm);
      });

      // Hash self closing tags without />
      text = text.replace(/<[^>]+?>/gi, function (wm) {
        return hashHTMLSpan(wm);
      });

      /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

      text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
      return text;
    });

    /**
     * Unhash HTML spans
     */
    showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
      text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

      for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
        var repText = globals.gHtmlSpans[i],
            // limiter to prevent infinite loop (assume 10 as limit for recurse)
            limit = 0;

        while (/¨C(\d+)C/.test(repText)) {
          var num = RegExp.$1;
          repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
          if (limit === 10) {
            console.error('maximum nesting of 10 spans reached!!!');
            break;
          }
          ++limit;
        }
        text = text.replace('¨C' + i + 'C', repText);
      }

      text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
      return text;
    });

    /**
     * Hash and escape <pre><code> elements that should not be parsed as markdown
     */
    showdown.subParser('hashPreCodeTags', function (text, options, globals) {
      text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

      var repFunc = function (wholeMatch, match, left, right) {
        // encode html entities
        var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
        return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
      };

      // Hash <pre><code>
      text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

      text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
      return text;
    });

    showdown.subParser('headers', function (text, options, globals) {

      text = globals.converter._dispatch('headers.before', text, options, globals);

      var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

          // Set text-style headers:
          //	Header 1
          //	========
          //
          //	Header 2
          //	--------
          //
          setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
          setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

      text = text.replace(setextRegexH1, function (wholeMatch, m1) {

        var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
            hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
            hLevel = headerLevelStart,
            hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
        return showdown.subParser('hashBlock')(hashBlock, options, globals);
      });

      text = text.replace(setextRegexH2, function (matchFound, m1) {
        var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
            hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
            hLevel = headerLevelStart + 1,
            hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
        return showdown.subParser('hashBlock')(hashBlock, options, globals);
      });

      // atx-style headers:
      //  # Header 1
      //  ## Header 2
      //  ## Header 2 with closing hashes ##
      //  ...
      //  ###### Header 6
      //
      var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

      text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
        var hText = m2;
        if (options.customizedHeaderId) {
          hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
        }

        var span = showdown.subParser('spanGamut')(hText, options, globals),
            hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
            hLevel = headerLevelStart - 1 + m1.length,
            header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

        return showdown.subParser('hashBlock')(header, options, globals);
      });

      function headerId (m) {
        var title,
            prefix;

        // It is separate from other options to allow combining prefix and customized
        if (options.customizedHeaderId) {
          var match = m.match(/\{([^{]+?)}\s*$/);
          if (match && match[1]) {
            m = match[1];
          }
        }

        title = m;

        // Prefix id to prevent causing inadvertent pre-existing style matches.
        if (showdown.helper.isString(options.prefixHeaderId)) {
          prefix = options.prefixHeaderId;
        } else if (options.prefixHeaderId === true) {
          prefix = 'section-';
        } else {
          prefix = '';
        }

        if (!options.rawPrefixHeaderId) {
          title = prefix + title;
        }

        if (options.ghCompatibleHeaderId) {
          title = title
            .replace(/ /g, '-')
            // replace previously escaped chars (&, ¨ and $)
            .replace(/&amp;/g, '')
            .replace(/¨T/g, '')
            .replace(/¨D/g, '')
            // replace rest of the chars (&~$ are repeated as they might have been escaped)
            // borrowed from github's redcarpet (some they should produce similar results)
            .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
            .toLowerCase();
        } else if (options.rawHeaderId) {
          title = title
            .replace(/ /g, '-')
            // replace previously escaped chars (&, ¨ and $)
            .replace(/&amp;/g, '&')
            .replace(/¨T/g, '¨')
            .replace(/¨D/g, '$')
            // replace " and '
            .replace(/["']/g, '-')
            .toLowerCase();
        } else {
          title = title
            .replace(/[^\w]/g, '')
            .toLowerCase();
        }

        if (options.rawPrefixHeaderId) {
          title = prefix + title;
        }

        if (globals.hashLinkCounts[title]) {
          title = title + '-' + (globals.hashLinkCounts[title]++);
        } else {
          globals.hashLinkCounts[title] = 1;
        }
        return title;
      }

      text = globals.converter._dispatch('headers.after', text, options, globals);
      return text;
    });

    /**
     * Turn Markdown link shortcuts into XHTML <a> tags.
     */
    showdown.subParser('horizontalRule', function (text, options, globals) {
      text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

      var key = showdown.subParser('hashBlock')('<hr />', options, globals);
      text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
      text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
      text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

      text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
      return text;
    });

    /**
     * Turn Markdown image shortcuts into <img> tags.
     */
    showdown.subParser('images', function (text, options, globals) {

      text = globals.converter._dispatch('images.before', text, options, globals);

      var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
          crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
          base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
          referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
          refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

      function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
        url = url.replace(/\s/g, '');
        return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
      }

      function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

        var gUrls   = globals.gUrls,
            gTitles = globals.gTitles,
            gDims   = globals.gDimensions;

        linkId = linkId.toLowerCase();

        if (!title) {
          title = '';
        }
        // Special case for explicit empty url
        if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
          url = '';

        } else if (url === '' || url === null) {
          if (linkId === '' || linkId === null) {
            // lower-case and turn embedded newlines into spaces
            linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
          }
          url = '#' + linkId;

          if (!showdown.helper.isUndefined(gUrls[linkId])) {
            url = gUrls[linkId];
            if (!showdown.helper.isUndefined(gTitles[linkId])) {
              title = gTitles[linkId];
            }
            if (!showdown.helper.isUndefined(gDims[linkId])) {
              width = gDims[linkId].width;
              height = gDims[linkId].height;
            }
          } else {
            return wholeMatch;
          }
        }

        altText = altText
          .replace(/"/g, '&quot;')
        //altText = showdown.helper.escapeCharacters(altText, '*_', false);
          .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
        //url = showdown.helper.escapeCharacters(url, '*_', false);
        url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
        var result = '<img src="' + url + '" alt="' + altText + '"';

        if (title && showdown.helper.isString(title)) {
          title = title
            .replace(/"/g, '&quot;')
          //title = showdown.helper.escapeCharacters(title, '*_', false);
            .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          result += ' title="' + title + '"';
        }

        if (width && height) {
          width  = (width === '*') ? 'auto' : width;
          height = (height === '*') ? 'auto' : height;

          result += ' width="' + width + '"';
          result += ' height="' + height + '"';
        }

        result += ' />';

        return result;
      }

      // First, handle reference-style labeled images: ![alt text][id]
      text = text.replace(referenceRegExp, writeImageTag);

      // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

      // base64 encoded images
      text = text.replace(base64RegExp, writeImageTagBase64);

      // cases with crazy urls like ./image/cat1).png
      text = text.replace(crazyRegExp, writeImageTag);

      // normal cases
      text = text.replace(inlineRegExp, writeImageTag);

      // handle reference-style shortcuts: ![img text]
      text = text.replace(refShortcutRegExp, writeImageTag);

      text = globals.converter._dispatch('images.after', text, options, globals);
      return text;
    });

    showdown.subParser('italicsAndBold', function (text, options, globals) {

      text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

      // it's faster to have 3 separate regexes for each case than have just one
      // because of backtracing, in some cases, it could lead to an exponential effect
      // called "catastrophic backtrace". Ominous!

      function parseInside (txt, left, right) {
        /*
        if (options.simplifiedAutoLink) {
          txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
        }
        */
        return left + txt + right;
      }

      // Parse underscores
      if (options.literalMidWordUnderscores) {
        text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
          return parseInside (txt, '<strong><em>', '</em></strong>');
        });
        text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
          return parseInside (txt, '<strong>', '</strong>');
        });
        text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
          return parseInside (txt, '<em>', '</em>');
        });
      } else {
        text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
          return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
        });
        text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
          return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
        });
        text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
          // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
          return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
        });
      }

      // Now parse asterisks
      if (options.literalMidWordAsterisks) {
        text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
          return parseInside (txt, lead + '<strong><em>', '</em></strong>');
        });
        text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
          return parseInside (txt, lead + '<strong>', '</strong>');
        });
        text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
          return parseInside (txt, lead + '<em>', '</em>');
        });
      } else {
        text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
          return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
        });
        text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
          return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
        });
        text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
          // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
          return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
        });
      }


      text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
      return text;
    });

    /**
     * Form HTML ordered (numbered) and unordered (bulleted) lists.
     */
    showdown.subParser('lists', function (text, options, globals) {

      /**
       * Process the contents of a single ordered or unordered list, splitting it
       * into individual list items.
       * @param {string} listStr
       * @param {boolean} trimTrailing
       * @returns {string}
       */
      function processListItems (listStr, trimTrailing) {
        // The $g_list_level global keeps track of when we're inside a list.
        // Each time we enter a list, we increment it; when we leave a list,
        // we decrement. If it's zero, we're not in a list anymore.
        //
        // We do this because when we're not inside a list, we want to treat
        // something like this:
        //
        //    I recommend upgrading to version
        //    8. Oops, now this line is treated
        //    as a sub-list.
        //
        // As a single paragraph, despite the fact that the second line starts
        // with a digit-period-space sequence.
        //
        // Whereas when we're inside a list (or sub-list), that line will be
        // treated as the start of a sub-list. What a kludge, huh? This is
        // an aspect of Markdown's syntax that's hard to parse perfectly
        // without resorting to mind-reading. Perhaps the solution is to
        // change the syntax rules such that sub-lists must start with a
        // starting cardinal number; e.g. "1." or "a.".
        globals.gListLevel++;

        // trim trailing blank lines:
        listStr = listStr.replace(/\n{2,}$/, '\n');

        // attacklab: add sentinel to emulate \z
        listStr += '¨0';

        var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
            isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

        // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
        // which is a syntax breaking change
        // activating this option reverts to old behavior
        if (options.disableForced4SpacesIndentedSublists) {
          rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
        }

        listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
          checked = (checked && checked.trim() !== '');

          var item = showdown.subParser('outdent')(m4, options, globals),
              bulletStyle = '';

          // Support for github tasklists
          if (taskbtn && options.tasklists) {
            bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
            item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
              var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
              if (checked) {
                otp += ' checked';
              }
              otp += '>';
              return otp;
            });
          }

          // ISSUE #312
          // This input: - - - a
          // causes trouble to the parser, since it interprets it as:
          // <ul><li><li><li>a</li></li></li></ul>
          // instead of:
          // <ul><li>- - a</li></ul>
          // So, to prevent it, we will put a marker (¨A)in the beginning of the line
          // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
          item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
            return '¨A' + wm2;
          });

          // m1 - Leading line or
          // Has a double return (multi paragraph) or
          // Has sublist
          if (m1 || (item.search(/\n{2,}/) > -1)) {
            item = showdown.subParser('githubCodeBlocks')(item, options, globals);
            item = showdown.subParser('blockGamut')(item, options, globals);
          } else {
            // Recursion for sub-lists:
            item = showdown.subParser('lists')(item, options, globals);
            item = item.replace(/\n$/, ''); // chomp(item)
            item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

            // Colapse double linebreaks
            item = item.replace(/\n\n+/g, '\n\n');
            if (isParagraphed) {
              item = showdown.subParser('paragraphs')(item, options, globals);
            } else {
              item = showdown.subParser('spanGamut')(item, options, globals);
            }
          }

          // now we need to remove the marker (¨A)
          item = item.replace('¨A', '');
          // we can finally wrap the line in list item tags
          item =  '<li' + bulletStyle + '>' + item + '</li>\n';

          return item;
        });

        // attacklab: strip sentinel
        listStr = listStr.replace(/¨0/g, '');

        globals.gListLevel--;

        if (trimTrailing) {
          listStr = listStr.replace(/\s+$/, '');
        }

        return listStr;
      }

      function styleStartNumber (list, listType) {
        // check if ol and starts by a number different than 1
        if (listType === 'ol') {
          var res = list.match(/^ *(\d+)\./);
          if (res && res[1] !== '1') {
            return ' start="' + res[1] + '"';
          }
        }
        return '';
      }

      /**
       * Check and parse consecutive lists (better fix for issue #142)
       * @param {string} list
       * @param {string} listType
       * @param {boolean} trimTrailing
       * @returns {string}
       */
      function parseConsecutiveLists (list, listType, trimTrailing) {
        // check if we caught 2 or more consecutive lists by mistake
        // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
        var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
            ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
            counterRxg = (listType === 'ul') ? olRgx : ulRgx,
            result = '';

        if (list.search(counterRxg) !== -1) {
          (function parseCL (txt) {
            var pos = txt.search(counterRxg),
                style = styleStartNumber(list, listType);
            if (pos !== -1) {
              // slice
              result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

              // invert counterType and listType
              listType = (listType === 'ul') ? 'ol' : 'ul';
              counterRxg = (listType === 'ul') ? olRgx : ulRgx;

              //recurse
              parseCL(txt.slice(pos));
            } else {
              result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
            }
          })(list);
        } else {
          var style = styleStartNumber(list, listType);
          result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
        }

        return result;
      }

      /** Start of list parsing **/
      text = globals.converter._dispatch('lists.before', text, options, globals);
      // add sentinel to hack around khtml/safari bug:
      // http://bugs.webkit.org/show_bug.cgi?id=11231
      text += '¨0';

      if (globals.gListLevel) {
        text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
          function (wholeMatch, list, m2) {
            var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
            return parseConsecutiveLists(list, listType, true);
          }
        );
      } else {
        text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
          function (wholeMatch, m1, list, m3) {
            var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
            return parseConsecutiveLists(list, listType, false);
          }
        );
      }

      // strip sentinel
      text = text.replace(/¨0/, '');
      text = globals.converter._dispatch('lists.after', text, options, globals);
      return text;
    });

    /**
     * Parse metadata at the top of the document
     */
    showdown.subParser('metadata', function (text, options, globals) {

      if (!options.metadata) {
        return text;
      }

      text = globals.converter._dispatch('metadata.before', text, options, globals);

      function parseMetadataContents (content) {
        // raw is raw so it's not changed in any way
        globals.metadata.raw = content;

        // escape chars forbidden in html attributes
        // double quotes
        content = content
          // ampersand first
          .replace(/&/g, '&amp;')
          // double quotes
          .replace(/"/g, '&quot;');

        content = content.replace(/\n {4}/g, ' ');
        content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
          globals.metadata.parsed[key] = value;
          return '';
        });
      }

      text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
        parseMetadataContents(content);
        return '¨M';
      });

      text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
        if (format) {
          globals.metadata.format = format;
        }
        parseMetadataContents(content);
        return '¨M';
      });

      text = text.replace(/¨M/g, '');

      text = globals.converter._dispatch('metadata.after', text, options, globals);
      return text;
    });

    /**
     * Remove one level of line-leading tabs or spaces
     */
    showdown.subParser('outdent', function (text, options, globals) {
      text = globals.converter._dispatch('outdent.before', text, options, globals);

      // attacklab: hack around Konqueror 3.5.4 bug:
      // "----------bug".replace(/^-/g,"") == "bug"
      text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

      // attacklab: clean up hack
      text = text.replace(/¨0/g, '');

      text = globals.converter._dispatch('outdent.after', text, options, globals);
      return text;
    });

    /**
     *
     */
    showdown.subParser('paragraphs', function (text, options, globals) {

      text = globals.converter._dispatch('paragraphs.before', text, options, globals);
      // Strip leading and trailing lines:
      text = text.replace(/^\n+/g, '');
      text = text.replace(/\n+$/g, '');

      var grafs = text.split(/\n{2,}/g),
          grafsOut = [],
          end = grafs.length; // Wrap <p> tags

      for (var i = 0; i < end; i++) {
        var str = grafs[i];
        // if this is an HTML marker, copy it
        if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
          grafsOut.push(str);

        // test for presence of characters to prevent empty lines being parsed
        // as paragraphs (resulting in undesired extra empty paragraphs)
        } else if (str.search(/\S/) >= 0) {
          str = showdown.subParser('spanGamut')(str, options, globals);
          str = str.replace(/^([ \t]*)/g, '<p>');
          str += '</p>';
          grafsOut.push(str);
        }
      }

      /** Unhashify HTML blocks */
      end = grafsOut.length;
      for (i = 0; i < end; i++) {
        var blockText = '',
            grafsOutIt = grafsOut[i],
            codeFlag = false;
        // if this is a marker for an html block...
        // use RegExp.test instead of string.search because of QML bug
        while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
          var delim = RegExp.$1,
              num   = RegExp.$2;

          if (delim === 'K') {
            blockText = globals.gHtmlBlocks[num];
          } else {
            // we need to check if ghBlock is a false positive
            if (codeFlag) {
              // use encoded version of all text
              blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
            } else {
              blockText = globals.ghCodeBlocks[num].codeblock;
            }
          }
          blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

          grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
          // Check if grafsOutIt is a pre->code
          if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
            codeFlag = true;
          }
        }
        grafsOut[i] = grafsOutIt;
      }
      text = grafsOut.join('\n');
      // Strip leading and trailing lines:
      text = text.replace(/^\n+/g, '');
      text = text.replace(/\n+$/g, '');
      return globals.converter._dispatch('paragraphs.after', text, options, globals);
    });

    /**
     * Run extension
     */
    showdown.subParser('runExtension', function (ext, text, options, globals) {

      if (ext.filter) {
        text = ext.filter(text, globals.converter, options);

      } else if (ext.regex) {
        // TODO remove this when old extension loading mechanism is deprecated
        var re = ext.regex;
        if (!(re instanceof RegExp)) {
          re = new RegExp(re, 'g');
        }
        text = text.replace(re, ext.replace);
      }

      return text;
    });

    /**
     * These are all the transformations that occur *within* block-level
     * tags like paragraphs, headers, and list items.
     */
    showdown.subParser('spanGamut', function (text, options, globals) {

      text = globals.converter._dispatch('spanGamut.before', text, options, globals);
      text = showdown.subParser('codeSpans')(text, options, globals);
      text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
      text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

      // Process anchor and image tags. Images must come first,
      // because ![foo][f] looks like an anchor.
      text = showdown.subParser('images')(text, options, globals);
      text = showdown.subParser('anchors')(text, options, globals);

      // Make links out of things like `<http://example.com/>`
      // Must come after anchors, because you can use < and >
      // delimiters in inline links like [this](<url>).
      text = showdown.subParser('autoLinks')(text, options, globals);
      text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
      text = showdown.subParser('emoji')(text, options, globals);
      text = showdown.subParser('underline')(text, options, globals);
      text = showdown.subParser('italicsAndBold')(text, options, globals);
      text = showdown.subParser('strikethrough')(text, options, globals);
      text = showdown.subParser('ellipsis')(text, options, globals);

      // we need to hash HTML tags inside spans
      text = showdown.subParser('hashHTMLSpans')(text, options, globals);

      // now we encode amps and angles
      text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

      // Do hard breaks
      if (options.simpleLineBreaks) {
        // GFM style hard breaks
        // only add line breaks if the text does not contain a block (special case for lists)
        if (!/\n\n¨K/.test(text)) {
          text = text.replace(/\n+/g, '<br />\n');
        }
      } else {
        // Vanilla hard breaks
        text = text.replace(/  +\n/g, '<br />\n');
      }

      text = globals.converter._dispatch('spanGamut.after', text, options, globals);
      return text;
    });

    showdown.subParser('strikethrough', function (text, options, globals) {

      function parseInside (txt) {
        if (options.simplifiedAutoLink) {
          txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
        }
        return '<del>' + txt + '</del>';
      }

      if (options.strikethrough) {
        text = globals.converter._dispatch('strikethrough.before', text, options, globals);
        text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
        text = globals.converter._dispatch('strikethrough.after', text, options, globals);
      }

      return text;
    });

    /**
     * Strips link definitions from text, stores the URLs and titles in
     * hash references.
     * Link defs are in the form: ^[id]: url "optional title"
     */
    showdown.subParser('stripLinkDefinitions', function (text, options, globals) {

      var regex       = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
          base64Regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

      // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
      text += '¨0';

      var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {

        // if there aren't two instances of linkId it must not be a reference link so back out
        linkId = linkId.toLowerCase();
        if (text.toLowerCase().split(linkId).length - 1 < 2) {
          return wholeMatch;
        }
        if (url.match(/^data:.+?\/.+?;base64,/)) {
          // remove newlines
          globals.gUrls[linkId] = url.replace(/\s/g, '');
        } else {
          globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
        }

        if (blankLines) {
          // Oops, found blank lines, so it's not a title.
          // Put back the parenthetical statement we stole.
          return blankLines + title;

        } else {
          if (title) {
            globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
          }
          if (options.parseImgDimensions && width && height) {
            globals.gDimensions[linkId] = {
              width:  width,
              height: height
            };
          }
        }
        // Completely remove the definition from the text
        return '';
      };

      // first we try to find base64 link references
      text = text.replace(base64Regex, replaceFunc);

      text = text.replace(regex, replaceFunc);

      // attacklab: strip sentinel
      text = text.replace(/¨0/, '');

      return text;
    });

    showdown.subParser('tables', function (text, options, globals) {

      if (!options.tables) {
        return text;
      }

      var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
          //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
          singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

      function parseStyles (sLine) {
        if (/^:[ \t]*--*$/.test(sLine)) {
          return ' style="text-align:left;"';
        } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
          return ' style="text-align:right;"';
        } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
          return ' style="text-align:center;"';
        } else {
          return '';
        }
      }

      function parseHeaders (header, style) {
        var id = '';
        header = header.trim();
        // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
        if (options.tablesHeaderId || options.tableHeaderId) {
          id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
        }
        header = showdown.subParser('spanGamut')(header, options, globals);

        return '<th' + id + style + '>' + header + '</th>\n';
      }

      function parseCells (cell, style) {
        var subText = showdown.subParser('spanGamut')(cell, options, globals);
        return '<td' + style + '>' + subText + '</td>\n';
      }

      function buildTable (headers, cells) {
        var tb = '<table>\n<thead>\n<tr>\n',
            tblLgn = headers.length;

        for (var i = 0; i < tblLgn; ++i) {
          tb += headers[i];
        }
        tb += '</tr>\n</thead>\n<tbody>\n';

        for (i = 0; i < cells.length; ++i) {
          tb += '<tr>\n';
          for (var ii = 0; ii < tblLgn; ++ii) {
            tb += cells[i][ii];
          }
          tb += '</tr>\n';
        }
        tb += '</tbody>\n</table>\n';
        return tb;
      }

      function parseTable (rawTable) {
        var i, tableLines = rawTable.split('\n');

        for (i = 0; i < tableLines.length; ++i) {
          // strip wrong first and last column if wrapped tables are used
          if (/^ {0,3}\|/.test(tableLines[i])) {
            tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
          }
          if (/\|[ \t]*$/.test(tableLines[i])) {
            tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
          }
          // parse code spans first, but we only support one line code spans
          tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
        }

        var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
            rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
            rawCells = [],
            headers = [],
            styles = [],
            cells = [];

        tableLines.shift();
        tableLines.shift();

        for (i = 0; i < tableLines.length; ++i) {
          if (tableLines[i].trim() === '') {
            continue;
          }
          rawCells.push(
            tableLines[i]
              .split('|')
              .map(function (s) {
                return s.trim();
              })
          );
        }

        if (rawHeaders.length < rawStyles.length) {
          return rawTable;
        }

        for (i = 0; i < rawStyles.length; ++i) {
          styles.push(parseStyles(rawStyles[i]));
        }

        for (i = 0; i < rawHeaders.length; ++i) {
          if (showdown.helper.isUndefined(styles[i])) {
            styles[i] = '';
          }
          headers.push(parseHeaders(rawHeaders[i], styles[i]));
        }

        for (i = 0; i < rawCells.length; ++i) {
          var row = [];
          for (var ii = 0; ii < headers.length; ++ii) {
            if (showdown.helper.isUndefined(rawCells[i][ii])) ;
            row.push(parseCells(rawCells[i][ii], styles[ii]));
          }
          cells.push(row);
        }

        return buildTable(headers, cells);
      }

      text = globals.converter._dispatch('tables.before', text, options, globals);

      // find escaped pipe characters
      text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

      // parse multi column tables
      text = text.replace(tableRgx, parseTable);

      // parse one column tables
      text = text.replace(singeColTblRgx, parseTable);

      text = globals.converter._dispatch('tables.after', text, options, globals);

      return text;
    });

    showdown.subParser('underline', function (text, options, globals) {

      if (!options.underline) {
        return text;
      }

      text = globals.converter._dispatch('underline.before', text, options, globals);

      if (options.literalMidWordUnderscores) {
        text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
          return '<u>' + txt + '</u>';
        });
        text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
          return '<u>' + txt + '</u>';
        });
      } else {
        text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
          return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
        });
        text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
          return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
        });
      }

      // escape remaining underscores to prevent them being parsed by italic and bold
      text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

      text = globals.converter._dispatch('underline.after', text, options, globals);

      return text;
    });

    /**
     * Swap back in all the special characters we've hidden.
     */
    showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
      text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

      text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
        var charCodeToReplace = parseInt(m1);
        return String.fromCharCode(charCodeToReplace);
      });

      text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
      return text;
    });

    showdown.subParser('makeMarkdown.blockquote', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes()) {
        var children = node.childNodes,
            childrenLength = children.length;

        for (var i = 0; i < childrenLength; ++i) {
          var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

          if (innerTxt === '') {
            continue;
          }
          txt += innerTxt;
        }
      }
      // cleanup
      txt = txt.trim();
      txt = '> ' + txt.split('\n').join('\n> ');
      return txt;
    });

    showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {

      var lang = node.getAttribute('language'),
          num  = node.getAttribute('precodenum');
      return '```' + lang + '\n' + globals.preList[num] + '\n```';
    });

    showdown.subParser('makeMarkdown.codeSpan', function (node) {

      return '`' + node.innerHTML + '`';
    });

    showdown.subParser('makeMarkdown.emphasis', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes()) {
        txt += '*';
        var children = node.childNodes,
            childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
        txt += '*';
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {

      var headerMark = new Array(headerLevel + 1).join('#'),
          txt = '';

      if (node.hasChildNodes()) {
        txt = headerMark + ' ';
        var children = node.childNodes,
            childrenLength = children.length;

        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.hr', function () {

      return '---';
    });

    showdown.subParser('makeMarkdown.image', function (node) {

      var txt = '';
      if (node.hasAttribute('src')) {
        txt += '![' + node.getAttribute('alt') + '](';
        txt += '<' + node.getAttribute('src') + '>';
        if (node.hasAttribute('width') && node.hasAttribute('height')) {
          txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
        }

        if (node.hasAttribute('title')) {
          txt += ' "' + node.getAttribute('title') + '"';
        }
        txt += ')';
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.links', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes() && node.hasAttribute('href')) {
        var children = node.childNodes,
            childrenLength = children.length;
        txt = '[';
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
        txt += '](';
        txt += '<' + node.getAttribute('href') + '>';
        if (node.hasAttribute('title')) {
          txt += ' "' + node.getAttribute('title') + '"';
        }
        txt += ')';
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.list', function (node, globals, type) {

      var txt = '';
      if (!node.hasChildNodes()) {
        return '';
      }
      var listItems       = node.childNodes,
          listItemsLenght = listItems.length,
          listNum = node.getAttribute('start') || 1;

      for (var i = 0; i < listItemsLenght; ++i) {
        if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
          continue;
        }

        // define the bullet to use in list
        var bullet = '';
        if (type === 'ol') {
          bullet = listNum.toString() + '. ';
        } else {
          bullet = '- ';
        }

        // parse list item
        txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
        ++listNum;
      }

      // add comment at the end to prevent consecutive lists to be parsed as one
      txt += '\n<!-- -->\n';
      return txt.trim();
    });

    showdown.subParser('makeMarkdown.listItem', function (node, globals) {

      var listItemTxt = '';

      var children = node.childNodes,
          childrenLenght = children.length;

      for (var i = 0; i < childrenLenght; ++i) {
        listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
      }
      // if it's only one liner, we need to add a newline at the end
      if (!/\n$/.test(listItemTxt)) {
        listItemTxt += '\n';
      } else {
        // it's multiparagraph, so we need to indent
        listItemTxt = listItemTxt
          .split('\n')
          .join('\n    ')
          .replace(/^ {4}$/gm, '')
          .replace(/\n\n+/g, '\n\n');
      }

      return listItemTxt;
    });



    showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {

      spansOnly = spansOnly || false;

      var txt = '';

      // edge case of text without wrapper paragraph
      if (node.nodeType === 3) {
        return showdown.subParser('makeMarkdown.txt')(node, globals);
      }

      // HTML comment
      if (node.nodeType === 8) {
        return '<!--' + node.data + '-->\n\n';
      }

      // process only node elements
      if (node.nodeType !== 1) {
        return '';
      }

      var tagName = node.tagName.toLowerCase();

      switch (tagName) {

        //
        // BLOCKS
        //
        case 'h1':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
          break;
        case 'h2':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
          break;
        case 'h3':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
          break;
        case 'h4':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
          break;
        case 'h5':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
          break;
        case 'h6':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
          break;

        case 'p':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
          break;

        case 'blockquote':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
          break;

        case 'hr':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
          break;

        case 'ol':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
          break;

        case 'ul':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
          break;

        case 'precode':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
          break;

        case 'pre':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
          break;

        case 'table':
          if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
          break;

        //
        // SPANS
        //
        case 'code':
          txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
          break;

        case 'em':
        case 'i':
          txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
          break;

        case 'strong':
        case 'b':
          txt = showdown.subParser('makeMarkdown.strong')(node, globals);
          break;

        case 'del':
          txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
          break;

        case 'a':
          txt = showdown.subParser('makeMarkdown.links')(node, globals);
          break;

        case 'img':
          txt = showdown.subParser('makeMarkdown.image')(node, globals);
          break;

        default:
          txt = node.outerHTML + '\n\n';
      }

      // common normalization
      // TODO eventually

      return txt;
    });

    showdown.subParser('makeMarkdown.paragraph', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes()) {
        var children = node.childNodes,
            childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
      }

      // some text normalization
      txt = txt.trim();

      return txt;
    });

    showdown.subParser('makeMarkdown.pre', function (node, globals) {

      var num  = node.getAttribute('prenum');
      return '<pre>' + globals.preList[num] + '</pre>';
    });

    showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes()) {
        txt += '~~';
        var children = node.childNodes,
            childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
        txt += '~~';
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.strong', function (node, globals) {

      var txt = '';
      if (node.hasChildNodes()) {
        txt += '**';
        var children = node.childNodes,
            childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
        }
        txt += '**';
      }
      return txt;
    });

    showdown.subParser('makeMarkdown.table', function (node, globals) {

      var txt = '',
          tableArray = [[], []],
          headings   = node.querySelectorAll('thead>tr>th'),
          rows       = node.querySelectorAll('tbody>tr'),
          i, ii;
      for (i = 0; i < headings.length; ++i) {
        var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
            allign = '---';

        if (headings[i].hasAttribute('style')) {
          var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
          switch (style) {
            case 'text-align:left;':
              allign = ':---';
              break;
            case 'text-align:right;':
              allign = '---:';
              break;
            case 'text-align:center;':
              allign = ':---:';
              break;
          }
        }
        tableArray[0][i] = headContent.trim();
        tableArray[1][i] = allign;
      }

      for (i = 0; i < rows.length; ++i) {
        var r = tableArray.push([]) - 1,
            cols = rows[i].getElementsByTagName('td');

        for (ii = 0; ii < headings.length; ++ii) {
          var cellContent = ' ';
          if (typeof cols[ii] !== 'undefined') {
            cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
          }
          tableArray[r].push(cellContent);
        }
      }

      var cellSpacesCount = 3;
      for (i = 0; i < tableArray.length; ++i) {
        for (ii = 0; ii < tableArray[i].length; ++ii) {
          var strLen = tableArray[i][ii].length;
          if (strLen > cellSpacesCount) {
            cellSpacesCount = strLen;
          }
        }
      }

      for (i = 0; i < tableArray.length; ++i) {
        for (ii = 0; ii < tableArray[i].length; ++ii) {
          if (i === 1) {
            if (tableArray[i][ii].slice(-1) === ':') {
              tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
            } else {
              tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
            }
          } else {
            tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
          }
        }
        txt += '| ' + tableArray[i].join(' | ') + ' |\n';
      }

      return txt.trim();
    });

    showdown.subParser('makeMarkdown.tableCell', function (node, globals) {

      var txt = '';
      if (!node.hasChildNodes()) {
        return '';
      }
      var children = node.childNodes,
          childrenLength = children.length;

      for (var i = 0; i < childrenLength; ++i) {
        txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
      }
      return txt.trim();
    });

    showdown.subParser('makeMarkdown.txt', function (node) {

      var txt = node.nodeValue;

      // multiple spaces are collapsed
      txt = txt.replace(/ +/g, ' ');

      // replace the custom ¨NBSP; with a space
      txt = txt.replace(/¨NBSP;/g, ' ');

      // ", <, > and & should replace escaped html entities
      txt = showdown.helper.unescapeHTMLEntities(txt);

      // escape markdown magic characters
      // emphasis, strong and strikethrough - can appear everywhere
      // we also escape pipe (|) because of tables
      // and escape ` because of code blocks and spans
      txt = txt.replace(/([*_~|`])/g, '\\$1');

      // escape > because of blockquotes
      txt = txt.replace(/^(\s*)>/g, '\\$1>');

      // hash character, only troublesome at the beginning of a line because of headers
      txt = txt.replace(/^#/gm, '\\#');

      // horizontal rules
      txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

      // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
      txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

      // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
      txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

      // images and links, ] followed by ( is problematic, so we escape it
      txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

      // reference URIs must also be escaped
      txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

      return txt;
    });

    var root = this;

    // AMD Loader
    if (module.exports) {
      module.exports = showdown;

    // Regular Browser loader
    } else {
      root.showdown = showdown;
    }
    }).call(commonjsGlobal);


    });

    const schema = {
        actionTypes: {
            data:           [],
            fields:         ["Type", "Description", "Response type", 'Description', 'Linked adaptation actions', 'recordID']
        },
        hazardEvents: {
            data:           [],
            fields:         ["Hazard event", "Hazard", "Type", "Climate variables", "Description", "Linked adaptation actions", "recordID"]
        },
        hazards: {
            data:           [],
            fields:         ["Hazard", "Alias", "Trend", "Climate hazard (IPCC)",  "Linked hazard events", "Link climate variables", "Linked adaptation actions", "recordID"]
        },
        climateVariables: {
            data:           [],
            fields:         ["Variable", "Alias", "Data availability", "Unit", "Change unit", "Description", "order", "Linked hazards", "Linked hazard events", "recordID"]
        },
        ipccHazards: {
            data:           [],
            fields:         ["IPCC impactHazard (IPCC)", "Description", "Linked hazards", "recordID"]
        },
        adaptationFocus: {
            data:           [],
            fields:         ["Focus area", "Alias", "Description", "Linked adaptation actions", "recordID"]
        },
        adaptationApproaches: {
            data:           [],
            fields:         ["Adaptation and risk approach", "Approach theme", "Description", "Linked approach theme", "Linked adaptation actions", "recordID"]
        },
        communityRisks: {
            data:           [],
            fields:         ["Community risk", "Risk area", "Risk bearer", "Hazard events", "Linked hazards", "IPCC impact", "recordID"]
        },
        riskArea: {
            data:           [],
            fields:         ["Risk area", "Description", "recordID"]
        },
        ipccImpacts: {
            data:           [],
            fields:         ["IPCC impact", "IPCC Impact theme", "Impacted system", "Description", "Hazard", "Baseline frequency", "Projected frequency", "recordID"]
        },
        actionScale: {
            data:           [],
            fields:         ["Scale", "Alias",  "Description", "rank", "radius", "yPos",  "Linked adaptation actions", "recordID"]
        },
        actionTypeNodes: {
            data:           [],
            fields:         ["Name", "Class",  "xPos", "yPos", "curveYoffset", "nodeCurve", "recordID"]
        },
        actionTypeLinks: {
            data:           [],
            fields:         ["Name", "_source",  "_target", "midX", "midY"]
        },
        adaptationScreens: {
            data:           [],
            fields:         ["Screen", "Description", "fieldName", "xPos", "yPos", "lensPos"]
        },
        riskDeterminants: {
            data:           [],
            fields:         ["Name"]
        }

    };

    /* src/components/byPage/postcards/postcard/Main.svelte generated by Svelte v3.48.0 */
    const file$t = "src/components/byPage/postcards/postcard/Main.svelte";

    // (22:8) {#if (actionData["More info #1 URL"] && actionData["More info #1 description"])              ||  (actionData["More info #2 URL"] && actionData["More info #2 description"])              ||  (actionData["More info #3 URL"] && actionData["More info #3 description"])           }
    function create_if_block$b(ctx) {
    	let div;
    	let h3;
    	let t1;
    	let ul;
    	let t2;
    	let t3;
    	let if_block0 = /*actionData*/ ctx[0]["More info #1 URL"] && /*actionData*/ ctx[0]["More info #1 description"] && create_if_block_3$3(ctx);
    	let if_block1 = /*actionData*/ ctx[0]["More info #2 URL"] && /*actionData*/ ctx[0]["More info #2 description"] && create_if_block_2$7(ctx);
    	let if_block2 = /*actionData*/ ctx[0]["More info #3 URL"] && /*actionData*/ ctx[0]["More info #3 description"] && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			h3.textContent = "Find out more";
    			t1 = space();
    			ul = element("ul");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(h3, "class", "svelte-1alepd0");
    			add_location(h3, file$t, 26, 12, 1094);
    			attr_dev(ul, "class", "svelte-1alepd0");
    			add_location(ul, file$t, 27, 12, 1129);
    			attr_dev(div, "class", "further-info-container svelte-1alepd0");
    			add_location(div, file$t, 25, 8, 1044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(div, t1);
    			append_dev(div, ul);
    			if (if_block0) if_block0.m(ul, null);
    			append_dev(ul, t2);
    			if (if_block1) if_block1.m(ul, null);
    			append_dev(ul, t3);
    			if (if_block2) if_block2.m(ul, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*actionData*/ ctx[0]["More info #1 URL"] && /*actionData*/ ctx[0]["More info #1 description"]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$3(ctx);
    					if_block0.c();
    					if_block0.m(ul, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*actionData*/ ctx[0]["More info #2 URL"] && /*actionData*/ ctx[0]["More info #2 description"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$7(ctx);
    					if_block1.c();
    					if_block1.m(ul, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*actionData*/ ctx[0]["More info #3 URL"] && /*actionData*/ ctx[0]["More info #3 description"]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$9(ctx);
    					if_block2.c();
    					if_block2.m(ul, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(22:8) {#if (actionData[\\\"More info #1 URL\\\"] && actionData[\\\"More info #1 description\\\"])              ||  (actionData[\\\"More info #2 URL\\\"] && actionData[\\\"More info #2 description\\\"])              ||  (actionData[\\\"More info #3 URL\\\"] && actionData[\\\"More info #3 description\\\"])           }",
    		ctx
    	});

    	return block;
    }

    // (29:12) {#if actionData["More info #1 URL"] && actionData["More info #1 description"] }
    function create_if_block_3$3(ctx) {
    	let li;
    	let a;
    	let raw_value = /*actionData*/ ctx[0]["More info #1 description"] + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			attr_dev(a, "href", a_href_value = /*actionData*/ ctx[0]["More info #1 URL"]);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$t, 29, 20, 1246);
    			attr_dev(li, "class", "svelte-1alepd0");
    			add_location(li, file$t, 29, 16, 1242);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			a.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*actionData*/ 1 && raw_value !== (raw_value = /*actionData*/ ctx[0]["More info #1 description"] + "")) a.innerHTML = raw_value;
    			if (dirty & /*actionData*/ 1 && a_href_value !== (a_href_value = /*actionData*/ ctx[0]["More info #1 URL"])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(29:12) {#if actionData[\\\"More info #1 URL\\\"] && actionData[\\\"More info #1 description\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (32:12) {#if actionData["More info #2 URL"] && actionData["More info #2 description"] }
    function create_if_block_2$7(ctx) {
    	let li;
    	let a;
    	let raw_value = /*actionData*/ ctx[0]["More info #2 description"] + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			attr_dev(a, "href", a_href_value = /*actionData*/ ctx[0]["More info #2 URL"]);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$t, 32, 20, 1493);
    			attr_dev(li, "class", "svelte-1alepd0");
    			add_location(li, file$t, 32, 16, 1489);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			a.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*actionData*/ 1 && raw_value !== (raw_value = /*actionData*/ ctx[0]["More info #2 description"] + "")) a.innerHTML = raw_value;
    			if (dirty & /*actionData*/ 1 && a_href_value !== (a_href_value = /*actionData*/ ctx[0]["More info #2 URL"])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(32:12) {#if actionData[\\\"More info #2 URL\\\"] && actionData[\\\"More info #2 description\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (35:12) {#if actionData["More info #3 URL"] && actionData["More info #3 description"] }
    function create_if_block_1$9(ctx) {
    	let li;
    	let a;
    	let raw_value = /*actionData*/ ctx[0]["More info #3 description"] + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			attr_dev(a, "href", a_href_value = /*actionData*/ ctx[0]["More info #3 URL"]);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$t, 35, 20, 1740);
    			attr_dev(li, "class", "svelte-1alepd0");
    			add_location(li, file$t, 35, 16, 1736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			a.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*actionData*/ 1 && raw_value !== (raw_value = /*actionData*/ ctx[0]["More info #3 description"] + "")) a.innerHTML = raw_value;
    			if (dirty & /*actionData*/ 1 && a_href_value !== (a_href_value = /*actionData*/ ctx[0]["More info #3 URL"])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(35:12) {#if actionData[\\\"More info #3 URL\\\"] && actionData[\\\"More info #3 description\\\"] }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let section;
    	let div1;
    	let h3;
    	let t1;
    	let div0;
    	let raw_value = /*converter*/ ctx[1].makeHtml(/*actionData*/ ctx[0].Description) + "";
    	let t2;
    	let if_block = (/*actionData*/ ctx[0]["More info #1 URL"] && /*actionData*/ ctx[0]["More info #1 description"] || /*actionData*/ ctx[0]["More info #2 URL"] && /*actionData*/ ctx[0]["More info #2 description"] || /*actionData*/ ctx[0]["More info #3 URL"] && /*actionData*/ ctx[0]["More info #3 description"]) && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div1 = element("div");
    			h3 = element("h3");
    			h3.textContent = "About the action";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(h3, "class", "svelte-1alepd0");
    			add_location(h3, file$t, 16, 8, 599);
    			attr_dev(div0, "class", "about-content svelte-1alepd0");
    			add_location(div0, file$t, 17, 8, 633);
    			attr_dev(div1, "class", "about-container svelte-1alepd0");
    			add_location(div1, file$t, 15, 4, 559);
    			attr_dev(section, "class", "main svelte-1alepd0");
    			add_location(section, file$t, 14, 0, 531);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div1);
    			append_dev(div1, h3);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(section, t2);
    			if (if_block) if_block.m(section, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*actionData*/ 1 && raw_value !== (raw_value = /*converter*/ ctx[1].makeHtml(/*actionData*/ ctx[0].Description) + "")) div0.innerHTML = raw_value;
    			if (/*actionData*/ ctx[0]["More info #1 URL"] && /*actionData*/ ctx[0]["More info #1 description"] || /*actionData*/ ctx[0]["More info #2 URL"] && /*actionData*/ ctx[0]["More info #2 description"] || /*actionData*/ ctx[0]["More info #3 URL"] && /*actionData*/ ctx[0]["More info #3 description"]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, []);
    	let { actionData } = $$props;

    	// HTML converter
    	const converter = new showdown.Converter();

    	const risks = actionData["Direct risks addressed"]
    	? actionData["Direct risks addressed"].map(d => schema.climateRisks.data.filter(e => e.recordID === d)[0].Risk)
    	: [];

    	const riskGroups = actionData["Risk group"] ? actionData["Risk group"] : [];
    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({
    		showdown,
    		schema,
    		actionData,
    		converter,
    		risks,
    		riskGroups
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actionData, converter];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$t, create_fragment$t, safe_not_equal, { actionData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[0] === undefined && !('actionData' in props)) {
    			console.warn("<Main> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/Image.svelte generated by Svelte v3.48.0 */

    const file$s = "src/components/byPage/postcards/postcard/Image.svelte";

    function create_fragment$s(ctx) {
    	let section;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			section = element("section");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*imgURL*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-596oyo");
    			add_location(img, file$s, 13, 4, 639);
    			attr_dev(section, "class", "img-wrapper svelte-596oyo");
    			add_location(section, file$s, 7, 0, 103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, img);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*imgURL*/ 1 && !src_url_equal(img.src, img_src_value = /*imgURL*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Image', slots, []);
    	let { imgURL } = $$props;
    	const writable_props = ['imgURL'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Image> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('imgURL' in $$props) $$invalidate(0, imgURL = $$props.imgURL);
    	};

    	$$self.$capture_state = () => ({ imgURL });

    	$$self.$inject_state = $$props => {
    		if ('imgURL' in $$props) $$invalidate(0, imgURL = $$props.imgURL);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [imgURL];
    }

    class Image$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$s, create_fragment$s, safe_not_equal, { imgURL: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image",
    			options,
    			id: create_fragment$s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*imgURL*/ ctx[0] === undefined && !('imgURL' in props)) {
    			console.warn("<Image> was created without expected prop 'imgURL'");
    		}
    	}

    	get imgURL() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imgURL(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* SVG paths */

    const icons = {
        heat:                   "M-4.907-4.685c-.16.544-.989.301-.829-.244a12.75 12.75 0 0 1 12.22-9.112c7.039 0 12.745 5.706 12.745 12.745 0 7.04-5.706 12.746-12.745 12.746-.57 0-.57-.866 0-.866 6.56 0 11.88-5.319 11.88-11.88 0-6.56-5.32-11.88-11.88-11.88a11.887 11.887 0 0 0-11.39 8.491zm-32.127 22.497c-.565.053-.646-.806-.08-.86 1.629-.153 3.219.347 4.177 1.734.606.877 1.518 1.53 2.618 1.53 1.1 0 2.012-.652 2.617-1.53 1.641-2.376 5.344-2.346 6.964 0 .606.877 1.518 1.53 2.617 1.53 1.1 0 2.013-.652 2.618-1.53.958-1.387 2.548-1.887 4.177-1.733.566.053.484.912-.08.859-1.312-.124-2.61.24-3.387 1.365-.767 1.112-1.94 1.905-3.328 1.905-1.387 0-2.56-.793-3.328-1.905-1.282-1.856-4.25-1.872-5.543 0-.768 1.112-1.94 1.905-3.328 1.905-1.387 0-2.56-.793-3.328-1.905-.777-1.125-2.075-1.489-3.387-1.365zm0-6.876c-.565.054-.646-.805-.08-.859 1.628-.154 3.219.346 4.177 1.734.29.42.624.754.982 1.001 1.022.705 2.25.705 3.272 0 .848-.585 1.122-1.413 2.001-2.02 1.448-1 3.477-1 4.925 0 .88.607 1.153 1.435 2 2.02 1.016.7 2.258.7 3.273 0 1.134-.783 1.181-1.776 2.741-2.415.763-.313 1.605-.397 2.418-.32.565.054.484.913-.08.86-.685-.065-1.385.002-2.01.258-1.277.524-1.48 1.57-2.578 2.328-1.314.907-2.939.907-4.253 0-.907-.627-1.191-1.462-2.001-2.021-1.154-.796-2.79-.796-3.944 0-.81.559-1.094 1.394-2 2.02-1.32.912-2.935.912-4.254 0a4.743 4.743 0 0 1-1.201-1.22c-.777-1.125-2.074-1.49-3.386-1.366zm0-6.875c-.565.053-.646-.806-.08-.86 1.628-.153 3.219.347 4.177 1.735.606.877 1.518 1.53 2.618 1.53 1.1 0 2.012-.653 2.617-1.53.788-1.142 2.101-1.773 3.482-1.773 1.381 0 2.694.63 3.482 1.773.606.877 1.518 1.53 2.617 1.53.563 0 1.127-.177 1.636-.53 1.134-.782 1.181-1.776 2.741-2.415.763-.312 1.605-.396 2.418-.32.565.054.484.913-.08.86-.685-.065-1.386.003-2.01.259-1.277.524-1.48 1.57-2.578 2.327a3.728 3.728 0 0 1-2.126.684c-1.387 0-2.56-.793-3.328-1.905-.629-.91-1.674-1.397-2.772-1.397-1.099 0-2.144.487-2.773 1.397-.767 1.112-1.94 1.905-3.327 1.905s-2.56-.793-3.328-1.905c-.777-1.125-2.075-1.489-3.387-1.365zM-2.499 24.7V11.347c0-.57.866-.57.866 0V24.7a1.52 1.52 0 1 1-.866 0zM2.443 4.108v16.873c0 .513-.025.355.31.73A6.454 6.454 0 0 1 4.4 26.014a6.466 6.466 0 1 1-11.202-4.401c.253-.272.218-.166.218-.545V4.108c0-5.934 9.026-5.953 9.026 0zm-8.16 0V21.25c0 .552.035.458-.311.804a5.6 5.6 0 1 0 7.963.04c-.373-.38-.35-.183-.35-.77V4.109c0-4.802-7.302-4.802-7.302 0zm21.66-5.405c0-.341.52-.341.52 0 0 5.512-4.468 9.98-9.98 9.98-.341 0-.341-.52 0-.52a9.46 9.46 0 0 0 9.461-9.46zm5.689-3.824c-.55.147-.773-.688-.223-.835l7.193-1.927c.55-.147.773.689.223.835zm.386 4.09c-.569 0-.569-.865 0-.865h15.055c.57 0 .57.866 0 .866zm-.609 3.975c-.55-.147-.326-.983.224-.835l7.193 1.927c.55.147.326.983-.224.836L21.41 2.944zM-8.38-5.933c.55.147.327.982-.223.835l-7.279-1.95c-.55-.147-.327-.983.223-.835zM19.722 6.678c-.49-.282-.061-1.03.43-.747l13.038 7.528c.492.282.062 1.03-.43.747zM-6.756-9.604c.492.282.062 1.03-.43.747l-13.038-7.528c-.49-.282-.061-1.03.43-.747zm23.938 19.42c-.403-.403.21-1.015.612-.612l5.266 5.265c.403.403-.21 1.015-.612.613zM-4.175-12.766c.403.403-.21 1.015-.612.612l-5.329-5.328c-.402-.403.21-1.015.613-.612zm18.052 24.97c-.282-.49.466-.92.748-.43l7.527 13.04c.283.49-.465.92-.747.429zM-.91-15.132c.282.491-.466.92-.747.43l-7.528-13.039c-.282-.491.466-.92.747-.43zm10.997 28.786c-.147-.55.688-.773.835-.223l1.927 7.193c.147.55-.688.773-.835.223zM2.88-16.58c.146.55-.689.773-.835.223l-1.95-7.279c-.147-.549.688-.772.834-.223zm17.271 7.723c-.49.282-.92-.465-.429-.747l13.038-7.528c.492-.282.921.466.43.747zm-2.397-3.296c-.403.402-1.015-.21-.612-.613l5.328-5.328c.403-.403 1.015.21.613.612zm-3.13-2.549c-.282.491-1.03.062-.747-.43l7.527-13.038c.283-.491 1.03-.062.748.43zm-3.703-1.655c-.147.55-.982.326-.835-.224l1.95-7.278c.147-.55.983-.327.836.223zm-4.005-.641c0 .57-.866.57-.866 0v-15.055c0-.569.866-.569.866 0z",
        heat:                   "M11.513-21.788c4.058.388 5.39-4.755 6.052-6.811 3.036-.163 2.543-5.78-.575-3.057-4.082 1.16-1.567 6.732-5.579 7.548-.7.607-.771 1.808.102 2.32zm10.403 9.404c2.998.76 6.025-1.581 7.07-3.403 3.9 1.301 5.305-4.26.502-2.905-3.698-.095-3.688 4.53-7.298 3.64-1.946.278-2.222 2.074-.274 2.668zM36.222-.52c-2.356-3.592-6.57 1.225-8.54-1.292-1.98-1.253-4.65 2.031-1.435 2.422 2.357 3.855 6.732-2.14 9.338 1.525 1.885.436 2.857-2.428.637-2.655zm-4.617 18.276c-.209-4.262-6.243-2.252-6.667-5.22-1.29-2.265-4.996-.886-2.705 1.54.891 3.963 6.4 1.569 6.948 5.057 1.29 1.573 4.416.966 2.424-1.377zM18.418 30.31c1.367-3.792-5.259-4.447-3.53-8.49-3.532-2.759-3.805 5.544-.28 6.131 2.686.835-.133 6.52 3.628 4.785.594-.666.54-1.668.182-2.426zM1.889 26.016c-3.128-3.244-5.618 4.785-2.878 6.688-.57 1.708-2.25 6.486 1.222 4.179 2.446-2.502.896-5.983.524-8.228.546-.783 1.307-1.598 1.132-2.639Zm-13.785-4.228c-4.123-.409-5.33 4.847-6.112 6.83-2.98-.048-2.3 5.887.372 2.867 4.477-.18 1.58-6.794 5.904-7.426.574-.642.744-1.818-.164-2.271zm-11.08-9.235c-3.757-2.04-5.08 4.19-7.902 3.098-2.594.066-3.152 3.928.043 3.177 3.837 1.252 4.606-4.721 7.943-3.41 2.153-.347 2.843-3.247-.084-2.865zM-30.532.963c1.707-.594 6.577 2.922 5.102-1.048-2.144-2.394-6.088-1.913-7.989-.787-3.05-3.067-6.527 1.266-1.659 2.267 1.437.88 3.418 1.023 4.546-.432zm-1.457-18.72c.21 4.263 6.244 2.253 6.667 5.221 3.08 3.392 4.497-1.283 1.591-3.214-2.27-1.87-5.385-.534-6.223-3.706-1.592-1.354-3.709-.32-2.035 1.7zM-18.8-30.308c-1.367 3.792 5.258 4.448 3.53 8.49 3.472 2.763 3.878-5.503.373-6.122-2.676-.818.016-6.432-3.699-4.748-.593.647-.546 1.633-.204 2.38zm16.529 4.293c3.128 3.244 5.618-4.785 2.878-6.688.57-1.708 2.25-6.486-1.222-4.179-2.446 2.502-.897 5.983-.524 8.228-.546.783-1.308 1.598-1.132 2.639zM20.473 9.106c3.417-.172 7.58-2.832 3.017-5.465-3-1.87-2.584-6.15.354-7.85 3.581-1.96.864-4.868-2.242-4.755-3.752-.278-4.282-4.678-2.791-7.4 1.368-5.491-4.923-1.104-7.56-1.957-3.916-.585-2.154-10.57-6.834-6.41-1.579 2.674-5.758 4.717-7.934 1.52-1.42-2.402-5.102-4.064-5.176.108.217 3.506-3.271 6.184-6.496 4.473-2.694-1.743-5.657.11-3.788 3.11 2.463 4.517-2.077 7.36-6.11 7.701-3.318 3.002 4.893 4.918 3.265 8.813-.93 2.74-7.607 6.427-1.487 7.583 3.345-.041 6.166 3.206 4.493 6.424-1.743 2.697.11 5.658 3.11 3.789 4.517-2.462 7.35 2.085 7.698 6.113 3.003 3.316 4.916-4.895 8.81-3.266 2.751.91 6.423 7.652 7.583 1.526-.038-3.343 3.182-6.219 6.421-4.533 2.696 1.746 5.666-.116 3.77-3.11-.95-2.298-1.022-5.633 1.897-6.414zM15.52 13.97c1.987 4.565-4.36-.297-6.25 2.376-2.906.382-2.224 5.544-4.13 5.337-2.363-3.603-8.004-3.699-10.502-.201-1.963 1.212-1.27-4.768-4.045-5.028-1.947-1.972-5.646.141-6.973-.836 1.88-3.521-.137-8.158-4.02-9.155-4.513-.559 3.075-3.798 1.328-6.772 1.033-2.88-5.976-5.859-1.08-6.313 4.397-.906 4.983-6.356 3.917-9.588 3.551 1.552 8.246.333 9.475-3.689.332-5.178 3.581 2.41 6.53 1.002 3.015 1.337 6.167-6.06 6.646-1.084.907 4.399 6.355 4.985 9.585 3.918-1.552 3.552-.333 8.25 3.689 9.477 5.176.333-2.409 3.583-1.002 6.533-1.336 3.016 6.059 6.167 1.084 6.647-3.097.761-5.151 4.313-4.252 7.376zM-.191-15.61c-9.488-.35-17.535 9.53-15.324 18.766 1.64 8.72 11.54 14.692 19.994 11.781 8.32-2.483 13.336-12.545 9.89-20.617-2.273-5.822-8.265-10.06-14.56-9.93Zm0 28.617c-8.446.354-15.302-9.053-12.419-17.006 2.268-7.544 12.005-11.498 18.81-7.38 6.655 3.616 8.835 13.382 3.938 19.292-2.424 3.153-6.34 5.138-10.33 5.094Z",
        flood:                  "M-21.516-10.93h18.424a8.956 8.956 0 0 0 8.952-8.936 8.863 8.863 0 0 0-3.916-7.383 8.938 8.938 0 0 0-12.11-4.785 8.944 8.944 0 0 0-16.177 4.648 8.928 8.928 0 0 0-1.94 13.378 8.93 8.93 0 0 0 6.767 3.078zm-3.18-14.691c.453-.211.72-.688.667-1.183a6.6 6.6 0 0 1 6.607-6.574 6.778 6.778 0 0 1 5.373 2.75c.591.823 1.086 1.781 2.233 1.077A6.623 6.623 0 0 1-.54-27.049c.24.597.583 1.147 1.016 1.623.567.433 1.097.912 1.583 1.434a6.573 6.573 0 0 1-5.15 10.7h-18.424a6.563 6.563 0 0 1-3.179-12.329zm30.751-.877c.134.184.25.378.371.569.097.15.203.295.292.45.092-.055.178-.12.274-.172.425-.22.67-.678.619-1.153a6.615 6.615 0 0 1 10.736-5.132c.508.42.954.91 1.322 1.458.557.797 1.116 1.566 2.15.93a6.737 6.737 0 0 1 3.454-.973c1.086 0 2.155.267 3.114.776a6.728 6.728 0 0 1 2.982 3.261 2.59 2.59 0 0 0 1.002 1.257 6.575 6.575 0 0 1-3.823 11.935H10.124a6.587 6.587 0 0 1-3.425-.963 11.338 11.338 0 0 1-1.387 1.913 8.898 8.898 0 0 0 4.812 1.413H28.55h-.001a8.956 8.956 0 0 0 8.952-8.937 8.863 8.863 0 0 0-3.916-7.382 8.938 8.938 0 0 0-12.11-4.786A8.945 8.945 0 0 0 5.298-27.43c.089.098.165.206.25.307.173.206.349.41.506.626zM36.328 33.38c-3.287 0-4.836-1.008-6.63-2.174-1.838-1.196-3.922-2.552-7.9-2.552-3.977 0-6.061 1.356-7.9 2.552-1.793 1.166-3.342 2.174-6.629 2.174-3.287 0-4.836-1.008-6.63-2.174-1.838-1.196-3.923-2.552-7.9-2.552-3.978 0-6.062 1.356-7.9 2.552-1.795 1.166-3.344 2.174-6.632 2.174s-4.837-1.008-6.63-2.174c-1.842-1.197-3.925-2.552-7.904-2.552a1.181 1.181 0 0 0 0 2.363c3.288 0 4.838 1.007 6.631 2.174 1.84 1.196 3.923 2.552 7.902 2.552 3.978 0 6.062-1.356 7.901-2.552 1.794-1.167 3.343-2.174 6.63-2.174 3.289 0 4.837 1.007 6.631 2.174 1.839 1.196 3.923 2.552 7.9 2.552 3.978 0 6.062-1.356 7.9-2.552 1.794-1.167 3.343-2.174 6.63-2.174s4.835 1.007 6.629 2.174c1.84 1.196 3.923 2.552 7.901 2.552a1.181 1.181 0 0 0 0-2.363zm-53.32-2.286v-2.44a5.377 5.377 0 0 0-5.273-5.317 5.3 5.3 0 0 0-5.274 5.317v1.753l2.344.152v-1.905a2.93 2.93 0 1 1 5.86 0v2.287zm26.069-4.101a1.172 1.172 0 0 0-1.427.851l-.582 2.29c-.075.298-.032.615.121.882l.08.001a9.52 9.52 0 0 0 2.023-.192c.018-.034.033-.07.047-.105l.582-2.289a1.182 1.182 0 0 0-.844-1.438zm-10.833.244v-6.264a1.176 1.176 0 0 0-1.172-1.181h-9.375a1.177 1.177 0 0 0-1.172 1.181v6.558c.755-.34 1.54-.608 2.344-.804v-4.572h7.03v4.418c.8.15 1.585.373 2.345.663zm-33.91-7.652 3.44-2.373v9.576c.806.21 1.591.495 2.344.85V15.596l15.82-10.914 15.82 10.914V29.12l.15.098c.691.483 1.425.9 2.193 1.247V17.212l3.44 2.373a1.178 1.178 0 0 0 1.323-1.95L4.1 14.35V5.613a1.177 1.177 0 0 0-1.172-1.182h-5.86a1.177 1.177 0 0 0-1.171 1.182V8.69l-9.3-6.415a1.163 1.163 0 0 0-1.322 0l-22.265 15.36a1.187 1.187 0 0 0-.306 1.642 1.167 1.167 0 0 0 1.628.308zm33.91-12.79h3.515v5.938l-3.516-2.425zm-19.63-7.47a1.171 1.171 0 0 0-1.427.851l-1.172 4.612c-.079.312-.028.643.142.916l2.48-1.71.82-3.23a1.182 1.182 0 0 0-.843-1.439zm9.375 0a1.165 1.165 0 0 0-1.257.483c.426.096.83.272 1.191.518l.868.599.042-.162a1.182 1.182 0 0 0-.844-1.438zm9.375 0a1.171 1.171 0 0 0-1.427.851l-.602 2.367a3.454 3.454 0 0 1 1.736-.474h.804l.332-1.306a1.182 1.182 0 0 0-.843-1.438zm9.374 0a1.172 1.172 0 0 0-1.426.851l-.606 2.383A3.543 3.543 0 0 1 6.43 5.294L7.582.762a1.182 1.182 0 0 0-.844-1.438zm4.356 24.494 1.172-4.612a1.185 1.185 0 0 0-.633-1.36c.212.955.021 1.955-.528 2.765a3.495 3.495 0 0 1-1.975 1.412l-.307 1.208a1.172 1.172 0 1 0 2.27.587zM25.16 5.372 26.332.76v.001a1.17 1.17 0 0 0-.84-1.437 1.174 1.174 0 0 0-1.43.85L22.89 4.786a1.172 1.172 0 1 0 2.27.586zm2.345-9.222 1.172-4.612c.01-.037.011-.074.017-.112-.049 0-.096.008-.145.008h-2.264l-1.05 4.129A1.176 1.176 0 0 0 26.075-3a1.173 1.173 0 0 0 1.43-.85zm-8.463 28.52a1.185 1.185 0 0 0 1.426-.852l1.173-4.611a1.174 1.174 0 0 0-.84-1.437 1.173 1.173 0 0 0-1.43.85l-1.173 4.611c-.162.63.215 1.273.844 1.438zm3.772-10.074 1.172-4.612a1.173 1.173 0 1 0-2.27-.586l-1.173 4.611a1.17 1.17 0 0 0 .84 1.437 1.172 1.172 0 0 0 1.43-.85zM18.13-3.85l1.173-4.612c.009-.035.01-.07.015-.104H16.91l-1.05 4.13v-.001A1.176 1.176 0 0 0 16.7-3a1.173 1.173 0 0 0 1.43-.85zm-2.345 9.222L16.958.76v.001a1.17 1.17 0 0 0-.84-1.437 1.174 1.174 0 0 0-1.43.85l-1.173 4.612a1.172 1.172 0 1 0 2.27.586zm-2.346 9.224 1.172-4.612a1.173 1.173 0 1 0-2.27-.586l-1.173 4.611a1.17 1.17 0 0 0 .84 1.437 1.172 1.172 0 0 0 1.43-.85zM8.755-3.85l1.173-4.612c.009-.037.01-.075.017-.113a11.253 11.253 0 0 1-2.336-.283l-1.124 4.42A1.176 1.176 0 0 0 7.325-3a1.173 1.173 0 0 0 1.43-.85zm-18.75 0 1.173-4.612c.009-.035.01-.07.016-.104h-2.409l-1.05 4.13v-.001A1.176 1.176 0 0 0-11.425-3a1.173 1.173 0 0 0 1.43-.85zm9.376 0L.553-8.462c.06-.233.046-.479-.038-.705-.758.258-1.54.434-2.336.525L-2.89-4.437A1.176 1.176 0 0 0-2.05-3a1.173 1.173 0 0 0 1.43-.85zm-18.75 0 1.172-4.612c.01-.035.01-.07.016-.104h-2.409l-1.05 4.13v-.001A1.176 1.176 0 0 0-20.8-3a1.173 1.173 0 0 0 1.43-.85z",
        "flood-and-storm":      "M-21.516-10.93h18.424a8.956 8.956 0 0 0 8.952-8.936 8.863 8.863 0 0 0-3.916-7.383 8.938 8.938 0 0 0-12.11-4.785 8.944 8.944 0 0 0-16.177 4.648 8.928 8.928 0 0 0-1.94 13.378 8.93 8.93 0 0 0 6.767 3.078zm-3.18-14.691c.453-.211.72-.688.667-1.183a6.6 6.6 0 0 1 6.607-6.574 6.778 6.778 0 0 1 5.373 2.75c.591.823 1.086 1.781 2.233 1.077A6.623 6.623 0 0 1-.54-27.049c.24.597.583 1.147 1.016 1.623.567.433 1.097.912 1.583 1.434a6.573 6.573 0 0 1-5.15 10.7h-18.424a6.563 6.563 0 0 1-3.179-12.329zm30.751-.877c.134.184.25.378.371.569.097.15.203.295.292.45.092-.055.178-.12.274-.172.425-.22.67-.678.619-1.153a6.615 6.615 0 0 1 10.736-5.132c.508.42.954.91 1.322 1.458.557.797 1.116 1.566 2.15.93a6.737 6.737 0 0 1 3.454-.973c1.086 0 2.155.267 3.114.776a6.728 6.728 0 0 1 2.982 3.261 2.59 2.59 0 0 0 1.002 1.257 6.575 6.575 0 0 1-3.823 11.935H10.124a6.587 6.587 0 0 1-3.425-.963 11.338 11.338 0 0 1-1.387 1.913 8.898 8.898 0 0 0 4.812 1.413H28.55h-.001a8.956 8.956 0 0 0 8.952-8.937 8.863 8.863 0 0 0-3.916-7.382 8.938 8.938 0 0 0-12.11-4.786A8.945 8.945 0 0 0 5.298-27.43c.089.098.165.206.25.307.173.206.349.41.506.626zM36.328 33.38c-3.287 0-4.836-1.008-6.63-2.174-1.838-1.196-3.922-2.552-7.9-2.552-3.977 0-6.061 1.356-7.9 2.552-1.793 1.166-3.342 2.174-6.629 2.174-3.287 0-4.836-1.008-6.63-2.174-1.838-1.196-3.923-2.552-7.9-2.552-3.978 0-6.062 1.356-7.9 2.552-1.795 1.166-3.344 2.174-6.632 2.174s-4.837-1.008-6.63-2.174c-1.842-1.197-3.925-2.552-7.904-2.552a1.181 1.181 0 0 0 0 2.363c3.288 0 4.838 1.007 6.631 2.174 1.84 1.196 3.923 2.552 7.902 2.552 3.978 0 6.062-1.356 7.901-2.552 1.794-1.167 3.343-2.174 6.63-2.174 3.289 0 4.837 1.007 6.631 2.174 1.839 1.196 3.923 2.552 7.9 2.552 3.978 0 6.062-1.356 7.9-2.552 1.794-1.167 3.343-2.174 6.63-2.174s4.835 1.007 6.629 2.174c1.84 1.196 3.923 2.552 7.901 2.552a1.181 1.181 0 0 0 0-2.363zm-53.32-2.286v-2.44a5.377 5.377 0 0 0-5.273-5.317 5.3 5.3 0 0 0-5.274 5.317v1.753l2.344.152v-1.905a2.93 2.93 0 1 1 5.86 0v2.287zm26.069-4.101a1.172 1.172 0 0 0-1.427.851l-.582 2.29c-.075.298-.032.615.121.882l.08.001a9.52 9.52 0 0 0 2.023-.192c.018-.034.033-.07.047-.105l.582-2.289a1.182 1.182 0 0 0-.844-1.438zm-10.833.244v-6.264a1.176 1.176 0 0 0-1.172-1.181h-9.375a1.177 1.177 0 0 0-1.172 1.181v6.558c.755-.34 1.54-.608 2.344-.804v-4.572h7.03v4.418c.8.15 1.585.373 2.345.663zm-33.91-7.652 3.44-2.373v9.576c.806.21 1.591.495 2.344.85V15.596l15.82-10.914 15.82 10.914V29.12l.15.098c.691.483 1.425.9 2.193 1.247V17.212l3.44 2.373a1.178 1.178 0 0 0 1.323-1.95L4.1 14.35V5.613a1.177 1.177 0 0 0-1.172-1.182h-5.86a1.177 1.177 0 0 0-1.171 1.182V8.69l-9.3-6.415a1.163 1.163 0 0 0-1.322 0l-22.265 15.36a1.187 1.187 0 0 0-.306 1.642 1.167 1.167 0 0 0 1.628.308zm33.91-12.79h3.515v5.938l-3.516-2.425zm-19.63-7.47a1.171 1.171 0 0 0-1.427.851l-1.172 4.612c-.079.312-.028.643.142.916l2.48-1.71.82-3.23a1.182 1.182 0 0 0-.843-1.439zm9.375 0a1.165 1.165 0 0 0-1.257.483c.426.096.83.272 1.191.518l.868.599.042-.162a1.182 1.182 0 0 0-.844-1.438zm9.375 0a1.171 1.171 0 0 0-1.427.851l-.602 2.367a3.454 3.454 0 0 1 1.736-.474h.804l.332-1.306a1.182 1.182 0 0 0-.843-1.438zm9.374 0a1.172 1.172 0 0 0-1.426.851l-.606 2.383A3.543 3.543 0 0 1 6.43 5.294L7.582.762a1.182 1.182 0 0 0-.844-1.438zm4.356 24.494 1.172-4.612a1.185 1.185 0 0 0-.633-1.36c.212.955.021 1.955-.528 2.765a3.495 3.495 0 0 1-1.975 1.412l-.307 1.208a1.172 1.172 0 1 0 2.27.587zM25.16 5.372 26.332.76v.001a1.17 1.17 0 0 0-.84-1.437 1.174 1.174 0 0 0-1.43.85L22.89 4.786a1.172 1.172 0 1 0 2.27.586zm2.345-9.222 1.172-4.612c.01-.037.011-.074.017-.112-.049 0-.096.008-.145.008h-2.264l-1.05 4.129A1.176 1.176 0 0 0 26.075-3a1.173 1.173 0 0 0 1.43-.85zm-8.463 28.52a1.185 1.185 0 0 0 1.426-.852l1.173-4.611a1.174 1.174 0 0 0-.84-1.437 1.173 1.173 0 0 0-1.43.85l-1.173 4.611c-.162.63.215 1.273.844 1.438zm3.772-10.074 1.172-4.612a1.173 1.173 0 1 0-2.27-.586l-1.173 4.611a1.17 1.17 0 0 0 .84 1.437 1.172 1.172 0 0 0 1.43-.85zM18.13-3.85l1.173-4.612c.009-.035.01-.07.015-.104H16.91l-1.05 4.13v-.001A1.176 1.176 0 0 0 16.7-3a1.173 1.173 0 0 0 1.43-.85zm-2.345 9.222L16.958.76v.001a1.17 1.17 0 0 0-.84-1.437 1.174 1.174 0 0 0-1.43.85l-1.173 4.612a1.172 1.172 0 1 0 2.27.586zm-2.346 9.224 1.172-4.612a1.173 1.173 0 1 0-2.27-.586l-1.173 4.611a1.17 1.17 0 0 0 .84 1.437 1.172 1.172 0 0 0 1.43-.85zM8.755-3.85l1.173-4.612c.009-.037.01-.075.017-.113a11.253 11.253 0 0 1-2.336-.283l-1.124 4.42A1.176 1.176 0 0 0 7.325-3a1.173 1.173 0 0 0 1.43-.85zm-18.75 0 1.173-4.612c.009-.035.01-.07.016-.104h-2.409l-1.05 4.13v-.001A1.176 1.176 0 0 0-11.425-3a1.173 1.173 0 0 0 1.43-.85zm9.376 0L.553-8.462c.06-.233.046-.479-.038-.705-.758.258-1.54.434-2.336.525L-2.89-4.437A1.176 1.176 0 0 0-2.05-3a1.173 1.173 0 0 0 1.43-.85zm-18.75 0 1.172-4.612c.01-.035.01-.07.016-.104h-2.409l-1.05 4.13v-.001A1.176 1.176 0 0 0-20.8-3a1.173 1.173 0 0 0 1.43-.85z",
        fire:                   "M-6.987 34.608h-5.292v-9.322l1.857-1.764c.811-.82-.341-2.032-1.2-1.264l-.657.622v-.507a.872.872 0 1 0-1.744 0v3.59l-1.069-.693c-.986-.598-1.896.805-.95 1.463l2.02 1.31v2.659h-7.94l3.346-5.193c.702-1.05-.103-2.526-1.366-2.505h-.959l4.473-6.135c.73-.96.1-2.428-1.092-2.567l4.771-6.649 4.772 6.65c-1.193.137-1.823 1.605-1.092 2.568l.853 1.17c.708.91 2.06-.074 1.41-1.027l-.727-.997c1.185-.139 1.818-1.595 1.097-2.557l-4.993-6.96c-.605-.89-2.035-.892-2.64 0l-4.992 6.958c-.72.96-.09 2.419 1.097 2.557l-4.484 6.151c-.788 1.04.008 2.606 1.313 2.582h.975l-3.345 5.193c-.702 1.05.103 2.526 1.366 2.504h8.156v2.163h-5.292a.872.872 0 1 0 0 1.743h12.327c1.15-.033 1.157-1.706 0-1.743zm14.652 1.148H2.373V33.37h8.039c1.307.027 2.18-1.474 1.509-2.597l-2.65-4.648c1.264.022 2.141-1.428 1.528-2.537L3.042 8.657c-.623-1.236-2.457-1.24-3.082 0l-7.756 14.931c-.613 1.103.267 2.578 1.535 2.527l-2.657 4.659c-.67 1.122.202 2.624 1.51 2.596H.63v2.386h-5.293a.872.872 0 1 0 0 1.744H7.666c1.148-.034 1.155-1.707 0-1.744zm-15.068-4.12 2.656-4.658c.67-1.114-.2-2.632-1.502-2.586L1.494 9.461l7.751 14.921c-1.301-.017-2.165 1.48-1.496 2.597l2.663 4.648H2.373v-5.193l1.857-1.763c.81-.82-.34-2.032-1.201-1.265l-.656.623v-.508a.872.872 0 1 0-1.744 0v3.59l-1.069-.693c-.985-.598-1.896.806-.949 1.463l2.018 1.31v2.437zm-19.233-17.118c-.018-.155-1.177-6.885 5.349-11.67-.349 1.712-.543 3.846.022 5.676A.872.872 0 0 0-19.6 8.01c-.586-1.897-.113-4.376.221-5.686.32-1.175-1.046-2.158-2.06-1.483-5.848 3.673-7.52 9.702-6.926 13.913A15.697 15.697 0 0 0-26.175 21a.872.872 0 0 0 1.488-.91 13.953 13.953 0 0 1-1.95-5.572zM21.488-8.453c-.76-1.025-2.434-.47-2.446.797C18.954-4.073 17.997-1.41 16.2.258a.405.405 0 0 1-.523.05.446.446 0 0 1-.203-.532C19.446-13.61 8.275-22.312 4.757-24.66.808-27.216.84-32.2 2.222-35.642c.48-1.212-.937-2.367-2.03-1.623-7.904 5.224-11.29 12.248-5.866 19.489 2.725 3.347 3.625 6.73 1.92 8.782-1.211 1.585-3.358 2.184-5.343 1.49-3.245-1.137-3.018-4.318-2.258-6.786l.001-.001a1.364 1.364 0 0 0-2.076-1.524c-6.9 4.486-7.345 13.657-1.472 19.047a.871.871 0 0 0 1.29-1.174c-.193-.212-.4-.428-.614-.645-2.315-2.337-3.406-5.614-2.917-8.767.388-2.5 1.678-4.642 3.837-6.382-.875 3.91.416 6.75 3.632 7.877 2.698.945 5.634.11 7.306-2.077 1.452-1.9 2.345-5.274-1.646-10.55C-8.906-24.489-6.352-30.52.218-35.166c-1.299 4.14-.606 9.236 3.57 11.954 3.268 2.18 13.647 10.248 10.014 22.49a2.192 2.192 0 0 0 .954 2.51 2.156 2.156 0 0 0 2.63-.254C19.348-.285 20.472-3 20.734-6.543c2.813 3.934 8.78 13.978 4.484 23.451a.872.872 0 1 0 1.588.72c4.202-8.532-.248-19.704-5.318-26.082zm1.336 32.63h.975c1.306.025 2.102-1.54 1.313-2.581l-4.483-6.151c1.186-.14 1.818-1.595 1.097-2.557L16.734 5.93c-.605-.892-2.036-.893-2.64 0L9.1 12.888c-.72.96-.09 2.419 1.098 2.557l-.566.777c-.65.95.702 1.938 1.41 1.026l.691-.95c.731-.96.101-2.429-1.091-2.567l4.771-6.649 4.772 6.65c-1.193.138-1.823 1.605-1.092 2.567l4.472 6.135h-.96c-1.262-.022-2.067 1.455-1.365 2.504l3.345 5.193h-8.662v-5.416l1.857-1.763c.811-.82-.34-2.032-1.2-1.264l-.656.623v-.508a.872.872 0 1 0-1.744 0v3.59l-1.07-.694c-.985-.598-1.896.805-.948 1.463l2.018 1.31v6.566H8.888a.872.872 0 1 0 0 1.744h12.328a.872.872 0 1 0 0-1.744h-5.292v-2.163h8.88c1.262.022 2.068-1.455 1.366-2.505z",
        drought:                "M21.444-36.695a.826.826 0 0 0-.697.822v4.783c-.006.422.376.81.797.81.42 0 .802-.388.796-.81v-4.783c.018-.46-.439-.88-.896-.822zm-10.591 4.434c-.277.311-.328.854-.011 1.147l3.385 3.388c.3.293.839.288 1.132-.013.294-.3.287-.84-.013-1.133l-3.384-3.363c-.383-.34-.811-.278-1.11-.026zm20.247.026-3.36 3.363c-.3.294-.305.834-.013 1.134.294.3.833.306 1.133.013l3.385-3.389c.309-.288.233-.79-.031-1.103-.358-.373-.791-.26-1.114-.019zm-51.866 4.31a.826.826 0 0 0-.696.823c-.014 9.453 0 18.863 0 28.303l-4.878-5.033-.25-8.023c-.01-.445-.455-.828-.895-.773a.826.826 0 0 0-.697.823l.174 6.178-5.55-6.079a.812.812 0 0 0-.722-.25c-.556.102-.827.902-.448 1.32l5.874 6.429-5.874.373c-.458-.047-.905.383-.876.844.029.461.527.831.976.726l7.168-.424 5.998 6.204v9.941c-5.133 1.445-10.261 3.254-15.53 5.307-.39.15-.61.643-.46 1.034.15.391.641.611 1.033.46 2.05-.798 4.063-1.55 6.072-2.267l-.622 7.375-5.326.549c-.453-.013-.864.433-.814.884.05.452.549.797.988.685l5.003-.523-.697 8.047c-.033.417.304.84.722.872.416.033.838-.33.87-.747l.722-8.347 8.263-.872 4.629 10.29c.167.39.684.578 1.07.398a.817.817 0 0 0 .373-1.071l-4.653-10.365 4.628-4.634 8.836 5.705c-.01.245.172.447.248.623l8.512 8.82c.293.3.845.318 1.145.024.3-.293.293-.846 0-1.146l-2.09-2.167 6.768-6.802 8.114 2.217 9.432 8.646c.296.33.881.332 1.18.008.299-.328.244-.91-.11-1.176l-9.233-8.475 1.12-7.076 11.423-2.018c.316 1.589.66 3.242.921 4.808.093.464.261.56.548.848.573.573 1.777 1.583 4.58 3.587.335.28.905.207 1.158-.15.254-.357.136-.92-.238-1.146-2.773-1.982-3.958-2.99-4.38-3.413-.577-2.389-1.048-4.98-1.468-7.075 1.686.463 3.397.965 5.15 1.52.406.153.914-.095 1.043-.509.129-.414-.149-.907-.569-1.011C25.49 11.567 15.515 9.913 6.262 9.717c-9.22-.194-17.705 1.067-26.131 3.314.007-7.67 0-15.302 0-22.971l7.266-4.36 6.82 2.291c.397.131.878-.113 1.008-.51.13-.399-.113-.88-.51-1.01l-5.576-1.868 7.342-4.659c.515-.384.495-.695.26-1.162-.287-.418-.687-.355-1.106-.183l-6.994 4.46 1.792-5.955c.17-.507-.316-1.108-.846-1.047a.816.816 0 0 0-.671.574l-2.29 7.673-6.495 3.912v-15.322c.017-.461-.439-.88-.897-.822zm42.309.798c-3.07 0-5.575 2.532-5.575 5.605 0 3.073 2.505 5.581 5.575 5.581 3.07 0 5.575-2.508 5.575-5.58 0-3.074-2.506-5.606-5.575-5.606zm0 1.62a3.972 3.972 0 0 1 3.982 3.986c0 2.21-1.773 3.961-3.982 3.961-2.209 0-3.982-1.75-3.982-3.961.058-2.45 1.574-3.896 3.982-3.987zM7.033-22.32c-.417.046-.755.467-.71.884.046.418.467.756.884.71h4.779c.42.008.807-.376.807-.797 0-.421-.386-.803-.807-.797H7.033Zm23.892 0c-.417.046-.755.467-.71.884.046.418.467.756.884.71h4.779c.42.008.807-.376.807-.797 0-.421-.387-.803-.807-.797h-4.953zm-3.131 6.93c-.315.301-.387.885-.055 1.192l3.36 3.389c.3.3.846.3 1.145 0 .3-.3.3-.846 0-1.146l-3.385-3.388c-.555-.379-.818-.253-1.066-.046zm-13.568.047-3.385 3.388c-.3.293-.306.833-.013 1.133.293.3.833.307 1.132.013l3.385-3.389c.318-.296.228-.82-.054-1.129-.382-.328-.782-.258-1.066-.016zm7.217 2.566a.826.826 0 0 0-.697.822v4.783c-.006.422.376.809.797.809.42 0 .802-.387.796-.809v-4.783c.018-.461-.439-.88-.896-.822zM4.768 11.267c.13.786.296 1.58.448 2.366l-10.428 10.49-1.096-4.934 2.364-7.524c3.14-.268 5.958-.398 8.711-.398zm1.617.024c3.82.091 7.763.434 11.897 1.072l-.922 5.804-10.527-4.51zm-12.07.573L-7.9 18.94a.805.805 0 0 0 0 .424l1.045 4.634c-4.88-3.002-9.022-5.726-13.364-8.969 4.608-1.718 10.246-2.641 14.534-3.164zm25.535.773a115.03 115.03 0 0 1 9.706 2.093l.274 1.42-10.851 1.893zm-42.26 2.765 5.775 4.335-4.58 4.585-8.138.872.672-7.773a146.54 146.54 0 0 1 6.271-2.019zm27.975.125 1.667 8.82-6.869 6.926-4.977-5.182c2.774-3.156 6.775-7.131 10.179-10.564zm1.618.025 9.93 4.26-.996 6.303L8.8 24.097z",
        agriculture:            "M11.47-20.813H7.61a1.138 1.138 0 0 1-1.136-1.135c0-.568.454-1.135 1.136-1.135h3.861c.568 0 1.136.567 1.136 1.135 0 .567-.454 1.135-1.136 1.135zm-14.084 8.4c-.227.908-1.022 1.362-1.93 1.135l-7.95-1.476.453 8.4c-.568-.227-1.476.228-2.385.34l-.113-9.08-6.133-1.136-1.477 7.833c1.817.681 3.294 1.816 4.43 3.178l-1.704.34a7.695 7.695 0 0 0-5.225-2.043l.228-1.021-3.294-.568c-.227 0-.454-.34-.34-.567 0-.227.34-.454.567-.34l3.294.567 1.477-7.72-.91-.113c-.794-.113-1.476-.908-1.362-1.702.114-.909.909-1.59 1.93-1.476l19.196 3.632c.908 0 1.476.909 1.249 1.817zm40.093-9.535c0 .568-.567 1.135-1.135 1.135h-3.862a1.138 1.138 0 0 1-1.135-1.135c0-.567.454-1.135 1.135-1.135h3.862c.568 0 1.135.454 1.135 1.135zm-7.041-6.243 3.407-1.93c.568-.34 1.25-.114 1.59.454.34.567.114 1.249-.454 1.59l-3.407 1.93c-.568.34-1.25.113-1.59-.455-.228-.568-.114-1.249.454-1.59zm-2.046 6.243c0 3.52-2.84 6.47-6.474 6.47-3.52 0-6.473-2.837-6.473-6.47 0-3.632 2.952-6.47 6.473-6.47 3.635 0 6.474 2.838 6.474 6.47zm-5.337 10.443v3.86c0 .681-.454 1.135-1.136 1.135-.567 0-1.135-.454-1.135-1.135v-3.86c0-.68.568-1.135 1.135-1.135.682 0 1.136.454 1.136 1.135zm-9.313-22.362c-.34-.568-.114-1.249.454-1.59.568-.34 1.25-.113 1.59.454l1.93 3.406c.341.568.115 1.249-.453 1.59-.568.34-1.25.113-1.59-.454zm7.042 1.362v-3.86c0-.681.567-1.135 1.135-1.135.682 0 1.136.454 1.136 1.135v3.86c0 .68-.454 1.135-1.136 1.135a1.137 1.137 0 0 1-1.135-1.135zm-3.068 20.092-1.93 3.406c-.341.567-1.022.68-1.59.453-.569-.34-.796-1.021-.455-1.589l1.93-3.406c.341-.567 1.023-.68 1.591-.454.568.341.795 1.022.454 1.59zM8.517-29.781c.34-.567 1.022-.681 1.59-.454l3.408 1.93c.568.34.682 1.021.454 1.59-.34.567-1.022.68-1.59.453l-3.407-1.93c-.568-.34-.796-1.021-.455-1.589zM-3.976-8.439l-.34 1.93c0 .227-.341.454-.569.34l-.681-.114-.454 2.498c.227.113.454.34.454.567l-.227 1.022-3.748-1.363c0-.113 0-.908.681-.794h.114l.568-2.839c.227-1.362 1.59-2.27 2.952-2.043l1.022.227c.114.001.228.229.228.569zm39.41-5.79c-.34.568-1.022.682-1.59.454l-3.408-1.93c-.567-.34-.681-1.02-.454-1.589.34-.567 1.022-.681 1.59-.454l3.408 1.93c.568.34.682 1.022.454 1.59zm-9.2-17.368 1.93-3.406c.341-.567 1.023-.68 1.591-.454.568.34.681 1.022.454 1.59l-1.93 3.406c-.341.567-1.023.68-1.59.454-.569-.341-.796-1.022-.455-1.59zm3.862 21.456c.34.567.113 1.248-.455 1.589-.567.34-1.249.114-1.59-.454l-1.93-3.406c-.341-.567-.114-1.248.453-1.59.568-.34 1.25-.113 1.59.455zm-16.582-5.677-3.407 1.93c-.568.34-1.25.114-1.59-.454-.341-.568-.114-1.249.453-1.59l3.408-1.93c.568-.34 1.25-.113 1.59.455.228.567.114 1.248-.454 1.59zm-26.01 12.373-6.132 1.362c1.703 2.044 2.271 4.427 1.817 6.811-.114.568-.227 1.022-.454 1.476l6.36 1.249c1.022-2.27 3.521-3.746 6.02-3.179 1.363.227 2.498.908 3.18 1.93 0-.114.568-3.065.568-2.838v-.228C-.683.641-3.295-.04-3.295-.04c-4.202-1.702-8.973-3.405-9.2-3.405zm6.475 14.19c.681.113 1.249-.34 1.362-.909a1.177 1.177 0 0 0-.908-1.362 1.178 1.178 0 0 0-1.363.908c-.227.568.227 1.249.909 1.363zm-16.696-7.152c.227-1.248-.568-2.383-1.704-2.61-1.136-.228-2.385.567-2.612 1.816-.227 1.135.568 2.383 1.703 2.61 1.25.114 2.386-.68 2.613-1.816zm58.832 11.011c.568.114 1.25-.227 1.363-.908.114-.568-.227-1.249-.908-1.362C22.6 9.495 10.673 10.97.68 16.988c-2.044-1.249-4.089-2.157-6.02-3.065 1.931-.113 3.635-1.59 3.976-3.632C-.91 7.907-2.5 5.523-4.885 5.069c-2.385-.454-4.77 1.135-5.225 3.519-.227 1.476.227 2.951 1.136 3.86-4.884-1.59-9.654-2.384-14.084-2.498a7.376 7.376 0 0 0 5.338-5.675c.795-3.86-1.817-7.72-5.792-8.4-3.862-.796-7.723 1.815-8.405 5.675-.681 3.86 1.817 7.606 5.565 8.4-3.975.228-7.61 1.022-10.449 2.27-.568.228-.795.909-.568 1.476.227.568.909.795 1.477.568 7.95-3.406 21.58-3.406 34.414 3.86a46.81 46.81 0 0 0-5.339 4.313c-8.518-6.357-19.08-6.017-29.53-5.79-.681 0-1.136.568-1.136 1.136 0 .68.568 1.135 1.136 1.135 9.768-.114 19.876-.568 27.827 5.108a66.753 66.753 0 0 0-3.748 4.087c-7.496-6.13-15.9-5.903-23.965-6.925-.568-.113-1.25.34-1.25 1.022-.113.567.34 1.249 1.022 1.249 8.291 1.135 15.9.794 22.83 6.47a46.2 46.2 0 0 0-3.749 5.45c-.34.567-.227 1.248.34 1.589.569.34 1.25.227 1.591-.34C2.724 7.792 27.825 12.901 36.115 14.603ZM-7.952 9.156c.227-1.135 1.363-1.93 2.498-1.703 1.136.227 1.931 1.362 1.704 2.497-.228 1.135-1.363 1.93-2.499 1.703-1.135-.227-1.93-1.362-1.703-2.497zm-19.99-6.585c.34-1.702 2.045-2.838 3.748-2.497 1.704.34 2.84 2.043 2.499 3.746-.34 1.703-2.044 2.838-3.748 2.497-1.704-.34-2.84-2.043-2.499-3.746zM36.23 21.53c-10.79 1.476-22.035 3.633-31.12 14.077-.455.454-.34 1.135.113 1.59.454.453 1.136.34 1.59-.114 8.518-9.876 19.309-12.033 29.644-13.395.568-.114 1.022-.681 1.022-1.249-.113-.567-.681-1.021-1.249-.908zm.113-4.54c-13.175-.227-32.028 1.476-43.386 18.73-.34.568-.228 1.249.34 1.59.568.34 1.25.227 1.59-.34 10.79-16.348 28.85-17.937 41.456-17.71.682 0 1.136-.455 1.136-1.136 0-.681-.455-1.135-1.136-1.135z",
        biodiversity:           "M8.049 23.48h2.142v1.57h-47.055v-1.57h11.165v-1.679h1.57v1.68h13.872v-6.356c.063-.023.117-.047.172-.078.44.368.91.706 1.397.996v5.438H6.479v-2.276h-9.431l.306-1.546v-.007C4.8 19.54 10.036 12.334 8.041 5.324a11.4 11.4 0 0 0 2.401-7.61c-.23-4.013-2.572-7.81-6.653-9.691v-.008L7.28-17.54l8.804 13.958H11.21l5.469 13.41h-3.586l4.645 11.377H8.05ZM.449-30.07c-.348-3.538-3.336-6.315-6.969-6.315a7 7 0 0 0-6.927 5.987c-2.709-1.119-5.597.858-5.597 3.706H6.658c0-3.222-3.582-5.087-6.21-3.378zm25.904 52.965c-.282.209-1.139 2.41-5.269 2.41-2.02 0-3.849-.648-4.657-1.65l-1.222.983c1.11 1.38 3.364 2.236 5.88 2.236 2.116 0 4.046-.607 5.267-1.62 1.221 1.013 3.152 1.62 5.269 1.62 2.515 0 4.768-.856 5.879-2.236l-1.222-.984c-.808 1.003-2.636 1.652-4.657 1.652-4.156 0-4.945-2.17-5.269-2.411zM31.62 35.01c-4.155 0-4.945-2.17-5.268-2.41-.28.208-1.138 2.41-5.268 2.41-4.156 0-4.945-2.17-5.268-2.41-.276.206-1.15 2.41-5.268 2.41-4.156 0-4.946-2.17-5.269-2.41-.276.206-1.15 2.41-5.268 2.41-4.156 0-4.945-2.17-5.268-2.41-.276.206-1.15 2.41-5.268 2.41-4.156 0-4.944-2.17-5.268-2.41-.277.206-1.15 2.41-5.269 2.41-4.155 0-4.945-2.17-5.268-2.41-.276.206-1.15 2.41-5.268 2.41-2.022 0-3.85-.648-4.657-1.65l-1.224.983c1.11 1.38 3.364 2.236 5.88 2.236 2.116 0 4.047-.607 5.268-1.62 1.22 1.013 3.151 1.62 5.268 1.62s4.048-.607 5.268-1.62c1.22 1.013 3.151 1.62 5.268 1.62s4.048-.607 5.268-1.62c1.221 1.013 3.152 1.62 5.269 1.62 2.116 0 4.047-.607 5.268-1.62 1.22 1.013 3.152 1.62 5.268 1.62 2.117 0 4.048-.607 5.268-1.62 1.221 1.013 3.152 1.62 5.268 1.62 2.117 0 4.048-.607 5.268-1.62 1.221 1.013 3.152 1.62 5.269 1.62 2.516 0 4.769-.856 5.879-2.236l-1.222-.983c-.806 1.002-2.634 1.65-4.656 1.65zm0-4.81c-4.155 0-4.944-2.17-5.268-2.411-.281.209-1.138 2.41-5.268 2.41-4.156 0-4.944-2.17-5.268-2.41-.282.209-1.139 2.41-5.268 2.41-4.156 0-4.945-2.17-5.269-2.41C5 27.999 4.142 30.2.012 30.2c-4.156 0-4.944-2.17-5.268-2.41-.282.209-1.139 2.41-5.268 2.41-4.122 0-4.925-2.155-5.268-2.41-.282.209-1.139 2.41-5.269 2.41-4.155 0-4.944-2.17-5.268-2.41-.281.209-1.138 2.41-5.268 2.41-2.021 0-3.849-.648-4.657-1.65l-1.224.983c1.11 1.38 3.364 2.237 5.88 2.237 2.116 0 4.047-.607 5.268-1.62 1.22 1.013 3.151 1.62 5.268 1.62s4.047-.607 5.268-1.62c1.22 1.013 3.151 1.62 5.268 1.62s4.047-.607 5.268-1.62c1.221 1.013 3.152 1.62 5.269 1.62 2.116 0 4.047-.607 5.268-1.62 1.22 1.013 3.152 1.62 5.268 1.62 2.117 0 4.047-.607 5.268-1.62 1.221 1.013 3.152 1.62 5.268 1.62 2.117 0 4.047-.607 5.268-1.62 1.221 1.013 3.152 1.62 5.269 1.62 2.515 0 4.768-.857 5.879-2.237l-1.222-.983c-.807 1.002-2.635 1.65-4.656 1.65zM20.445-17.367l-1.365-.785-2.417 4.198 1.358.784zm-9.03-7.243h4.85v1.57h-4.85zm11.063 7.783h1.569v4.85h-1.57zm7.792-7.783h4.85v1.57h-4.85Zm3.652-4.467-4.198 2.424-.783-1.357 4.197-2.424zm-.004 10.493L29.72-21.01l-.785 1.366 4.198 2.416zm-5.404-15.9 1.358.784-2.423 4.191-1.358-.784zm0 21.317-2.424-4.197 1.357-.784 2.425 4.198zm-5.251-15.24a4.586 4.586 0 0 0-4.575 4.581 4.585 4.585 0 0 0 4.575 4.575 4.586 4.586 0 0 0 4.582-4.575 4.588 4.588 0 0 0-4.582-4.582zm-.785-7.274h1.57v4.85h-1.57zm-9.088 5.247 4.198 2.424-.784 1.357-4.198-2.424zm-.782 11.85.784 1.357 4.198-2.416-.784-1.366zm7.837-11.707-2.424-4.19-1.357.785 2.416 4.19zM6.283 4.97c.4 1.075.596 2.213.596 3.374a9.693 9.693 0 0 1-6.826 9.298 9.719 9.719 0 0 1-9.918-2.527 9.14 9.14 0 0 1-2.4 1.107l-3.437-8.427h4.41l-6.725-16.493h6.434l-4.394-6.967.243-.063A9.712 9.712 0 0 1-9.136-18.3a9.692 9.692 0 0 1 9.338 6.96 9.763 9.763 0 0 1 4.896 1.969A9.739 9.739 0 0 1 8.872-2.2a9.737 9.737 0 0 1-2.589 7.17zM10.6 15.312H9.524v-1.57h1.075Zm-22.927 4.92H-37.5l5.712-14.005h-4.417l6.732-16.493h-5.932l10.483-16.658 10.498 16.658h-5.931l6.724 16.493h-4.41zm-17.128-47.94c.34-.827.494-2.375 2.248-1.935l.383-1.522c-1.616-.405-2.669.262-3.249 1.002-1.762-.798-3.647.444-3.738.505l.874 1.303c2.208-1.454 3.079.57 3.482.648zM-.02-18.248c.417-.087 1.269-2.14 3.504-.676l.871-1.306c-.09-.06-1.978-1.301-3.738-.503-.58-.74-1.635-1.41-3.249-1.002l.383 1.522c1.776-.447 1.894 1.118 2.23 1.965zM20.113-1.34l.383 1.521c2.627-.66 3.054 1.49 3.447 2.555.397-.058 1.777-2.834 5.064-.655L29.88.778c-.128-.086-2.861-1.882-5.287-.574-.724-1.059-2.168-2.125-4.48-1.543Z",
        "health-and-wellbeing": "m36.328 3.59-3.955.001c-.456 0-.871.265-1.063.68l-4.375 9.459-4.711-9.84a1.172 1.172 0 0 0-1.859-.348l-4.422 4.15H8.616a4.103 4.103 0 0 0-6.314-2.166 4.102 4.102 0 1 0 6.314 4.51h7.79c.298 0 .585-.114.802-.318L20.8 6.346l5.095 10.64v.001c.195.407.606.666 1.057.666h.008a1.171 1.171 0 0 0 1.056-.68l5.106-11.039h3.205a1.172 1.172 0 0 0 0-2.343zm-31.64 7.032a1.758 1.758 0 1 1 0-3.516 1.758 1.758 0 0 1 0 3.516zM-26.902-4.08l2.56-5.35a3.52 3.52 0 0 1 5.579-1.043l3.75 3.516h4.929a6.445 6.445 0 1 1 0 7.031h-6.324c-.894 0-1.755-.34-2.408-.95l-1.254-1.183-3.715 7.752c-.147.311-.34.597-.574.85a54.465 54.465 0 0 0 10.77 11.912 61.45 61.45 0 0 0 13.09 8.46c.315.15.68.15.995 0A62.42 62.42 0 0 0 20.66 11.479l-.592-1.23-1.254 1.182a3.531 3.531 0 0 1-2.408.95H10.09a6.445 6.445 0 1 1 0-7.031h4.921l3.75-3.516a3.52 3.52 0 0 1 5.579 1.043l.99 2.074a29.948 29.948 0 0 0 3.504-8.754c1.283-6.1-.147-11.73-4.125-16.283-8.778-10.037-19.02-6.832-24.709-3.72-5.69-3.112-15.932-6.317-24.708 3.72a17.907 17.907 0 0 0-4.548 10.94c.026.042.05.085.071.128zm-9.427-2.292h3.205l5.106 11.04c.19.411.602.676 1.056.679h.008c.45 0 .862-.26 1.057-.666l5.095-10.641 3.593 3.372c.217.204.504.318.802.318h7.79A4.104 4.104 0 0 0-2.303-.103a4.102 4.102 0 1 0-6.315-4.51h-7.326l-4.423-4.15a1.172 1.172 0 0 0-1.858.348l-4.71 9.84-4.376-9.46a1.172 1.172 0 0 0-1.064-.679h-3.954a1.172 1.172 0 0 0 0 2.343zm31.64 1.172a1.757 1.757 0 1 1 .001 3.514 1.757 1.757 0 0 1 0-3.514z",
        water:                  "M.046-37.5a1.784 1.784 0 0 0-1.58.871c-5.26 8.778-10.521 14.638-14.6 19.94C-20.214-11.384-23.19-6.456-23.19 0c0 12.798 10.4 23.213 23.184 23.213 12.785 0 23.186-10.414 23.186-23.213 0-6.456-2.978-11.385-7.057-16.687-4.08-5.303-9.333-11.163-14.594-19.94A1.785 1.785 0 0 0 .047-37.5zm12.434 0a3.573 3.573 0 0 0 0 7.142 3.57 3.57 0 0 0 0-7.142zm10.701 5.357a7.132 7.132 0 0 0-5.044 2.092 7.148 7.148 0 0 0 0 10.1 7.13 7.13 0 0 0 10.089 0 7.144 7.144 0 0 0 0-10.1 7.13 7.13 0 0 0-5.045-2.092zM-17.212-1.812A1.781 1.781 0 0 1-15.402 0c0 8.6 6.807 15.417 15.396 15.417.97.021 1.744.814 1.744 1.785s-.775 1.765-1.744 1.786c-10.494 0-18.966-8.482-18.966-18.987a1.785 1.785 0 0 1 1.76-1.811zm-11.33 26.81c-1.658 0-3.46.503-5.002.97-1.542.466-2.766.934-2.766.934a1.786 1.786 0 1 0 1.271 3.336s1.116-.424 2.528-.85c1.412-.428 3.176-.819 3.969-.819.793 0 1.766.326 2.937.773 1.17.446 2.54 1.014 4.199 1.014 1.658 0 3.029-.568 4.2-1.014 1.17-.447 2.143-.773 2.936-.773.788 0 1.756.328 2.93.778 1.172.45 2.552 1.023 4.22 1.01 1.592-.014 2.887-.575 3.981-1.015 1.094-.44 1.988-.762 2.7-.773.871-.013 1.912.325 3.16.778 1.246.453 2.697 1.022 4.423 1.01 1.65-.012 3.018-.572 4.188-1.015 1.168-.444 2.137-.773 2.934-.773.793 0 1.76.326 2.93.773 1.17.446 2.54 1.014 4.199 1.014 1.658 0 3.037-.568 4.208-1.014 1.17-.447 2.135-.773 2.928-.773.793 0 2.56.391 3.97.818 1.413.427 2.528.851 2.528.851a1.78 1.78 0 0 0 2.354-1.012 1.786 1.786 0 0 0-1.084-2.324s-1.222-.468-2.765-.934c-1.542-.466-3.345-.97-5.003-.97s-3.029.562-4.2 1.008c-1.17.447-2.143.778-2.936.778-.793 0-1.757-.331-2.928-.778-1.17-.446-2.543-1.008-4.201-1.008-1.653 0-3.026.557-4.2 1.002-1.171.444-2.147.778-2.948.784-.876.007-1.929-.342-3.18-.797-1.252-.454-2.706-1.015-4.436-.989-1.59.025-2.88.59-3.97 1.03-1.09.438-1.978.75-2.686.756-.783.007-1.742-.322-2.91-.77-1.169-.45-2.544-1.016-4.206-1.016-1.658 0-3.036.562-4.206 1.008-1.171.447-2.137.778-2.93.778-.793 0-1.759-.331-2.93-.778-1.17-.446-2.548-1.008-4.206-1.008zm0 7.144c-1.658 0-3.46.504-5.002.97a48.29 48.29 0 0 0-2.766.927 1.79 1.79 0 0 0 1.271 3.343s1.116-.431 2.528-.857c1.412-.427 3.176-.817 3.969-.817.793 0 1.766.332 2.937.778 1.17.446 2.54 1.008 4.199 1.008 1.658 0 3.029-.562 4.2-1.008 1.17-.446 2.143-.778 2.936-.778.788 0 1.756.333 2.93.783 1.172.45 2.552 1.016 4.22 1.003 1.592-.013 2.887-.575 3.981-1.015 1.094-.44 1.988-.76 2.7-.77.871-.014 1.912.324 3.16.777 1.246.453 2.697 1.02 4.423 1.008 1.65-.012 3.018-.571 4.188-1.015 1.168-.444 2.137-.77 2.934-.77.793 0 1.76.33 2.93.777 1.17.446 2.54 1.008 4.199 1.008 1.658 0 3.037-.562 4.208-1.008 1.17-.446 2.135-.778 2.928-.778.793 0 2.56.39 3.97.816 1.413.427 2.528.858 2.528.858a1.786 1.786 0 0 0 2.304-1.036A1.79 1.79 0 0 0 36.3 34.04s-1.222-.461-2.765-.927c-1.542-.466-3.345-.97-5.003-.97s-3.029.562-4.2 1.008c-1.17.447-2.143.778-2.936.778-.793 0-1.757-.331-2.928-.778-1.17-.446-2.543-1.008-4.201-1.008-1.653 0-3.026.556-4.2 1.001-1.171.445-2.147.78-2.948.785-.876.006-1.929-.342-3.18-.797-1.252-.454-2.706-1.016-4.436-.989-1.59.025-2.88.59-3.97 1.03-1.09.438-1.978.75-2.686.756-.783.006-1.742-.323-2.91-.77-1.169-.449-2.543-1.016-4.206-1.016-1.658 0-3.036.562-4.206 1.008-1.171.447-2.137.778-2.93.778-.793 0-1.759-.331-2.93-.778-1.17-.446-2.548-1.008-4.206-1.008z",            
        economy:                "M4.703 7.324a1.065 1.065 0 1 0-2.13 0v3.37a1.065 1.065 0 1 0 2.13 0zm-15.19-19.474a1.2 1.2 0 0 0-1.135 1.148v1.366C-11.622-3.772-6.782.981-.919.981H.447A1.049 1.049 0 0 0 1.51-.068v-1.366C1.51-7.297-3.258-12.15-9.12-12.15zm15.19.526a12.025 12.025 0 1 0-2.13 0V3.013a1.065 1.065 0 1 0 2.13 0zm-1.065-2.849a1.065 1.065 0 0 1-1.064-1.065v-.931a4.251 4.251 0 0 1-3.159-4.052 1.04 1.04 0 0 1 1.036-1.065 1.062 1.062 0 0 1 1.062 1.065 2.06 2.06 0 0 0 2.036 2.059l.022-.002a2.057 2.057 0 0 0 2.077-2.062 2.06 2.06 0 0 0-2.065-2.054 4.175 4.175 0 0 1-4.168-4.19 4.248 4.248 0 0 1 3.159-4.05v-.79a1.065 1.065 0 1 1 2.129 0v.79a4.19 4.19 0 0 1 3.091 4.05 1.09 1.09 0 0 1-1.093 1.065 1.062 1.062 0 0 1-1.066-1.064 2.057 2.057 0 1 0-2.05 2.06 4.195 4.195 0 0 1 1.118 8.24v.931c0 .588-.476 1.065-1.065 1.065zM17.63-12.15h-1.366C10.4-12.15 5.59-7.297 5.59-1.434v1.366c.02.593.512 1.06 1.105 1.05H8.06a10.651 10.651 0 0 0 10.66-10.617v-1.367c0-.588-.503-1.148-1.09-1.148zM-37.5 12.58l3.275 26.795h13.526l-8.188-26.795zm12.638 22.788a3.186 3.186 0 1 1-6.373-.001 3.186 3.186 0 0 1 6.373 0zm-.373-18.171 4.275 14.02 5.987-3.785a5.96 5.96 0 0 1 4.395-.62l13.203 2.432c3.138.56 6.372.111 9.24-1.283l21.91-15.043a4.24 4.24 0 0 0-5.034-.752l-10.881 5.87-.986.52c.008.142.012.285.012.43 0 .589-.476 1.065-1.064 1.065l-.048-.001-7.512-.34a36.177 36.177 0 0 0-6.572.303 1.067 1.067 0 0 1-.292-2.113 38.322 38.322 0 0 1 6.96-.326l6.285.275a5.509 5.509 0 0 0-5.368-4.382H.47a11.578 11.578 0 0 1-5.022-1.131l-.908-.421a13.535 13.535 0 0 0-14.054 1.35l-2.158 1.922a9.66 9.66 0 0 1-3.561 2.01zm42.093-1.04 8.585-4.631c-.947-.857-2.376-1.302-3.517-.73l-6.613 3.562v.001c.472.614.849 1.297 1.115 2.025zm-44.906 20.267a1.055 1.055 0 0 0 .747-1.803 1.056 1.056 0 1 0-.747 1.803zm41.097-25.887-.026.014-1.924 1.047a7.596 7.596 0 0 1 2.609 1.207l4.248-2.29a4.94 4.94 0 0 0-4.907.022Z",
        "healing-country":      "M37.5.15c-5.112-.14-.33 6.22-2.094 8.994-.672 4.433-1.764 8.828-3.186 13.07-3.562 7.53-11.68 11.268-19.313 13.313-4.458 1.666-9.48 1.802-13.95.12-7.369-1.572-14.992-3.93-20.313-9.575-3.998-3.92-7.94-7.928-11.652-12.111-3.84-4.997-5.294-11.597-4.143-17.766.648-8.805 4.993-16.788 9.287-24.303 5.29-7.438 15.216-9.689 23.849-8.541 5.874.435 11.827 1.483 16.929 4.605 8.279 5.157 17.402 10.411 21.976 19.44C36.977-8.689 37.184-4.183 37.5.148zm-68.695-8.837c-1.74 6.026-1.244 12.922 2.294 18.224-.564-3.675-2.385-7.219-2.266-11.103-.669-4.102-.322-8.344 1.614-12.068 1.055-1.814.385-4.375-.45-1.094-.72 1.929-1.234 3.968-1.192 6.04zM28.33-1.601c-.071-6.655-4.048-12.408-7.819-17.574-4.845-5.03-11.56-7.488-17.667-10.57-5.231-1.742-10.946-.154-15.827 1.95-3.593 1.965-7.061 4.57-9.34 7.992-3.683 6.682-4.022 14.689-2.678 22.044 2.494 9.582 10.635 16.331 18.938 20.982 4.115 2.264 7.777 5.892 12.773 5.914 4.41.378 9.436.282 12.685-3.208 3.293-2.426 4.444-6.586 4.447-10.509-.325-2.518 1.667-6.868-.216-8.23-1.781 6.473-8.275 9.557-12.555 14.143-4.52 3.214-10.34 1.48-15.292.46-9.503-2.691-15.69-11.563-18.885-20.444-1.485-3.77.298-7.523 1.38-11.08.927-4.374 2.666-9.01 6.751-11.361 5.928-4.014 13.26-6.087 20.4-5.758 5.167.277 8.013 4.88 11.04 8.398 4.39 5.27 8.855 10.644 11.865 16.85zM-8.602 14.905C-4.5 19.321 1.836 20.563 7.627 20.57c4.71-1.351 8.107-5.434 10.723-9.357 2.426-5.688-.17-11.783-1.607-17.399-1.13-3.704-2.686-7.508-6.1-9.664C6.24-19.377.302-20.494-5.149-19.212c-5.02.094-8.69 3.813-10.668 8.115-1.294 1.279-2.324 8.458.379 5.398.453-3.943 4.021-5.563 6.986-7.488 4.305-2.495 10.757-3.798 14.567.222a230.86 230.86 0 0 0 6.984 9.39C16.034.463 18.53 6.456 15.265 11.007c-2.833 4.008-8.166 5.576-12.842 4.507-3.674-.147-7.419.322-11.025-.609zM2.068-2.018C7.193-.06 4.95 8.578-.295 8.457c-5.771.813-8.241-5.603-12.395-7.49-1.944 2.751 3.726 5.07 5.664 6.818C-3.519 9.86.117 11.974 4.072 13.013c3.347.815 8.038-1.917 6.313-5.738C8.581 1.917 5.893-3.147 3.037-7.981c-3.106-3.087-9.07-4.548-12.228-.768-3.169 2.777-1.374 7.529 1.146 10.096 2.333 2.817 7.264 6.97 10.515 3.34C3.56 2.52 2.02.212 2.069-2.017Zm-19.507 24.01c5.662 7.502 15.284 10.09 24.096 11.697 5.188.107 9.927-2.446 14.583-4.392 2.431-.661 6.199-5.566 4.86-6.105-4.968 5.473-12.213 9.921-19.873 8.779-5.093.262-10.246-1.173-14.112-4.582-2.988-2.15-6.356-3.62-9.554-5.397Zm-9.67-42.851c5.178-3.53 9.791-7.963 15.537-10.607.235-2.801-5.344-.817-7.32-.669-4.35 1.696-6.15 6.495-7.971 10.43l-.133.42zM-13.856 5.4c-.984 4.164 3.366 6.82 6.826 7.66 1.679 1.072 6.33.265 2.665-1.387-3.398-1.7-6.415-4.06-9.49-6.273ZM2.652-23.11c-4.63-1.92-10.006-.689-14.085 1.964 1.064 2.186 5.058-1.494 7.35-.862 2.243-.38 4.512-.611 6.735-1.102zM29.33 12.238c2.182-1.154-.314-7.167.102-2.397l-.102 2.397z"
    };

    const mapIcons = {
        Local: 'm44.843 15.796-4.143-.86-.209-1.842-3.864-1.617-.537 1.316-3.23 2.464-4.687-.768-1.77-1.494-1.49.816-3.568-.433-.475-1.282-3.144 1.256-3.66.29-3.956 1.527-1.443 1.558-1.677.057-1.152 2.11-3.023.957-1.666-.81-.497 2.889-13.048-1.544-10.529-.745-.62-.966.738-3.633-1.878-.24.773-3.93 1.247.162 1.268-6.954-5.39-1.059-4.38.458-.649-.557L-50 .625l2.214-11.017 3.015-1 3.367.131 1.417-2.03 5.322 1.808 6.992.905 5.2-.113.914-5.085 1.033-1.134 7.87.843 1.67.94 1.26 2.61 5.419 2.558-.038 1.986 2.445 1.03 2.48.12 1.921-1.824 1.7-3.257-.235-2.93 1.317-7.096 6.253.73-.12.716 8.931.974-.683 3.768 12.856 1.629 1.026-5.764 10.667 1.248-1.465.848-.227 3.694-2.255 2.344-1.428 3.569-1.19.8-.31 2.233-1.428 2.022 3.883 2.186 7.084 2.908-.284 3.373L50 5.654l-.677 4.74-4.13-.488-.541 2.927z', 
        Regional: 'm-27.37 17.02-1.902.215-1.383-.79-1.649.134-.633.75-2.36.908 1.114 2.138-2.782-.003.003 2.08-5.86-.656 1.617 1.233-.503 1.018-2.582-.272-1.967.834-1.423-1.336-2.036-1.208-.131-17.36-.028-9.81L-50-22.707h14.936l-.009-6.953 13.86-.004v-.97l4.714.415 1.111-.79-.92-2.064.752-1.69 2.47-.673 3.168.337 3.688-.01.212 4.818 4.983-.016-.025 7.25-3.356.012.09 10.681 2.133-.674 1.423.197.316 1.236-.506 1.723.184 5.44 1.858.077.68 1.515 5.48.562 1.467-1.109 1.683.181.4-1.102 3.846-.084 1.377 2.963 2.407 1.242.753 1.796 1.51 1.146-1.201 2.26 5.713-.106.331 1.957 2.223 1.565 2.48.35.39 1.907 1.102 2.008 2.104.234.937 1.327-1.23.665-.169 3.312 2.214 1.221.774-1.09.234-2.154 3.232.521-.147.81 2.76.349.218-1.24 1.974.453-1.465 3.147 2.351 1.093.672.79-1.034.912-.075 1.264 2.517.01-.288 2.984 2.698.347-.918 1.23-.119 2.882-.79-.028-.658 3.712-1.418-.821-3.34.274-6.563-.662-.31.85-3.06-.072-1.295-1.012-.093-2.013-1.518-1.384-.075-1.292-3.394-1.44-1.333.153-.562 2.164-4.424-.118-1.161.668-2.407.006-.9 2.042-1.261.346-2.698-.687-2.438 2.698-1.705-.387-.67-1.361-3.673 1.845-3.275-.53-1.564.611-2.363-.709-.734-1.23.796-3.288-.88-.552-6.195-.784.637-2.791 2.438-2.585 1.043-3.107-2.488-.936-5.102-3.129-.668-1.008-2.82.018-.976 3.104-2.326-.028-2.339-.912-.056-1.583z', 
        State: 'm-3.75 20.431-1.185.939-1.536.021-.396-1.203 1.463-.803 1.506-1.673-1.645-3.16-1.729.159-1.806 1.403-2.814.801.89 1.006 1.699-.634-.09 1.6-2.16.334-1.937 1.263-2.412.891-2.213 2.409-1.726.496-1.413 1.312-2.192-1.13-1.371.139-1.688-1.281-2.476-.508-3.266-2.033-2.116-.805-2.515.466-2.933-1.395-1.547-.14-3.716 1.287-1.99-2.203-2.907-1.272.09-6.59L-50-8.887l.006-19.618.662.878 2.026.022 1.193.7 3 .822 1.371-1.14 4.085.391 1.592.552 1.462 2.392.63 1.901 1.298 2.125 1.01.286.976-1.901 1.124-.061 1.86.962 2.513.243 1.65.827-.078 3.375.596 1.073 1.955.161-.096 1.446 2.095.562 1.195 1.022 2.732 1.23 1.77 1.782.938.174.86 1.683 2.12 1.758 2.11.515 1.854-2.66 1.544-.704 2.676.517 1.296-.642 2.24 1.295 2.537.295 3.143.994 1.441-.04 1.539-.846 5.524 1.648 1.94-1.029 2.5.152.576-.979 1.633.673 1.737-.838 2.22.808 1.257 1.942.175 2.372L30.484.542l-.964 1.514.713.682L50 10.604l-2.64.888-.68 1.11-2.135 1.002-7.502.122-5.76.273-5.562 1.602-3.462 2.179-6.58 5.358-4.926.722-2.165-.187-.648.672.94 1.296 2.26.622-.644 2.323-2.514-2.796-1.728-.67-1.317.653-2.057-2.522-1.362.377-1.365-1.362-.553-1.345 1.277-.7-.665-1.535-1.574-.22-1.347.653z', 
        National: 'm22.37-40.642 3.505 9.472 3.31 1.12 2.923 10.278 5.298 2.498 2.604 5.46 6.989 6.257L50 4.735l-2.71 8.896-5.893 8.82-.445 3.846-10.17 3.498.718 4.169 5.243 1.628-3.183 5.05-5.196-2.398-.764-3.771 3.9-.51-.718-4.168-11.2-1.302-7.241-9.081-10.654-5.379-7.737-2.775-12.474 1.887-6.545 4.127-8.908.105-4.705 2.65-7.752-1.81 1.656-6.532L-50-.74l1.051-12.034 6.827-3.106 8.735-1.775 16.78-15.45 6.01 1.71 4.105-5.59 5.35-1.241 4.82 1.462.803 6.198 3.44 2.901 10.16 3.872 1.6-9.181z', 
        "central-highlands": "m18.257 27.78-2.163-.261.545-1.062-.149-1.099.501-2.628-2.91-.129-1.358.354-2.873.096-1.975-.273 1.204-.526-.332-1.072-.84-.32-.79-1.003-6.034-.831.064-.454-1.558-1.38.267-1.237-.539-.63.33-1.729-.322-1.66L.416 6.212l-1.069.506-3.926.01-.585 1.684-.746.293-.14 1.357-.869.588-1.188-.021-1.246-.618-3.156-.501-.665 1.44-.752-.062-1.045.813-1.365 1.905.448.54-1.345-.81-.643.42-1.395-.472.177-.989-1.009-.266-.264-.97-2.542 1.089-.759.606-2.694 1.32.19-1.067-1.691-.026-.116.649-3.728-.426-2.554 1.001-1.28-.828-2.658-.285-.095-.848-1.02-1.205.527-2.98.632-.463.14-1.933-1.437-.904-10.114-1.277-.434-.489.643-1.105-.217-.885 1.05-2.085 1.777-1.38.335-1.042 1.87-1.8.905-1.845.249-2.044.721-1.217 3.852-.015-.894-1.04.708-.366-.083-2.016-2.383-2.736 7.918-.001 2.35-.657.679 1.18 1.822.135.72.908 5.191.723.332-1.85 1.465.727 2.979.188.356-1.81 1.3.373-.427-1.398.68-1.07-.384-2.493.288-2.043-.54-.547.902-3.866.846-.25 2.548-.056 2.616.19 4.778.586.331.407 1.948.466.688-.29 2.825.422 3.202.562 1.574-.06-.059 1.529.857.335-1.46 2.032-.477 2.752 1.184.952.114 1.093-1.059.77-.288 1.109 1.566.185-.142.78 2.651.3-.193 1.024 1.305.265 2.235-.305.497-.713 1.863.634 2.45.318 1.82-.04.682-2.181 3.351.522.433 1.019 1.897.897-.013.697 1.725.403 1.268-1.782-.083-1.028.463-2.49 2.147.507 3.128.342-.24 1.322 4.503.572.36-2.023 3.736.439-.513.297-.08 1.297-.79.822-1.526 3.025 3.842 1.787-.1 1.184 1.194.107-.238 1.663-1.446-.17-.123 2.064 2.451.519 1.656-.502-.47 2.635.475.47-.477 1.77L50 1.665l-1.499 2.008-.189 4.711-1.294-.046-.586 3.422-.487 2.646-.817-.094-.218 1.222-1.024-.809-.256-1.664-.767.256-1.701-.202-.304 1.464-1.03.133-1.729-.774.08-.424-3.346-.427.463 2.35.526.451-1.393 1.346-.493 1.68 1.553.191.48 2.016-.301.96.999 2.15 1.055 1.027-.808.677-.262 2.201-2.963.24-1.98-1.137-2.227.128-.713-.668-2.023.123-2.606.778-3.626-1.113-.293 1.525z"
    };


    const circleClockwise = (originObj, radius) => "M "+(originObj.x+radius)+","+originObj.y +" m 0,0  a "+radius+","+radius+" 0 0 1 "+(-radius * 2)+",0 a "+radius+","+radius+" 0 0 1 "+(radius * 2)+",0"; 
    const circleAntiClockwise = (originObj, radius) => "M "+(originObj.x-radius)+","+originObj.y +" m 0,0  a "+radius+","+radius+" 0 1 0 "+(radius * 2)+",0 a "+radius+","+radius+" 0 1 0 "+(-radius * 2)+",0"; 

    const triangle$1 = (radius, direction = 'up') => {
        const triRadius = radius * 0.8;
        return direction === 'up' 
            ? `M-${triRadius}, ${triRadius * 0.5}  L0, -${triRadius}  L${triRadius}, ${triRadius * 0.5}z` // Up triangle
            : `M-${triRadius}, -${triRadius * 0.5} L0, ${triRadius}  L${triRadius}, -${triRadius * 0.5}z`  // Down triangle
    };

    function ascending$3(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$3;
        compare2 = (d, x) => ascending$3(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$3 || f === descending$2 ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;
    var bisect = bisectRight;

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f] = F;
      if ((f && f.length !== 2) || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascendingDefined(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascendingDefined(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(compareDefined(f));
    }

    function compareDefined(compare = ascending$3) {
      if (compare === ascending$3) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a, b) => {
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }

    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length !== 2
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$3 = array$5.slice;

    function constant$b(x) {
      return () => x;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            step,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the domain is aligned with the first tick (which it will by
          // default), then we can use quantization rather than bisection to bin
          // values, which is substantially faster.
          if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

          // If the last threshold is coincident with the domain’s upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we don’t
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        if (isFinite(step)) {
          if (step > 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
              }
            }
          } else if (step < 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                const j = Math.floor((x0 - x) * step);
                bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
              }
            }
          }
        } else {
          for (i = 0; i < n; ++i) {
            if ((x = values[i]) != null && x0 <= x && x <= x1) {
              bins[bisect(tz, x, 0, m)].push(data[i]);
            }
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare) {
      compare = compare === undefined ? ascendingDefined : compareDefined(compare);

      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }
      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function thresholdFreedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function thresholdScott(values, min, max) {
      return Math.ceil((max - min) * Math.cbrt(count$1(values)) / (3.49 * deviation(values)));
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$2(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function rank(values, valueof = ascending$3) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      let V = Array.from(values);
      const R = new Float64Array(V.length);
      if (valueof.length !== 2) V = V.map(valueof), valueof = ascending$3;
      const compareIndex = (i, j) => valueof(V[i], V[j]);
      let k, r;
      Uint32Array
        .from(V, (_, i) => i)
        .sort(valueof === ascending$3 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex))
        .forEach((j, i) => {
          const c = compareIndex(j, k === undefined ? j : k);
          if (c >= 0) {
            if (k === undefined || c > 0) k = j, r = i;
            R[j] = r;
          } else {
            R[j] = NaN;
          }
        });
      return R;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new InternSet(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new InternSet();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function intersection(values, ...others) {
      values = new InternSet(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function set$2(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        const io = intern(o);
        if (set.has(io)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          const ivalue = intern(value);
          set.add(ivalue);
          if (Object.is(io, ivalue)) break;
        }
      }
      return true;
    }

    function intern(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$3 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend(Color, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend(Color, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0 ≅ u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$1(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$1(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$1 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$2() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m),
            pow2k = Math.pow(2, -k);

        data.forEach(function(d, i, data) {
          var xi = (x(d, i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values0[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values0[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values0[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values0[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$3(values0);
          tz = tickStep(0, stop, tz);
          tz = range$2(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$4(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$4, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$2 = 1664525;
    const c$4 = 1013904223;
    const m$1 = 4294967296; // 2^32

    function lcg$2() {
      let s = 1;
      return () => (s = (a$2 * s + c$4) % m$1) / m$1;
    }

    function x$3(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$2();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$3, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$2(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$1,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$2(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$2(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$2(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$2(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$2(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$2(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    var pathMeasure = lengthStream;

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Don’t include the root’s parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array, random) {
      let m = array.length,
          t,
          i;

      while (m) {
        i = random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      return packEncloseRandom(circles, lcg$1());
    }

    function packEncloseRandom(circles, random) {
      var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packSiblingsRandom(circles, random) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle…
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEncloseRandom(a, random);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packSiblingsRandom(circles, lcg$1());
      return circles;
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        const random = lcg$1();
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildrenRandom(padding, 0.5, random))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildrenRandom(constantZero, 1, random))
              .eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildrenRandom(padding, k, random) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packSiblingsRandom(children, random);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {},
        imputed = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId,
          path;

      function stratify(data) {
        var nodes = Array.from(data),
            currentId = id,
            currentParentId = parentId,
            n,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        if (path != null) {
          const I = nodes.map((d, i) => normalize$1(path(d, i, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i of P) {
            if (!S.has(i)) {
              S.add(i);
              I.push(i);
              P.push(parentof(i));
              nodes.push(imputed);
            }
          }
          currentId = (_, i) => I[i];
          currentParentId = (_, i) => P[i];
        }

        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");

        // When imputing internal nodes, only introduce roots if needed.
        // Then replace the imputed marker data with null.
        if (path != null) {
          while (root.data === imputed && root.children.length === 1) {
            root = root.children[0], --n;
          }
          for (let i = nodes.length - 1; i >= 0; --i) {
            node = nodes[i];
            if (node.data !== imputed) break;
            node.data = null;
          }
        }

        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = optional(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = optional(x), stratify) : parentId;
      };

      stratify.path = function(x) {
        return arguments.length ? (path = optional(x), stratify) : path;
      };

      return stratify;
    }

    // To normalize a path, we coerce to a string, strip the trailing slash if any
    // (as long as the trailing slash is not immediately preceded by another slash),
    // and add leading slash if missing.
    function normalize$1(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }

    // Walk backwards to find the first slash that is not the leading slash, e.g.:
    // "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
    // because the id of the root must be a truthy value.)
    function parentof(path) {
      let i = path.length;
      if (i < 2) return "";
      while (--i > 1) if (slash(path, i)) break;
      return path.slice(0, i);
    }

    // Slashes can be escaped; to determine whether a slash is a path delimiter, we
    // count the number of preceding backslashes escaping the forward slash: an odd
    // number indicates an escaped forward slash.
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\") ++k;
        if ((k & 1) === 0) return true;
      }
      return false;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$2(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : x => Math.pow(base, x);
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), x => Math.log(x) / base);
    }

    function reflect(f) {
      return (x, k) => -f(-x, k);
    }

    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = count => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;

        if (r) ([u, v] = [v, u]);

        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };

      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return d => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = () => {
        return domain(nice(domain(), {
          floor: x => pows(Math.floor(logs(x))),
          ceil: x => pows(Math.ceil(logs(x)))
        }));
      };

      return scale;
    }

    function log() {
      const scale = loggish(transformer$2()).domain([1, 10]);
      scale.copy = () => copy$1(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var millisecond$1 = millisecond;
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var utcSecond = second;
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var timeMinute = minute;
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var timeHour = hour;
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );

    var timeDay = day;
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var timeMonth = month;
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var timeYear = year;
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcMinute$1 = utcMinute;
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcHour$1 = utcHour;
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    var utcDay$1 = utcDay;
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcMonth$1 = utcMonth;
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    var utcYear$1 = utcYear;
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [utcSecond,  1,      durationSecond],
        [utcSecond,  5,  5 * durationSecond],
        [utcSecond, 15, 15 * durationSecond],
        [utcSecond, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond$1.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay$1.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    const abs = Math.abs;
    const atan2 = Math.atan2;
    const cos = Math.cos;
    const max = Math.max;
    const min = Math.min;
    const sin = Math.sin;
    const sqrt = Math.sqrt;

    const epsilon = 1e-12;
    const pi = Math.PI;
    const halfPi = pi / 2;
    const tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x$1(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x = typeof x === "function" ? x : (x === undefined) ? x$1 : constant$1(x);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), line) : x;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x$1 : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    class BumpRadial {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {}
      point(x, y) {
        x = +x, y = +y;
        if (this._point++ === 0) {
          this._x0 = x, this._y0 = y;
        } else {
          const p0 = pointRadial(this._x0, this._y0);
          const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y) / 2);
          const p2 = pointRadial(x, this._y0);
          const p3 = pointRadial(x, y);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function bumpRadial(context) {
      return new BumpRadial(context);
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      let source = linkSource;
      let target = linkTarget;
      let x = x$1;
      let y$1 = y;
      let context = null;
      let output = null;

      function link() {
        let buffer;
        const argv = slice.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null) output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        argv[0] = t, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        output.lineEnd();
        if (buffer) return output = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), link) : x;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
      };

      return link;
    }

    function linkHorizontal() {
      return link(bumpX);
    }

    function linkVertical() {
      return link(bumpY);
    }

    function linkRadial() {
      const l = link(bumpRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    const sqrt3$2 = sqrt(3);

    var asterisk = {
      draw(context, size) {
        const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$2;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };

    var circle = {
      draw(context, size) {
        const r = sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    const tan30 = sqrt(1 / 3);
    const tan30_2 = tan30 * 2;

    var diamond = {
      draw(context, size) {
        const y = sqrt(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var diamond2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };

    var plus = {
      draw(context, size) {
        const r = sqrt(size - min(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };

    var square = {
      draw(context, size) {
        const w = sqrt(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var square2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };

    const ka = 0.89081309152928522810;
    const kr = sin(pi / 10) / sin(7 * pi / 10);
    const kx = sin(tau / 10) * kr;
    const ky = -cos(tau / 10) * kr;

    var star = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a = tau * i / 5;
          const c = cos(a);
          const s = sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    const sqrt3$1 = sqrt(3);

    var triangle = {
      draw(context, size) {
        const y = -sqrt(size / (sqrt3$1 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$1 * y, -y);
        context.lineTo(sqrt3$1 * y, -y);
        context.closePath();
      }
    };

    const sqrt3 = sqrt(3);

    var triangle2 = {
      draw(context, size) {
        const s = sqrt(size) * 0.6824;
        const t = s  / 2;
        const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
        context.moveTo(0, -s);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };

    const c = -0.5;
    const s = sqrt(3) / 2;
    const k = 1 / sqrt(12);
    const a = (k / 2 + 1) * 3;

    var wye = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var x = {
      draw(context, size) {
        const r = sqrt(size - min(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };

    // These symbols are designed to be filled.
    const symbolsFill = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    // These symbols are designed to be stroked (with a width of 1.5px and round caps).
    const symbolsStroke = [
      circle,
      plus,
      x,
      triangle2,
      asterisk,
      square2,
      diamond2
    ];

    function Symbol$1(type, size) {
      let context = null;

      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisect,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: thresholdFreedmanDiaconis,
        thresholdScott: thresholdScott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$2,
        rank: rank,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$2,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$1,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        link: link,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: Symbol$1,
        symbolsStroke: symbolsStroke,
        symbolsFill: symbolsFill,
        symbols: symbolsFill,
        symbolAsterisk: asterisk,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolDiamond2: diamond2,
        symbolPlus: plus,
        symbolSquare: square,
        symbolSquare2: square2,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolTriangle2: triangle2,
        symbolWye: wye,
        symbolX: x,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond$1,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond$1,
        utcMilliseconds: milliseconds,
        timeSecond: utcSecond,
        timeSeconds: seconds,
        utcSecond: utcSecond,
        utcSeconds: seconds,
        timeMinute: timeMinute,
        timeMinutes: minutes,
        timeHour: timeHour,
        timeHours: hours,
        timeDay: timeDay,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: timeMonth,
        timeMonths: months,
        timeYear: timeYear,
        timeYears: years,
        utcMinute: utcMinute$1,
        utcMinutes: utcMinutes,
        utcHour: utcHour$1,
        utcHours: utcHours,
        utcDay: utcDay$1,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth$1,
        utcMonths: utcMonths,
        utcYear: utcYear$1,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '').toLowerCase(); // trim           
        const from = "àáäâèéëêìíïîòóöôùúüûñç·/_,:;",      // remove accents, swap ñ for n, etc
            to   = "aaaaeeeeiiiioooouuuunc------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }
        str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
            .replace(/\s+/g, '-') // collapse whitespace and replace by -
            .replace(/-+/g, '-'); // collapse dashes
        return str;
    }

    function textWrap(text, width, lineHeight, centerVertical = false) {

        text.each(function() {
            let text = select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                y = text.attr("y"),
                x = text.attr("x");
                parseFloat(text.style("font-size"));
                let dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));

                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan")
                        .attr("x", x)
                        .attr("y",  y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }                    
            }            
            if(centerVertical){
                text.style("transform",  "translateY(-"+(14 * (lineNumber))+"px)");
            }
        });
    } // end wrap()

    /* src/components/byPage/postcards/postcard/Hazards.svelte generated by Svelte v3.48.0 */
    const file$r = "src/components/byPage/postcards/postcard/Hazards.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (38:16) {#each eventsByHazard[hazard] as event}
    function create_each_block_1$8(ctx) {
    	let div;
    	let raw_value = /*event*/ ctx[9] + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "event svelte-9a8w10");
    			add_location(div, file$r, 38, 16, 1615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*eventsByHazard*/ 2 && raw_value !== (raw_value = /*event*/ ctx[9] + "")) div.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(38:16) {#each eventsByHazard[hazard] as event}",
    		ctx
    	});

    	return block;
    }

    // (43:79) {:else}
    function create_else_block_4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker svelte-9a8w10");
    			add_location(div, file$r, 42, 86, 1828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(43:79) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:16) {#if actionData[hazard] > 0}
    function create_if_block_4$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker filled svelte-9a8w10");
    			add_location(div, file$r, 42, 44, 1786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(43:16) {#if actionData[hazard] > 0}",
    		ctx
    	});

    	return block;
    }

    // (44:79) {:else}
    function create_else_block_3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker svelte-9a8w10");
    			add_location(div, file$r, 43, 86, 1948);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(44:79) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:16) {#if actionData[hazard] > 1}
    function create_if_block_3$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker filled svelte-9a8w10");
    			add_location(div, file$r, 43, 44, 1906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(44:16) {#if actionData[hazard] > 1}",
    		ctx
    	});

    	return block;
    }

    // (45:79) {:else}
    function create_else_block_2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker svelte-9a8w10");
    			add_location(div, file$r, 44, 86, 2068);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(45:79) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:16) {#if actionData[hazard] > 2}
    function create_if_block_2$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker filled svelte-9a8w10");
    			add_location(div, file$r, 44, 44, 2026);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(45:16) {#if actionData[hazard] > 2}",
    		ctx
    	});

    	return block;
    }

    // (46:79) {:else}
    function create_else_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker svelte-9a8w10");
    			add_location(div, file$r, 45, 86, 2188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(46:79) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:16) {#if actionData[hazard] > 3}
    function create_if_block_1$8(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker filled svelte-9a8w10");
    			add_location(div, file$r, 45, 44, 2146);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(46:16) {#if actionData[hazard] > 3}",
    		ctx
    	});

    	return block;
    }

    // (47:79) {:else}
    function create_else_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker svelte-9a8w10");
    			add_location(div, file$r, 46, 86, 2308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(47:79) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:16) {#if actionData[hazard] > 4}
    function create_if_block$a(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "marker filled svelte-9a8w10");
    			add_location(div, file$r, 46, 44, 2266);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(47:16) {#if actionData[hazard] > 4}",
    		ctx
    	});

    	return block;
    }

    // (29:8) {#each hazardList as hazard}
    function create_each_block$g(ctx) {
    	let div4;
    	let div0;
    	let raw_value = /*hazard*/ ctx[6] + "";
    	let t0;
    	let div1;
    	let svg;
    	let path;
    	let t1;
    	let div2;
    	let t2;
    	let div3;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let each_value_1 = /*eventsByHazard*/ ctx[1][/*hazard*/ ctx[6]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*actionData*/ ctx[0][/*hazard*/ ctx[6]] > 0) return create_if_block_4$2;
    		return create_else_block_4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*actionData*/ ctx[0][/*hazard*/ ctx[6]] > 1) return create_if_block_3$2;
    		return create_else_block_3;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*actionData*/ ctx[0][/*hazard*/ ctx[6]] > 2) return create_if_block_2$6;
    		return create_else_block_2;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*actionData*/ ctx[0][/*hazard*/ ctx[6]] > 3) return create_if_block_1$8;
    		return create_else_block_1$1;
    	}

    	let current_block_type_3 = select_block_type_3(ctx);
    	let if_block3 = current_block_type_3(ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (/*actionData*/ ctx[0][/*hazard*/ ctx[6]] > 4) return create_if_block$a;
    		return create_else_block$2;
    	}

    	let current_block_type_4 = select_block_type_4(ctx);
    	let if_block4 = current_block_type_4(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t1 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			div3 = element("div");
    			if_block0.c();
    			t3 = space();
    			if_block1.c();
    			t4 = space();
    			if_block2.c();
    			t5 = space();
    			if_block3.c();
    			t6 = space();
    			if_block4.c();
    			t7 = space();
    			attr_dev(div0, "class", "hazard-label-wrapper svelte-9a8w10");
    			add_location(div0, file$r, 30, 12, 1192);
    			attr_dev(path, "class", "icon " + slugify(/*hazard*/ ctx[6]) + " svelte-9a8w10");
    			attr_dev(path, "d", icons[slugify(/*hazard*/ ctx[6])]);
    			add_location(path, file$r, 33, 20, 1389);
    			attr_dev(svg, "class", "hazard-icon svelte-9a8w10");
    			attr_dev(svg, "viewBox", "-50 -50 100 100");
    			add_location(svg, file$r, 32, 16, 1313);
    			attr_dev(div1, "class", "hazard-icon-wrapper svelte-9a8w10");
    			add_location(div1, file$r, 31, 12, 1261);
    			attr_dev(div2, "class", "event-wrapper");
    			add_location(div2, file$r, 36, 12, 1513);
    			attr_dev(div3, "class", "marker-wrapper svelte-9a8w10");
    			add_location(div3, file$r, 41, 12, 1711);
    			attr_dev(div4, "class", "hazard-container " + slugify(/*hazard*/ ctx[6]) + " svelte-9a8w10");
    			add_location(div4, file$r, 29, 8, 1129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div4, t1);
    			append_dev(div4, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			if_block0.m(div3, null);
    			append_dev(div3, t3);
    			if_block1.m(div3, null);
    			append_dev(div3, t4);
    			if_block2.m(div3, null);
    			append_dev(div3, t5);
    			if_block3.m(div3, null);
    			append_dev(div3, t6);
    			if_block4.m(div3, null);
    			append_dev(div4, t7);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*eventsByHazard, hazardList*/ 6) {
    				each_value_1 = /*eventsByHazard*/ ctx[1][/*hazard*/ ctx[6]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div3, t3);
    				}
    			}

    			if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div3, t4);
    				}
    			}

    			if (current_block_type_2 !== (current_block_type_2 = select_block_type_2(ctx))) {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div3, t5);
    				}
    			}

    			if (current_block_type_3 !== (current_block_type_3 = select_block_type_3(ctx))) {
    				if_block3.d(1);
    				if_block3 = current_block_type_3(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(div3, t6);
    				}
    			}

    			if (current_block_type_4 !== (current_block_type_4 = select_block_type_4(ctx))) {
    				if_block4.d(1);
    				if_block4 = current_block_type_4(ctx);

    				if (if_block4) {
    					if_block4.c();
    					if_block4.m(div3, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    			if_block3.d();
    			if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(29:8) {#each hazardList as hazard}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let section;
    	let div0;
    	let t0;
    	let h3;
    	let t2;
    	let div1;
    	let each_value = /*hazardList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			t0 = space();
    			h3 = element("h3");
    			h3.textContent = "Ratings vs climate hazards";
    			t2 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "wedge svelte-9a8w10");
    			add_location(div0, file$r, 25, 4, 979);
    			attr_dev(h3, "class", "svelte-9a8w10");
    			add_location(h3, file$r, 26, 4, 1011);
    			attr_dev(div1, "class", "hazards-container svelte-9a8w10");
    			add_location(div1, file$r, 27, 4, 1051);
    			attr_dev(section, "class", "hazards-wrapper svelte-9a8w10");
    			add_location(section, file$r, 24, 0, 940);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			append_dev(section, t0);
    			append_dev(section, h3);
    			append_dev(section, t2);
    			append_dev(section, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*slugify, hazardList, actionData, eventsByHazard, icons*/ 7) {
    				each_value = /*hazardList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(3, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hazards', slots, []);
    	let { actionData } = $$props;
    	const hazardRecordList = [...new Set(actionData.Hazard)];
    	const hazardList = [...new Set(actionData.Hazard)].map(d => $data.schema.hazards.data.filter(e => e.recordID === d)[0].Hazard);
    	const eventObjList = [...new Set(actionData["Hazard event"])].map(d => $data.schema.hazardEvents.data.filter(e => e.recordID === d)[0]);
    	const eventsByHazard = {};

    	hazardRecordList.forEach((id, i) => {
    		$$invalidate(1, eventsByHazard[hazardList[i]] = [], eventsByHazard);

    		for (const obj of eventObjList) {
    			if (obj.Hazard && id === obj.Hazard[0]) {
    				eventsByHazard[hazardList[i]].push(obj["Hazard event"]);
    			}
    		}
    	});

    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hazards> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({
    		data,
    		icons,
    		slugify,
    		actionData,
    		hazardRecordList,
    		hazardList,
    		eventObjList,
    		eventsByHazard,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actionData, eventsByHazard, hazardList];
    }

    class Hazards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$r, create_fragment$r, safe_not_equal, { actionData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hazards",
    			options,
    			id: create_fragment$r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[0] === undefined && !('actionData' in props)) {
    			console.warn("<Hazards> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Hazards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Hazards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/ImageHazards.svelte generated by Svelte v3.48.0 */
    const file$q = "src/components/byPage/postcards/postcard/ImageHazards.svelte";

    function create_fragment$q(ctx) {
    	let section;
    	let image;
    	let t;
    	let hazards;
    	let current;

    	image = new Image$1({
    			props: { imgURL: /*imgURL*/ ctx[1] },
    			$$inline: true
    		});

    	hazards = new Hazards({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(image.$$.fragment);
    			t = space();
    			create_component(hazards.$$.fragment);
    			attr_dev(section, "class", "imgHazard svelte-1bxb02c");
    			add_location(section, file$q, 12, 0, 264);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(image, section, null);
    			append_dev(section, t);
    			mount_component(hazards, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const image_changes = {};
    			if (dirty & /*imgURL*/ 2) image_changes.imgURL = /*imgURL*/ ctx[1];
    			image.$set(image_changes);
    			const hazards_changes = {};
    			if (dirty & /*actionData*/ 1) hazards_changes.actionData = /*actionData*/ ctx[0];
    			hazards.$set(hazards_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			transition_in(hazards.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			transition_out(hazards.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(image);
    			destroy_component(hazards);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let imgURL;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageHazards', slots, []);
    	let { actionData } = $$props;
    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImageHazards> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({ Image: Image$1, Hazards, actionData, imgURL });

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    		if ('imgURL' in $$props) $$invalidate(1, imgURL = $$props.imgURL);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*actionData*/ 1) {
    			$$invalidate(1, imgURL = actionData.image ? actionData.image[0].url : null);
    		}
    	};

    	return [actionData, imgURL];
    }

    class ImageHazards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$q, create_fragment$q, safe_not_equal, { actionData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageHazards",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[0] === undefined && !('actionData' in props)) {
    			console.warn("<ImageHazards> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<ImageHazards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<ImageHazards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/AdaptationCriteria.svelte generated by Svelte v3.48.0 */
    const file$p = "src/components/byPage/postcards/postcard/AdaptationCriteria.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (23:12) {#each $data.schema.adaptationScreens.data as lens, i}
    function create_each_block_1$7(ctx) {
    	let circle;
    	let circle_class_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", circle_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"));
    			attr_dev(circle, "r", /*radius*/ ctx[3]);
    			set_style(circle, "transform", "translate(" + /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos + "px, " + /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos + "px)");
    			add_location(circle, file$p, 23, 12, 895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*criteria, $data*/ 3 && circle_class_value !== (circle_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"))) {
    				attr_dev(circle, "class", circle_class_value);
    			}

    			if (dirty & /*$data*/ 2) {
    				set_style(circle, "transform", "translate(" + /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos + "px, " + /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(23:12) {#each $data.schema.adaptationScreens.data as lens, i}",
    		ctx
    	});

    	return block;
    }

    // (44:51) 
    function create_if_block_2$5(ctx) {
    	let path;
    	let path_id_value;
    	let path_d_value;
    	let text_1;
    	let textPath;

    	let raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    	? /*lens*/ ctx[4].Screen
    	: "Not " + /*lens*/ ctx[4].Screen) + "";

    	let textPath_class_value;
    	let textPath_href_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			text_1 = svg_element("text");
    			textPath = svg_element("textPath");
    			attr_dev(path, "id", path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path, "class", "label-path svelte-royxzr");

    			attr_dev(path, "d", path_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 110
    			));

    			add_location(path, file$p, 44, 20, 2468);
    			attr_dev(textPath, "class", textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"));
    			attr_dev(textPath, "href", textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath, "startOffset", "12.5%");
    			add_location(textPath, file$p, 46, 24, 2689);
    			add_location(text_1, file$p, 45, 20, 2658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, textPath);
    			textPath.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path_id_value !== (path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path, "id", path_id_value);
    			}

    			if (dirty & /*$data*/ 2 && path_d_value !== (path_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 110
    			))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*criteria, $data*/ 3 && raw_value !== (raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    			? /*lens*/ ctx[4].Screen
    			: "Not " + /*lens*/ ctx[4].Screen) + "")) textPath.innerHTML = raw_value;
    			if (dirty & /*criteria, $data*/ 3 && textPath_class_value !== (textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"))) {
    				attr_dev(textPath, "class", textPath_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath_href_value !== (textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath, "href", textPath_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(44:51) ",
    		ctx
    	});

    	return block;
    }

    // (36:50) 
    function create_if_block_1$7(ctx) {
    	let path;
    	let path_id_value;
    	let path_d_value;
    	let text_1;
    	let textPath;

    	let raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    	? /*lens*/ ctx[4].Screen
    	: "Not " + /*lens*/ ctx[4].Screen) + "";

    	let textPath_class_value;
    	let textPath_href_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			text_1 = svg_element("text");
    			textPath = svg_element("textPath");
    			attr_dev(path, "id", path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path, "class", "label-path svelte-royxzr");

    			attr_dev(path, "d", path_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 110
    			));

    			add_location(path, file$p, 36, 20, 1843);
    			attr_dev(textPath, "class", textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"));
    			attr_dev(textPath, "href", textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath, "startOffset", "32.5%");
    			add_location(textPath, file$p, 38, 24, 2064);
    			add_location(text_1, file$p, 37, 20, 2033);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, textPath);
    			textPath.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path_id_value !== (path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path, "id", path_id_value);
    			}

    			if (dirty & /*$data*/ 2 && path_d_value !== (path_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 110
    			))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*criteria, $data*/ 3 && raw_value !== (raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    			? /*lens*/ ctx[4].Screen
    			: "Not " + /*lens*/ ctx[4].Screen) + "")) textPath.innerHTML = raw_value;
    			if (dirty & /*criteria, $data*/ 3 && textPath_class_value !== (textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"))) {
    				attr_dev(textPath, "class", textPath_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath_href_value !== (textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath, "href", textPath_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(36:50) ",
    		ctx
    	});

    	return block;
    }

    // (28:16) {#if lens.lensPos === "top"}
    function create_if_block$9(ctx) {
    	let path;
    	let path_id_value;
    	let path_d_value;
    	let text_1;
    	let textPath;

    	let raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    	? /*lens*/ ctx[4].Screen
    	: "Not " + /*lens*/ ctx[4].Screen) + "";

    	let textPath_class_value;
    	let textPath_href_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			text_1 = svg_element("text");
    			textPath = svg_element("textPath");
    			attr_dev(path, "id", path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path, "class", "label-path svelte-royxzr");

    			attr_dev(path, "d", path_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 20
    			));

    			add_location(path, file$p, 28, 20, 1226);
    			attr_dev(textPath, "class", textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"));
    			attr_dev(textPath, "href", textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath, "startOffset", "75%");
    			add_location(textPath, file$p, 30, 24, 1442);
    			add_location(text_1, file$p, 29, 20, 1411);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, textPath);
    			textPath.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path_id_value !== (path_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path, "id", path_id_value);
    			}

    			if (dirty & /*$data*/ 2 && path_d_value !== (path_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[2].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[2].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 20
    			))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*criteria, $data*/ 3 && raw_value !== (raw_value = (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] === "Yes"
    			? /*lens*/ ctx[4].Screen
    			: "Not " + /*lens*/ ctx[4].Screen) + "")) textPath.innerHTML = raw_value;
    			if (dirty & /*criteria, $data*/ 3 && textPath_class_value !== (textPath_class_value = "" + (/*criteria*/ ctx[0][slugify(/*lens*/ ctx[4].Screen)] + " lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-royxzr"))) {
    				attr_dev(textPath, "class", textPath_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath_href_value !== (textPath_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath, "href", textPath_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(28:16) {#if lens.lensPos === \\\"top\\\"}",
    		ctx
    	});

    	return block;
    }

    // (27:12) {#each $data.schema.adaptationScreens.data as lens, i}
    function create_each_block$f(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*lens*/ ctx[4].lensPos === "top") return create_if_block$9;
    		if (/*lens*/ ctx[4].lensPos === "left") return create_if_block_1$7;
    		if (/*lens*/ ctx[4].lensPos === "right") return create_if_block_2$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(27:12) {#each $data.schema.adaptationScreens.data as lens, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let each0_anchor;
    	let g1_intro;
    	let each_value_1 = /*$data*/ ctx[1].schema.adaptationScreens.data;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	let each_value = /*$data*/ ctx[1].schema.adaptationScreens.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(g0, "transform", "translate(" + /*dims*/ ctx[2].width * 0.5 + "px, " + /*dims*/ ctx[2].height * 0.55 + "px)");
    			add_location(g0, file$p, 21, 8, 735);
    			attr_dev(g1, "id", "screening-vis-container");
    			add_location(g1, file$p, 20, 4, 685);
    			attr_dev(svg, "viewBox", "0 0 " + /*dims*/ ctx[2].width + " " + /*dims*/ ctx[2].height);
    			attr_dev(svg, "width", "100%");
    			add_location(svg, file$p, 19, 0, 619);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g0, null);
    			}

    			append_dev(g0, each0_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g0, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*criteria, slugify, $data, radius, dims*/ 15) {
    				each_value_1 = /*$data*/ ctx[1].schema.adaptationScreens.data;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$7(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g0, each0_anchor);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*criteria, slugify, $data, circleClockwise, dims, radius, circleAntiClockwise*/ 15) {
    				each_value = /*$data*/ ctx[1].schema.adaptationScreens.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (!g1_intro) {
    				add_render_callback(() => {
    					g1_intro = create_in_transition(g1, fade, {});
    					g1_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AdaptationCriteria', slots, []);
    	let { criteria = {} } = $$props;

    	const dims = {
    		// SVG dimensions
    		width: 1600,
    		height: 1600
    	};

    	const radius = dims.width * 0.25;
    	const writable_props = ['criteria'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AdaptationCriteria> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('criteria' in $$props) $$invalidate(0, criteria = $$props.criteria);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		slugify,
    		schema,
    		circleClockwise,
    		circleAntiClockwise,
    		criteria,
    		dims,
    		radius,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('criteria' in $$props) $$invalidate(0, criteria = $$props.criteria);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [criteria, $data, dims, radius];
    }

    class AdaptationCriteria extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$p, create_fragment$p, safe_not_equal, { criteria: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdaptationCriteria",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get criteria() {
    		throw new Error("<AdaptationCriteria>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set criteria(value) {
    		throw new Error("<AdaptationCriteria>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/ActionTypeVis.svelte generated by Svelte v3.48.0 */
    const file$o = "src/components/byPage/postcards/postcard/ActionTypeVis.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	const constants_0 = /*typeData*/ child_ctx[2].nodes.filter(e => e.Name === /*link*/ child_ctx[7]._source.replaceAll('\"', ''))[0];
    	child_ctx[8] = constants_0;
    	const constants_1 = /*typeData*/ child_ctx[2].nodes.filter(e => e.Name === /*link*/ child_ctx[7]._target.replaceAll('\"', ''))[0];
    	child_ctx[9] = constants_1;

    	const constants_2 = typeof /*link*/ child_ctx[7].midX !== 'undefined'
    	? `M${/*source*/ child_ctx[8].xPos * 0.5 * /*dims*/ child_ctx[1].width}, ${/*source*/ child_ctx[8].yPos * /*dims*/ child_ctx[1].height} 
                        L${/*link*/ child_ctx[7].midX * 0.5 * /*dims*/ child_ctx[1].width}, ${/*link*/ child_ctx[7].midY * /*dims*/ child_ctx[1].height} 
                        L${/*target*/ child_ctx[9].xPos * 0.5 * /*dims*/ child_ctx[1].width}, ${/*target*/ child_ctx[9].yPos * /*dims*/ child_ctx[1].height}`
    	: `M${/*source*/ child_ctx[8].xPos * 0.5 * /*dims*/ child_ctx[1].width}, ${/*source*/ child_ctx[8].yPos * /*dims*/ child_ctx[1].height} 
                            L${/*target*/ child_ctx[9].xPos * 0.5 * /*dims*/ child_ctx[1].width}, ${/*target*/ child_ctx[9].yPos * /*dims*/ child_ctx[1].height}`;

    	child_ctx[10] = constants_2;
    	return child_ctx;
    }

    // (26:12) {#each typeData.links as link}
    function create_each_block_1$6(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "flow svelte-1sv06l");
    			attr_dev(path, "d", /*path*/ ctx[10]);
    			add_location(path, file$o, 35, 16, 1652);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(26:12) {#each typeData.links as link}",
    		ctx
    	});

    	return block;
    }

    // (40:12) {#each typeData.nodes as node}
    function create_each_block$e(ctx) {
    	let circle;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "node " + slugify(/*node*/ ctx[4].Class) + " svelte-1sv06l");
    			set_style(circle, "transform", "translate( " + /*node*/ ctx[4].xPos * 0.5 * /*dims*/ ctx[1].width + "px, " + /*node*/ ctx[4].yPos * /*dims*/ ctx[1].height + "px)");
    			toggle_class(circle, "selected", /*node*/ ctx[4].Name === /*actionType*/ ctx[0]);
    			add_location(circle, file$o, 40, 12, 1823);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*typeData, actionType*/ 5) {
    				toggle_class(circle, "selected", /*node*/ ctx[4].Name === /*actionType*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(40:12) {#each typeData.nodes as node}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let svg;
    	let g2;
    	let g0;
    	let g1;
    	let svg_intro;
    	let each_value_1 = /*typeData*/ ctx[2].links;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	let each_value = /*typeData*/ ctx[2].nodes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g1 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g0, "class", "connector-container");
    			add_location(g0, file$o, 24, 8, 796);
    			attr_dev(g1, "class", "action-type-node-container");
    			add_location(g1, file$o, 38, 8, 1727);
    			attr_dev(g2, "class", "flow-diagram");
    			set_style(g2, "transform", "translate(" + /*dims*/ ctx[1].width * 0.5 + "px, 0px)");
    			add_location(g2, file$o, 23, 4, 705);
    			attr_dev(svg, "viewBox", "0 0 " + /*dims*/ ctx[1].width + " " + /*dims*/ ctx[1].height);
    			attr_dev(svg, "width", "100%");
    			add_location(svg, file$o, 22, 0, 632);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g2);
    			append_dev(g2, g0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g0, null);
    			}

    			append_dev(g2, g1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g1, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*typeData, dims*/ 6) {
    				each_value_1 = /*typeData*/ ctx[2].links;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$6(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*slugify, typeData, dims, actionType*/ 7) {
    				each_value = /*typeData*/ ctx[2].nodes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (!svg_intro) {
    				add_render_callback(() => {
    					svg_intro = create_in_transition(svg, fade, {});
    					svg_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(3, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ActionTypeVis', slots, []);
    	let { actionType } = $$props;
    	const dims = { width: 1600, height: 1600 };

    	const typeData = {
    		nodes: $data.schema.actionTypeNodes.data,
    		links: $data.schema.actionTypeLinks.data
    	};

    	const writable_props = ['actionType'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ActionTypeVis> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionType' in $$props) $$invalidate(0, actionType = $$props.actionType);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		scale,
    		onMount,
    		d3,
    		textWrap,
    		slugify,
    		ui,
    		data,
    		actionType,
    		dims,
    		typeData,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionType' in $$props) $$invalidate(0, actionType = $$props.actionType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actionType, dims, typeData];
    }

    class ActionTypeVis extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$o, create_fragment$o, safe_not_equal, { actionType: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ActionTypeVis",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionType*/ ctx[0] === undefined && !('actionType' in props)) {
    			console.warn("<ActionTypeVis> was created without expected prop 'actionType'");
    		}
    	}

    	get actionType() {
    		throw new Error("<ActionTypeVis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionType(value) {
    		throw new Error("<ActionTypeVis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/Info.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1$1 } = globals;
    const file$n = "src/components/byPage/postcards/postcard/Info.svelte";

    // (77:20) {#if actionApproachThemeArray.includes('Increase resilience')}
    function create_if_block_1$6(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", triangle$1(50));
    			set_style(path, "transform", "translate( 50px, 50px)");
    			add_location(path, file$n, 77, 20, 3597);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(77:20) {#if actionApproachThemeArray.includes('Increase resilience')}",
    		ctx
    	});

    	return block;
    }

    // (80:20) {#if actionApproachThemeArray.includes('Reduce risk')}
    function create_if_block$8(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", triangle$1(50, 'down'));
    			set_style(path, "transform", "translate( 50px, 50px)");
    			add_location(path, file$n, 80, 20, 3786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(80:20) {#if actionApproachThemeArray.includes('Reduce risk')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let section;
    	let div5;
    	let div0;
    	let h40;
    	let t1;
    	let div4;
    	let div1;
    	let actiontypevis;
    	let t2;
    	let div3;
    	let div2;
    	let t3;
    	let div11;
    	let div6;
    	let h41;
    	let t5;
    	let div10;
    	let div7;
    	let svg0;
    	let show_if_1 = /*actionApproachThemeArray*/ ctx[2].includes('Increase resilience');
    	let if_block0_anchor;
    	let show_if = /*actionApproachThemeArray*/ ctx[2].includes('Reduce risk');
    	let t6;
    	let div9;
    	let div8;
    	let t7;
    	let div17;
    	let div12;
    	let h42;
    	let t9;
    	let div16;
    	let div13;
    	let svg1;
    	let path;
    	let t10;
    	let div15;
    	let div14;
    	let t11;
    	let div23;
    	let div18;
    	let h43;
    	let t13;
    	let div22;
    	let div19;
    	let adaptationcriteria;
    	let t14;
    	let div21;
    	let div20;
    	let current;

    	actiontypevis = new ActionTypeVis({
    			props: { actionType: /*actionType*/ ctx[1] },
    			$$inline: true
    		});

    	let if_block0 = show_if_1 && create_if_block_1$6(ctx);
    	let if_block1 = show_if && create_if_block$8(ctx);

    	adaptationcriteria = new AdaptationCriteria({
    			props: { criteria: /*criteria*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			div5 = element("div");
    			div0 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Action type";
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			create_component(actiontypevis.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t3 = space();
    			div11 = element("div");
    			div6 = element("div");
    			h41 = element("h4");
    			h41.textContent = "Adaptation approach";
    			t5 = space();
    			div10 = element("div");
    			div7 = element("div");
    			svg0 = svg_element("svg");
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			div9 = element("div");
    			div8 = element("div");
    			t7 = space();
    			div17 = element("div");
    			div12 = element("div");
    			h42 = element("h4");
    			h42.textContent = "Project scale";
    			t9 = space();
    			div16 = element("div");
    			div13 = element("div");
    			svg1 = svg_element("svg");
    			path = svg_element("path");
    			t10 = space();
    			div15 = element("div");
    			div14 = element("div");
    			t11 = space();
    			div23 = element("div");
    			div18 = element("div");
    			h43 = element("h4");
    			h43.textContent = "Adaptation criteria";
    			t13 = space();
    			div22 = element("div");
    			div19 = element("div");
    			create_component(adaptationcriteria.$$.fragment);
    			t14 = space();
    			div21 = element("div");
    			div20 = element("div");
    			attr_dev(h40, "class", "svelte-1k9n8ov");
    			add_location(h40, file$n, 54, 12, 2801);
    			attr_dev(div0, "class", "header svelte-1k9n8ov");
    			add_location(div0, file$n, 53, 8, 2766);
    			attr_dev(div1, "class", "icon-wrapper svelte-1k9n8ov");
    			add_location(div1, file$n, 57, 13, 2891);
    			attr_dev(div2, "class", "response svelte-1k9n8ov");
    			add_location(div2, file$n, 61, 16, 3043);
    			attr_dev(div3, "class", "label-wrapper svelte-1k9n8ov");
    			add_location(div3, file$n, 60, 12, 2997);
    			attr_dev(div4, "class", "response-wrapper svelte-1k9n8ov");
    			add_location(div4, file$n, 56, 8, 2845);
    			attr_dev(div5, "class", "info-container svelte-1k9n8ov");
    			add_location(div5, file$n, 52, 4, 2728);
    			attr_dev(h41, "class", "svelte-1k9n8ov");
    			add_location(h41, file$n, 71, 12, 3287);
    			attr_dev(div6, "class", "header svelte-1k9n8ov");
    			add_location(div6, file$n, 70, 8, 3252);
    			attr_dev(svg0, "class", "scale-icon svelte-1k9n8ov");
    			attr_dev(svg0, "viewBox", "0 0 100 100");
    			attr_dev(svg0, "width", "100%");
    			add_location(svg0, file$n, 75, 16, 3430);
    			attr_dev(div7, "class", "icon-wrapper svelte-1k9n8ov");
    			add_location(div7, file$n, 74, 13, 3385);
    			attr_dev(div8, "class", "response icon-label svelte-1k9n8ov");
    			add_location(div8, file$n, 85, 16, 3988);
    			attr_dev(div9, "class", "label-wrapper svelte-1k9n8ov");
    			add_location(div9, file$n, 84, 12, 3942);
    			attr_dev(div10, "class", "response-wrapper svelte-1k9n8ov");
    			add_location(div10, file$n, 73, 8, 3339);
    			attr_dev(div11, "class", "info-container svelte-1k9n8ov");
    			add_location(div11, file$n, 69, 4, 3214);
    			attr_dev(h42, "class", "svelte-1k9n8ov");
    			add_location(h42, file$n, 95, 12, 4246);
    			attr_dev(div12, "class", "header svelte-1k9n8ov");
    			add_location(div12, file$n, 94, 8, 4211);
    			attr_dev(path, "d", mapIcons[/*actionScale*/ ctx[4]]);
    			add_location(path, file$n, 100, 20, 4482);
    			attr_dev(svg1, "class", "scale-icon svelte-1k9n8ov");
    			attr_dev(svg1, "viewBox", "-50 -50 100 100");
    			attr_dev(svg1, "width", "100%");
    			add_location(svg1, file$n, 99, 16, 4394);
    			attr_dev(div13, "class", "icon-wrapper svelte-1k9n8ov");
    			add_location(div13, file$n, 98, 13, 4349);
    			attr_dev(div14, "class", "response icon-label svelte-1k9n8ov");
    			add_location(div14, file$n, 104, 16, 4618);
    			attr_dev(div15, "class", "label-wrapper svelte-1k9n8ov");
    			add_location(div15, file$n, 103, 12, 4572);
    			attr_dev(div16, "class", "response-wrapper icon-label svelte-1k9n8ov");
    			add_location(div16, file$n, 97, 8, 4292);
    			attr_dev(div17, "class", "info-container svelte-1k9n8ov");
    			add_location(div17, file$n, 93, 4, 4173);
    			attr_dev(h43, "class", "svelte-1k9n8ov");
    			add_location(h43, file$n, 114, 12, 4882);
    			attr_dev(div18, "class", "header svelte-1k9n8ov");
    			add_location(div18, file$n, 113, 8, 4847);
    			attr_dev(div19, "class", "icon-wrapper svelte-1k9n8ov");
    			add_location(div19, file$n, 117, 12, 4990);
    			attr_dev(div20, "class", "response svelte-1k9n8ov");
    			add_location(div20, file$n, 121, 16, 5147);
    			attr_dev(div21, "class", "label-wrapper svelte-1k9n8ov");
    			add_location(div21, file$n, 120, 12, 5100);
    			attr_dev(div22, "class", "response-wrapper icon-label svelte-1k9n8ov");
    			add_location(div22, file$n, 116, 8, 4934);
    			attr_dev(div23, "class", "info-container svelte-1k9n8ov");
    			add_location(div23, file$n, 112, 4, 4809);
    			attr_dev(section, "class", "svelte-1k9n8ov");
    			add_location(section, file$n, 50, 0, 2690);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h40);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			mount_component(actiontypevis, div1, null);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			div2.innerHTML = /*actionType*/ ctx[1];
    			append_dev(section, t3);
    			append_dev(section, div11);
    			append_dev(div11, div6);
    			append_dev(div6, h41);
    			append_dev(div11, t5);
    			append_dev(div11, div10);
    			append_dev(div10, div7);
    			append_dev(div7, svg0);
    			if (if_block0) if_block0.m(svg0, null);
    			append_dev(svg0, if_block0_anchor);
    			if (if_block1) if_block1.m(svg0, null);
    			append_dev(div10, t6);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			div8.innerHTML = /*actionApproachTheme*/ ctx[3];
    			append_dev(section, t7);
    			append_dev(section, div17);
    			append_dev(div17, div12);
    			append_dev(div12, h42);
    			append_dev(div17, t9);
    			append_dev(div17, div16);
    			append_dev(div16, div13);
    			append_dev(div13, svg1);
    			append_dev(svg1, path);
    			append_dev(div16, t10);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			div14.innerHTML = /*actionScale*/ ctx[4];
    			append_dev(section, t11);
    			append_dev(section, div23);
    			append_dev(div23, div18);
    			append_dev(div18, h43);
    			append_dev(div23, t13);
    			append_dev(div23, div22);
    			append_dev(div22, div19);
    			mount_component(adaptationcriteria, div19, null);
    			append_dev(div22, t14);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			div20.innerHTML = /*assessment*/ ctx[0];
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (show_if_1) if_block0.p(ctx, dirty);
    			if (show_if) if_block1.p(ctx, dirty);
    			if (!current || dirty & /*assessment*/ 1) div20.innerHTML = /*assessment*/ ctx[0];		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actiontypevis.$$.fragment, local);
    			transition_in(adaptationcriteria.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actiontypevis.$$.fragment, local);
    			transition_out(adaptationcriteria.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(actiontypevis);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(adaptationcriteria);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(7, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info', slots, []);
    	let { actionData } = $$props;

    	// Ge action data
    	const actionType = actionData['Action type']
    	? schema.actionTypes.data.filter(d => d.recordID === actionData['Action type'][0])[0].Type
    	: null;

    	const actionApproachArray = [...new Set(actionData['Adaptation and risk approach'])].map(d => schema.adaptationApproaches.data.filter(e => e.recordID === d)[0]["Adaptation and risk approach"]);

    	const actionApproachThemeArray = [
    		...new Set(actionData['Adaptation and risk approach'].map(d => schema.adaptationApproaches.data.filter(e => e.recordID === d)[0]["Approach theme"]))
    	];

    	const actionApproachTheme = actionApproachThemeArray.length === 2
    	? "Reduce risk and increase resilience"
    	: actionApproachThemeArray[0];

    	const actionScale = actionData.Scale
    	? schema.actionScale.data.filter(d => d.recordID === actionData.Scale[0])[0].Scale
    	: null;

    	const focusAreas = [...new Set(actionData['Focus areas'])].map(d => schema.adaptationFocus.data.filter(e => e.recordID === d)[0]["Alias"]);

    	const criteria = {
    		flexible: actionData[$data.schema.adaptationScreens.data.filter(d => d.Screen === "Flexible")[0].fieldName],
    		robust: actionData[$data.schema.adaptationScreens.data.filter(d => d.Screen === "Robust")[0].fieldName],
    		viable: actionData[$data.schema.adaptationScreens.data.filter(d => d.Screen === "Viable")[0].fieldName]
    	};

    	let assessment = '';

    	switch (actionData["Screening outcome"]) {
    		case "=> No regrets":
    			assessment = "No regrets: highest priority";
    			break;
    		case "=> Discard":
    			assessment = "No adaptation benefit";
    			break;
    		default:
    			switch (Object.values(criteria).filter(d => d === "Yes").length) {
    				case 3:
    					assessment = "No regrets";
    					break;
    				case 2:
    					assessment = "High priority";
    					break;
    				case 1:
    					assessment = "Low priority";
    					break;
    				case 0:
    					assessment = "Uncertain adaptation benefit";
    					break;
    			}
    	}

    	const writable_props = ['actionData'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(6, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({
    		AdaptationCriteria,
    		ActionTypeVis,
    		schema,
    		data,
    		slugify,
    		mapIcons,
    		icons,
    		triangle: triangle$1,
    		actionData,
    		actionType,
    		actionApproachArray,
    		actionApproachThemeArray,
    		actionApproachTheme,
    		actionScale,
    		focusAreas,
    		criteria,
    		assessment,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(6, actionData = $$props.actionData);
    		if ('assessment' in $$props) $$invalidate(0, assessment = $$props.assessment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		assessment,
    		actionType,
    		actionApproachThemeArray,
    		actionApproachTheme,
    		actionScale,
    		criteria,
    		actionData
    	];
    }

    class Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$n, create_fragment$n, safe_not_equal, { actionData: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[6] === undefined && !('actionData' in props)) {
    			console.warn("<Info> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/postcard/Strip.svelte generated by Svelte v3.48.0 */
    const file$m = "src/components/byPage/postcards/postcard/Strip.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (28:12) {#each $data.schema.adaptationFocus.data as d}
    function create_each_block$d(ctx) {
    	let div2;
    	let div0;
    	let svg;
    	let path;
    	let path_d_value;
    	let t0;
    	let div1;
    	let raw_value = /*d*/ ctx[3].Alias + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			attr_dev(path, "d", path_d_value = icons[slugify(/*d*/ ctx[3].Alias)]);
    			add_location(path, file$m, 31, 24, 1288);
    			attr_dev(svg, "class", "focusArea-icon svelte-oau61i");
    			attr_dev(svg, "viewBox", "-50 -50 100 100");
    			attr_dev(svg, "width", "80%");
    			add_location(svg, file$m, 30, 20, 1190);
    			attr_dev(div0, "class", "focusArea-icon-wrapper svelte-oau61i");
    			add_location(div0, file$m, 29, 16, 1130);
    			attr_dev(div1, "class", "focusArea-icon-label svelte-oau61i");
    			add_location(div1, file$m, 34, 16, 1393);
    			attr_dev(div2, "class", "focusArea-wrapper svelte-oau61i");
    			toggle_class(div2, "selected", /*focusAreas*/ ctx[1].indexOf(/*d*/ ctx[3].Alias) > -1);
    			add_location(div2, file$m, 28, 12, 1030);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, svg);
    			append_dev(svg, path);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div2, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1 && path_d_value !== (path_d_value = icons[slugify(/*d*/ ctx[3].Alias)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 1 && raw_value !== (raw_value = /*d*/ ctx[3].Alias + "")) div1.innerHTML = raw_value;
    			if (dirty & /*focusAreas, $data*/ 3) {
    				toggle_class(div2, "selected", /*focusAreas*/ ctx[1].indexOf(/*d*/ ctx[3].Alias) > -1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(28:12) {#each $data.schema.adaptationFocus.data as d}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let section;
    	let div0;
    	let logo;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div5;
    	let div4;
    	let div3;
    	let t4;
    	let div7;
    	let div6;
    	let current;
    	logo = new Logo({ $$inline: true });
    	let each_value = /*$data*/ ctx[0].schema.adaptationFocus.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div3.textContent = "Hepburn climate change adaptation focus areas";
    			t4 = space();
    			div7 = element("div");
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "logo-container svelte-oau61i");
    			add_location(div0, file$m, 15, 4, 563);
    			attr_dev(div1, "class", "strip-1a svelte-oau61i");
    			add_location(div1, file$m, 18, 4, 625);
    			attr_dev(div2, "class", "strip-2a svelte-oau61i");
    			add_location(div2, file$m, 19, 4, 659);
    			attr_dev(div3, "class", "vertical-label svelte-oau61i");
    			add_location(div3, file$m, 22, 12, 778);
    			attr_dev(div4, "class", "vertical-label-container svelte-oau61i");
    			add_location(div4, file$m, 21, 8, 725);
    			attr_dev(div5, "class", "strip-1b svelte-oau61i");
    			add_location(div5, file$m, 20, 4, 693);
    			attr_dev(div6, "class", "focus-area-container svelte-oau61i");
    			add_location(div6, file$m, 26, 8, 922);
    			attr_dev(div7, "class", "strip-2b svelte-oau61i");
    			add_location(div7, file$m, 25, 4, 890);
    			attr_dev(section, "class", "svelte-oau61i");
    			add_location(section, file$m, 14, 0, 549);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			mount_component(logo, div0, null);
    			append_dev(section, t0);
    			append_dev(section, div1);
    			append_dev(section, t1);
    			append_dev(section, div2);
    			append_dev(section, t2);
    			append_dev(section, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(section, t4);
    			append_dev(section, div7);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*focusAreas, $data, icons, slugify*/ 3) {
    				each_value = /*$data*/ ctx[0].schema.adaptationFocus.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(logo);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Strip', slots, []);
    	let { actionData } = $$props;
    	const focusAreas = [...new Set(actionData['Focus areas'])].map(d => schema.adaptationFocus.data.filter(e => e.recordID === d)[0]["Alias"]);
    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Strip> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(2, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({
    		Logo,
    		schema,
    		icons,
    		slugify,
    		ui,
    		data,
    		actionData,
    		focusAreas,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(2, actionData = $$props.actionData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$data, focusAreas, actionData];
    }

    class Strip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$m, create_fragment$m, safe_not_equal, { actionData: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Strip",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[2] === undefined && !('actionData' in props)) {
    			console.warn("<Strip> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Strip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Strip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/Postcard.svelte generated by Svelte v3.48.0 */
    const file$l = "src/components/byPage/postcards/Postcard.svelte";

    function create_fragment$l(ctx) {
    	let main1;
    	let strip;
    	let t0;
    	let title;
    	let t1;
    	let main0;
    	let t2;
    	let imagehazards;
    	let t3;
    	let info;
    	let main1_transition;
    	let current;

    	strip = new Strip({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	title = new Title({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	main0 = new Main({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	imagehazards = new ImageHazards({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	info = new Info({
    			props: { actionData: /*actionData*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main1 = element("main");
    			create_component(strip.$$.fragment);
    			t0 = space();
    			create_component(title.$$.fragment);
    			t1 = space();
    			create_component(main0.$$.fragment);
    			t2 = space();
    			create_component(imagehazards.$$.fragment);
    			t3 = space();
    			create_component(info.$$.fragment);
    			attr_dev(main1, "class", "postcard svelte-6pifco");
    			add_location(main1, file$l, 12, 0, 407);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main1, anchor);
    			mount_component(strip, main1, null);
    			append_dev(main1, t0);
    			mount_component(title, main1, null);
    			append_dev(main1, t1);
    			mount_component(main0, main1, null);
    			append_dev(main1, t2);
    			mount_component(imagehazards, main1, null);
    			append_dev(main1, t3);
    			mount_component(info, main1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const strip_changes = {};
    			if (dirty & /*actionData*/ 1) strip_changes.actionData = /*actionData*/ ctx[0];
    			strip.$set(strip_changes);
    			const title_changes = {};
    			if (dirty & /*actionData*/ 1) title_changes.actionData = /*actionData*/ ctx[0];
    			title.$set(title_changes);
    			const main0_changes = {};
    			if (dirty & /*actionData*/ 1) main0_changes.actionData = /*actionData*/ ctx[0];
    			main0.$set(main0_changes);
    			const imagehazards_changes = {};
    			if (dirty & /*actionData*/ 1) imagehazards_changes.actionData = /*actionData*/ ctx[0];
    			imagehazards.$set(imagehazards_changes);
    			const info_changes = {};
    			if (dirty & /*actionData*/ 1) info_changes.actionData = /*actionData*/ ctx[0];
    			info.$set(info_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(strip.$$.fragment, local);
    			transition_in(title.$$.fragment, local);
    			transition_in(main0.$$.fragment, local);
    			transition_in(imagehazards.$$.fragment, local);
    			transition_in(info.$$.fragment, local);

    			add_render_callback(() => {
    				if (!main1_transition) main1_transition = create_bidirectional_transition(main1, fade, {}, true);
    				main1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(strip.$$.fragment, local);
    			transition_out(title.$$.fragment, local);
    			transition_out(main0.$$.fragment, local);
    			transition_out(imagehazards.$$.fragment, local);
    			transition_out(info.$$.fragment, local);
    			if (!main1_transition) main1_transition = create_bidirectional_transition(main1, fade, {}, false);
    			main1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main1);
    			destroy_component(strip);
    			destroy_component(title);
    			destroy_component(main0);
    			destroy_component(imagehazards);
    			destroy_component(info);
    			if (detaching && main1_transition) main1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Postcard', slots, []);
    	let { actionData } = $$props;
    	const writable_props = ['actionData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Postcard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Title,
    		Main,
    		ImageHazards,
    		Info,
    		Strip,
    		actionData
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(0, actionData = $$props.actionData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actionData];
    }

    class Postcard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$l, create_fragment$l, safe_not_equal, { actionData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Postcard",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[0] === undefined && !('actionData' in props)) {
    			console.warn("<Postcard> was created without expected prop 'actionData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<Postcard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<Postcard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/postcards/ActionTable.svelte generated by Svelte v3.48.0 */
    const file$k = "src/components/byPage/postcards/ActionTable.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[12] = i;
    	const constants_0 = /*d*/ child_ctx[4]["Project leads"].map(id => /*$data*/ child_ctx[0].stakeholders.filter(e => e.recordID === id)[0].Name);
    	child_ctx[5] = constants_0;
    	const constants_1 = /*d*/ child_ctx[4]["Action type"].map(id => /*$data*/ child_ctx[0].schema.actionTypes.data.filter(e => e.recordID === id)[0].Type)[0];
    	child_ctx[6] = constants_1;
    	const constants_2 = /*d*/ child_ctx[4]["Scale"].map(id => /*$data*/ child_ctx[0].schema.actionScale.data.filter(e => e.recordID === id)[0].Scale)[0];
    	child_ctx[7] = constants_2;
    	const constants_3 = /*d*/ child_ctx[4]["Focus areas"].map(id => /*$data*/ child_ctx[0].schema.adaptationFocus.data.filter(e => e.recordID === id)[0]);
    	child_ctx[8] = constants_3;
    	const constants_4 = /*d*/ child_ctx[4]["Hazard"].map(id => /*$data*/ child_ctx[0].schema.hazards.data.filter(e => e.recordID === id)[0]);
    	child_ctx[9] = constants_4;

    	const constants_5 = /*d*/ child_ctx[4]["Screening outcome"] === "=> No regrets"
    	? "No regrets"
    	: /*d*/ child_ctx[4]["Screening outcome"] === "=> Discard"
    		? "No adaptation benefit"
    		: /*d*/ child_ctx[4]["# Criteria met"] === 2
    			? "High priority"
    			: /*d*/ child_ctx[4]["# Criteria met"] === 1
    				? "Low priority"
    				: "Adaptation benefit uncertain";

    	child_ctx[10] = constants_5;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (55:16) {#each focusAreas as obj}
    function create_each_block_2$1(ctx) {
    	let div1;
    	let svg;
    	let path;
    	let path_d_value;
    	let t0;
    	let div0;
    	let raw_value = /*obj*/ ctx[13].Alias + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			attr_dev(path, "d", path_d_value = icons[slugify(/*obj*/ ctx[13].Alias)]);
    			add_location(path, file$k, 57, 28, 2733);
    			attr_dev(svg, "class", "icon");
    			attr_dev(svg, "viewBox", "-50 -50 100 100");
    			attr_dev(svg, "width", "80%");
    			add_location(svg, file$k, 56, 24, 2647);
    			attr_dev(div0, "class", "icon-label svelte-16qh7xx");
    			add_location(div0, file$k, 59, 24, 2828);
    			attr_dev(div1, "class", "icon-container svelte-16qh7xx");
    			add_location(div1, file$k, 55, 20, 2593);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1 && path_d_value !== (path_d_value = icons[slugify(/*obj*/ ctx[13].Alias)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 1 && raw_value !== (raw_value = /*obj*/ ctx[13].Alias + "")) div0.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(55:16) {#each focusAreas as obj}",
    		ctx
    	});

    	return block;
    }

    // (67:16) {#each hazards as obj}
    function create_each_block_1$5(ctx) {
    	let div1;
    	let svg;
    	let path;
    	let path_d_value;
    	let t0;
    	let div0;
    	let raw_value = /*obj*/ ctx[13].Hazard + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			attr_dev(path, "d", path_d_value = icons[slugify(/*obj*/ ctx[13].Hazard)]);
    			add_location(path, file$k, 69, 28, 3254);
    			attr_dev(svg, "class", "icon");
    			attr_dev(svg, "viewBox", "-50 -50 100 100");
    			attr_dev(svg, "width", "80%");
    			add_location(svg, file$k, 68, 24, 3168);
    			attr_dev(div0, "class", "icon-label svelte-16qh7xx");
    			add_location(div0, file$k, 71, 24, 3350);
    			attr_dev(div1, "class", "icon-container svelte-16qh7xx");
    			add_location(div1, file$k, 67, 20, 3114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1 && path_d_value !== (path_d_value = icons[slugify(/*obj*/ ctx[13].Hazard)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 1 && raw_value !== (raw_value = /*obj*/ ctx[13].Hazard + "")) div0.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(67:16) {#each hazards as obj}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#each $data.actions as d, i}
    function create_each_block$c(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*d*/ ctx[4].Name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*leads*/ ctx[5].join(', ') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*d*/ ctx[4].Status + "";
    	let t4;
    	let t5;
    	let td3;
    	let div1;
    	let svg;
    	let path;
    	let path_d_value;
    	let t6;
    	let div0;
    	let raw_value = /*scale*/ ctx[7] + "";
    	let t7;
    	let td4;
    	let t8_value = /*type*/ ctx[6] + "";
    	let t8;
    	let t9;
    	let td5;
    	let div2;
    	let t10;
    	let td6;
    	let div3;
    	let t11;
    	let td7;
    	let t12_value = /*tier*/ ctx[10] + "";
    	let t12;
    	let t13;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*focusAreas*/ ctx[8];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*hazards*/ ctx[9];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*d*/ ctx[4]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			div1 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t6 = space();
    			div0 = element("div");
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t10 = space();
    			td6 = element("td");
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t11 = space();
    			td7 = element("td");
    			t12 = text$1(t12_value);
    			t13 = space();
    			attr_dev(td0, "class", "name svelte-16qh7xx");
    			add_location(td0, file$k, 40, 12, 1917);
    			attr_dev(td1, "class", "leads svelte-16qh7xx");
    			add_location(td1, file$k, 41, 12, 1962);
    			attr_dev(td2, "class", "status svelte-16qh7xx");
    			add_location(td2, file$k, 42, 12, 2018);
    			attr_dev(path, "d", path_d_value = mapIcons[/*scale*/ ctx[7]]);
    			add_location(path, file$k, 46, 24, 2236);
    			attr_dev(svg, "class", "icon");
    			attr_dev(svg, "viewBox", "-50 -50 100 100");
    			attr_dev(svg, "width", "80%");
    			add_location(svg, file$k, 45, 20, 2154);
    			attr_dev(div0, "class", "icon-label svelte-16qh7xx");
    			add_location(div0, file$k, 48, 20, 2313);
    			attr_dev(div1, "class", "icon-container svelte-16qh7xx");
    			add_location(div1, file$k, 44, 16, 2104);
    			attr_dev(td3, "class", "scale svelte-16qh7xx");
    			add_location(td3, file$k, 43, 12, 2067);
    			attr_dev(td4, "class", "type svelte-16qh7xx");
    			add_location(td4, file$k, 51, 12, 2411);
    			attr_dev(div2, "class", "icon-cell-container svelte-16qh7xx");
    			add_location(div2, file$k, 53, 16, 2496);
    			attr_dev(td5, "class", "focusAreas svelte-16qh7xx");
    			add_location(td5, file$k, 52, 12, 2454);
    			attr_dev(div3, "class", "icon-cell-container svelte-16qh7xx");
    			add_location(div3, file$k, 65, 16, 3020);
    			attr_dev(td6, "class", "hazards svelte-16qh7xx");
    			add_location(td6, file$k, 64, 12, 2981);
    			attr_dev(td7, "class", "assessment svelte-16qh7xx");
    			add_location(td7, file$k, 76, 12, 3504);
    			attr_dev(tr, "class", "action-row svelte-16qh7xx");
    			add_location(tr, file$k, 39, 8, 1847);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, div1);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div1, t6);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(tr, t10);
    			append_dev(tr, td6);
    			append_dev(td6, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(tr, t11);
    			append_dev(tr, td7);
    			append_dev(td7, t12);
    			append_dev(tr, t13);

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$data*/ 1 && t0_value !== (t0_value = /*d*/ ctx[4].Name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$data*/ 1 && t2_value !== (t2_value = /*leads*/ ctx[5].join(', ') + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$data*/ 1 && t4_value !== (t4_value = /*d*/ ctx[4].Status + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$data*/ 1 && path_d_value !== (path_d_value = mapIcons[/*scale*/ ctx[7]])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 1 && raw_value !== (raw_value = /*scale*/ ctx[7] + "")) div0.innerHTML = raw_value;			if (dirty & /*$data*/ 1 && t8_value !== (t8_value = /*type*/ ctx[6] + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*$data, icons, slugify*/ 1) {
    				each_value_2 = /*focusAreas*/ ctx[8];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty & /*$data, icons, slugify*/ 1) {
    				each_value_1 = /*hazards*/ ctx[9];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*$data*/ 1 && t12_value !== (t12_value = /*tier*/ ctx[10] + "")) set_data_dev(t12, t12_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(29:4) {#each $data.actions as d, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let th7;
    	let t15;
    	let each_value = /*$data*/ ctx[0].actions;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Action name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Lead(s)";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Status";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Scale";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Type";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Focus areas";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Hazards";
    			t13 = space();
    			th7 = element("th");
    			th7.textContent = "Assessment";
    			t15 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "name svelte-16qh7xx");
    			add_location(th0, file$k, 17, 12, 485);
    			attr_dev(th1, "class", "leads svelte-16qh7xx");
    			add_location(th1, file$k, 18, 12, 533);
    			attr_dev(th2, "class", "status svelte-16qh7xx");
    			add_location(th2, file$k, 19, 12, 578);
    			attr_dev(th3, "class", "scale svelte-16qh7xx");
    			add_location(th3, file$k, 20, 12, 623);
    			attr_dev(th4, "class", "type svelte-16qh7xx");
    			add_location(th4, file$k, 21, 12, 666);
    			attr_dev(th5, "class", "focusAreas svelte-16qh7xx");
    			add_location(th5, file$k, 22, 12, 707);
    			attr_dev(th6, "class", "hazards svelte-16qh7xx");
    			add_location(th6, file$k, 23, 12, 761);
    			attr_dev(th7, "class", "assessment svelte-16qh7xx");
    			add_location(th7, file$k, 24, 12, 808);
    			attr_dev(tr, "class", "svelte-16qh7xx");
    			add_location(tr, file$k, 16, 8, 468);
    			attr_dev(thead, "class", "svelte-16qh7xx");
    			add_location(thead, file$k, 15, 4, 452);
    			attr_dev(table, "class", "svelte-16qh7xx");
    			add_location(table, file$k, 14, 0, 440);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(tr, t13);
    			append_dev(tr, th7);
    			append_dev(table, t15);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*openPostcard, $data, icons, slugify, mapIcons*/ 3) {
    				each_value = /*$data*/ ctx[0].actions;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(3, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ActionTable', slots, []);

    	function openPostcard(actionData) {
    		set_store_value(ui, $ui.state.postcards.view = 'postcard', $ui);
    		set_store_value(ui, $ui.state.postcards.selectedAction = actionData, $ui);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ActionTable> was created with unknown prop '${key}'`);
    	});

    	const click_handler = d => openPostcard(d);

    	$$self.$capture_state = () => ({
    		ui,
    		data,
    		icons,
    		mapIcons,
    		slugify,
    		fade,
    		openPostcard,
    		$ui,
    		$data
    	});

    	return [$data, openPostcard, click_handler];
    }

    class ActionTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ActionTable",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/pages/Postcards.svelte generated by Svelte v3.48.0 */
    const file$j = "src/pages/Postcards.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (16:0) {:else}
    function create_else_block$1(ctx) {
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let logo;
    	let t0;
    	let h1;
    	let span0;
    	let br0;
    	let t2;
    	let br1;
    	let t3;
    	let span1;
    	let t5;
    	let div2;
    	let p;
    	let t6;
    	let em;
    	let t8;
    	let t9;
    	let div3;
    	let ul;
    	let li0;
    	let t11;
    	let li1;
    	let div5_transition;
    	let t13;
    	let div14;
    	let section;
    	let div13;
    	let h2;
    	let t15;
    	let div9;
    	let div6;
    	let t17;
    	let div7;
    	let t19;
    	let div8;
    	let t21;
    	let div12;
    	let h3;
    	let t23;
    	let div10;
    	let t25;
    	let div11;
    	let t27;
    	let current_block_type_index;
    	let if_block;
    	let div14_transition;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ $$inline: true });
    	const if_block_creators = [create_if_block_1$5, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$ui*/ ctx[0].state.postcards.view === 'all') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			span0 = element("span");
    			span0.textContent = "hepburn";
    			br0 = element("br");
    			t2 = text$1("\n                adaptation action");
    			br1 = element("br");
    			t3 = space();
    			span1 = element("span");
    			span1.textContent = "postcards";
    			t5 = space();
    			div2 = element("div");
    			p = element("p");
    			t6 = text$1("This section provides access to a set of summary 'postcards' for ");
    			em = element("em");
    			em.textContent = "every";
    			t8 = text$1(" adaptation considered in this research. These postcards provide descriptions and details about each action; and can be added to via the Hepburn Z-NET adaptation action database.");
    			t9 = space();
    			div3 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "Action menu";
    			t11 = space();
    			li1 = element("li");
    			li1.textContent = "Postcard gallery";
    			t13 = space();
    			div14 = element("div");
    			section = element("section");
    			div13 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Options for viewing creating adaptation action postcards";
    			t15 = space();
    			div9 = element("div");
    			div6 = element("div");
    			div6.textContent = "Select an action from a list";
    			t17 = space();
    			div7 = element("div");
    			div7.textContent = "Select an action from table";
    			t19 = space();
    			div8 = element("div");
    			div8.textContent = "Select an action from table";
    			t21 = space();
    			div12 = element("div");
    			h3 = element("h3");
    			h3.textContent = "Postcard styling options";
    			t23 = space();
    			div10 = element("div");
    			div10.textContent = "Color palette options";
    			t25 = space();
    			div11 = element("div");
    			div11.textContent = "Image style options";
    			t27 = space();
    			if_block.c();
    			attr_dev(div0, "class", "hero-logo__wrapper svelte-h0w60z");
    			add_location(div0, file$j, 21, 16, 844);
    			attr_dev(div1, "class", "hero-logo svelte-h0w60z");
    			add_location(div1, file$j, 20, 12, 804);
    			attr_dev(span0, "class", "title--mute svelte-h0w60z");
    			add_location(span0, file$j, 24, 16, 970);
    			add_location(br0, file$j, 24, 58, 1012);
    			add_location(br1, file$j, 25, 33, 1051);
    			attr_dev(span1, "class", "title--highlight svelte-h0w60z");
    			add_location(span1, file$j, 26, 16, 1073);
    			attr_dev(h1, "class", "hero-content__title svelte-h0w60z");
    			add_location(h1, file$j, 23, 12, 921);
    			add_location(em, file$j, 29, 84, 1270);
    			add_location(p, file$j, 29, 16, 1202);
    			attr_dev(div2, "class", "hero-content__text svelte-h0w60z");
    			add_location(div2, file$j, 28, 12, 1153);
    			attr_dev(li0, "class", "select__item svelte-h0w60z");
    			add_location(li0, file$j, 34, 20, 1579);
    			attr_dev(li1, "class", "select__item svelte-h0w60z");
    			add_location(li1, file$j, 35, 20, 1664);
    			add_location(ul, file$j, 33, 16, 1554);
    			attr_dev(div3, "class", "select svelte-h0w60z");
    			add_location(div3, file$j, 32, 12, 1516);
    			attr_dev(div4, "class", "hero-content svelte-h0w60z");
    			add_location(div4, file$j, 18, 8, 726);
    			attr_dev(div5, "class", "hero-wrapper svelte-h0w60z");
    			add_location(div5, file$j, 17, 4, 673);
    			add_location(h2, file$j, 45, 16, 1978);
    			add_location(div6, file$j, 47, 20, 2086);
    			add_location(div7, file$j, 48, 20, 2146);
    			add_location(div8, file$j, 49, 20, 2205);
    			add_location(div9, file$j, 46, 16, 2060);
    			add_location(h3, file$j, 52, 20, 2309);
    			add_location(div10, file$j, 53, 20, 2363);
    			add_location(div11, file$j, 54, 20, 2416);
    			add_location(div12, file$j, 51, 16, 2283);
    			add_location(div13, file$j, 44, 12, 1956);
    			attr_dev(section, "class", "option-container col-1-2 svelte-h0w60z");
    			add_location(section, file$j, 43, 8, 1899);
    			attr_dev(div14, "class", "content-wrapper svelte-h0w60z");
    			add_location(div14, file$j, 42, 4, 1843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			mount_component(logo, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, h1);
    			append_dev(h1, span0);
    			append_dev(h1, br0);
    			append_dev(h1, t2);
    			append_dev(h1, br1);
    			append_dev(h1, t3);
    			append_dev(h1, span1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div2, p);
    			append_dev(p, t6);
    			append_dev(p, em);
    			append_dev(p, t8);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, ul);
    			append_dev(ul, li0);
    			append_dev(ul, t11);
    			append_dev(ul, li1);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, section);
    			append_dev(section, div13);
    			append_dev(div13, h2);
    			append_dev(div13, t15);
    			append_dev(div13, div9);
    			append_dev(div9, div6);
    			append_dev(div9, t17);
    			append_dev(div9, div7);
    			append_dev(div9, t19);
    			append_dev(div9, div8);
    			append_dev(div13, t21);
    			append_dev(div13, div12);
    			append_dev(div12, h3);
    			append_dev(div12, t23);
    			append_dev(div12, div10);
    			append_dev(div12, t25);
    			append_dev(div12, div11);
    			append_dev(div14, t27);
    			if_blocks[current_block_type_index].m(div14, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*showTable*/ ctx[2], false, false, false),
    					listen_dev(li1, "click", /*showPostcards*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div14, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div5_transition) div5_transition = create_bidirectional_transition(div5, fade, {}, true);
    				div5_transition.run(1);
    			});

    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!div14_transition) div14_transition = create_bidirectional_transition(div14, fade, {}, true);
    				div14_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			if (!div5_transition) div5_transition = create_bidirectional_transition(div5, fade, {}, false);
    			div5_transition.run(0);
    			transition_out(if_block);
    			if (!div14_transition) div14_transition = create_bidirectional_transition(div14, fade, {}, false);
    			div14_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(logo);
    			if (detaching && div5_transition) div5_transition.end();
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(div14);
    			if_blocks[current_block_type_index].d();
    			if (detaching && div14_transition) div14_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(16:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:0) {#if $ui.state.postcards.view === 'postcard'}
    function create_if_block$7(ctx) {
    	let postcard;
    	let current;

    	postcard = new Postcard({
    			props: {
    				actionData: /*$ui*/ ctx[0].state.postcards.selectedAction
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(postcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(postcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const postcard_changes = {};
    			if (dirty & /*$ui*/ 1) postcard_changes.actionData = /*$ui*/ ctx[0].state.postcards.selectedAction;
    			postcard.$set(postcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(postcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(postcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(postcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(14:0) {#if $ui.state.postcards.view === 'postcard'}",
    		ctx
    	});

    	return block;
    }

    // (66:8) {:else}
    function create_else_block_1(ctx) {
    	let section;
    	let h2;
    	let t1;
    	let p;
    	let em;
    	let t3;
    	let actiontable;
    	let section_transition;
    	let current;
    	actiontable = new ActionTable({ $$inline: true });

    	const block = {
    		c: function create() {
    			section = element("section");
    			h2 = element("h2");
    			h2.textContent = "Table of adaptation actions";
    			t1 = space();
    			p = element("p");
    			em = element("em");
    			em.textContent = "Tap on any action to open its summary postcard";
    			t3 = space();
    			create_component(actiontable.$$.fragment);
    			add_location(h2, file$j, 67, 12, 2838);
    			add_location(em, file$j, 68, 31, 2907);
    			attr_dev(p, "class", "notes svelte-h0w60z");
    			add_location(p, file$j, 68, 12, 2888);
    			attr_dev(section, "class", "table-container svelte-h0w60z");
    			add_location(section, file$j, 66, 8, 2774);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, h2);
    			append_dev(section, t1);
    			append_dev(section, p);
    			append_dev(p, em);
    			append_dev(section, t3);
    			mount_component(actiontable, section, null);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actiontable.$$.fragment, local);

    			add_render_callback(() => {
    				if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, true);
    				section_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actiontable.$$.fragment, local);
    			if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, false);
    			section_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(actiontable);
    			if (detaching && section_transition) section_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(66:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:8) {#if $ui.state.postcards.view === 'all'}
    function create_if_block_1$5(ctx) {
    	let section;
    	let section_transition;
    	let current;
    	let each_value = /*$data*/ ctx[1].actions;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(section, "class", "postcards-container");
    			add_location(section, file$j, 60, 8, 2566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2) {
    				each_value = /*$data*/ ctx[1].actions;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(section, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, true);
    				section_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, false);
    			section_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_each(each_blocks, detaching);
    			if (detaching && section_transition) section_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(60:8) {#if $ui.state.postcards.view === 'all'}",
    		ctx
    	});

    	return block;
    }

    // (62:12) {#each $data.actions as action }
    function create_each_block$b(ctx) {
    	let postcard;
    	let current;

    	postcard = new Postcard({
    			props: { actionData: /*action*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(postcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(postcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const postcard_changes = {};
    			if (dirty & /*$data*/ 2) postcard_changes.actionData = /*action*/ ctx[4];
    			postcard.$set(postcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(postcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(postcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(postcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(62:12) {#each $data.actions as action }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$ui*/ ctx[0].state.postcards.view === 'postcard') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(0, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Postcards', slots, []);
    	const showTable = () => set_store_value(ui, $ui.state.postcards.view = 'table', $ui);
    	const showPostcards = () => set_store_value(ui, $ui.state.postcards.view = 'all', $ui);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Postcards> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		Logo,
    		Postcard,
    		ActionTable,
    		data,
    		ui,
    		showTable,
    		showPostcards,
    		$ui,
    		$data
    	});

    	return [$ui, $data, showTable, showPostcards];
    }

    class Postcards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Postcards",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/components/byPage/actions/vis/Type.svelte generated by Svelte v3.48.0 */
    const file$i = "src/components/byPage/actions/vis/Type.svelte";

    function create_fragment$i(ctx) {
    	let g7;
    	let g2;
    	let g0;
    	let text0;
    	let tspan0;
    	let t0;
    	let t1;
    	let text1;
    	let t2;
    	let g1;
    	let text2;
    	let tspan1;
    	let t3;
    	let t4;
    	let text3;
    	let t5;
    	let g6;
    	let g3;
    	let g4;
    	let g5;
    	let g7_intro;

    	const block = {
    		c: function create() {
    			g7 = svg_element("g");
    			g2 = svg_element("g");
    			g0 = svg_element("g");
    			text0 = svg_element("text");
    			tspan0 = svg_element("tspan");
    			t0 = text$1("More");
    			t1 = text$1(" Abstract");
    			text1 = svg_element("text");
    			t2 = text$1("Builds capacity");
    			g1 = svg_element("g");
    			text2 = svg_element("text");
    			tspan1 = svg_element("tspan");
    			t3 = text$1("More");
    			t4 = text$1(" Concrete");
    			text3 = svg_element("text");
    			t5 = text$1("Responds to risk");
    			g6 = svg_element("g");
    			g3 = svg_element("g");
    			g4 = svg_element("g");
    			g5 = svg_element("g");
    			attr_dev(tspan0, "class", "svelte-8cg3va");
    			toggle_class(tspan0, "none", /*$ui*/ ctx[1].state.actionVis.scene !== 3);
    			add_location(tspan0, file$i, 82, 103, 4138);
    			attr_dev(text0, "class", "spectrum-label abstract svelte-8cg3va");
    			toggle_class(text0, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			add_location(text0, file$i, 82, 12, 4047);
    			attr_dev(text1, "class", "spectrum-sub-label svelte-8cg3va");
    			attr_dev(text1, "dy", "35");
    			toggle_class(text1, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			add_location(text1, file$i, 83, 12, 4234);

    			set_style(g0, "transform", "translate(" + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    			? 0
    			: /*dims*/ ctx[0].width * 0.5) + "px, " + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    			? /*dims*/ ctx[0].height * 0.05
    			: /*dims*/ ctx[0].height * 0.025) + "px)");

    			add_location(g0, file$i, 81, 8, 3865);
    			attr_dev(tspan1, "class", "svelte-8cg3va");
    			toggle_class(tspan1, "none", /*$ui*/ ctx[1].state.actionVis.scene !== 3);
    			add_location(tspan1, file$i, 86, 103, 4645);
    			attr_dev(text2, "class", "spectrum-label concrete svelte-8cg3va");
    			toggle_class(text2, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			add_location(text2, file$i, 86, 12, 4554);
    			attr_dev(text3, "class", "spectrum-sub-label svelte-8cg3va");
    			attr_dev(text3, "dy", "35");
    			toggle_class(text3, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			add_location(text3, file$i, 87, 12, 4741);

    			set_style(g1, "transform", "translate(" + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    			? 0
    			: /*dims*/ ctx[0].width * 0.5) + "px, " + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    			? /*dims*/ ctx[0].height * 0.65
    			: /*dims*/ ctx[0].height * 0.85) + "px)");

    			add_location(g1, file$i, 85, 8, 4373);
    			attr_dev(g2, "class", "spectrum-group svelte-8cg3va");
    			add_location(g2, file$i, 80, 4, 3828);
    			attr_dev(g3, "class", "connector-container");
    			add_location(g3, file$i, 91, 8, 5025);
    			attr_dev(g4, "class", "action-type-node-container");
    			add_location(g4, file$i, 92, 8, 5071);
    			attr_dev(g5, "class", "outcomes-label-container");
    			add_location(g5, file$i, 93, 8, 5124);
    			attr_dev(g6, "class", "flow-diagram svelte-8cg3va");
    			set_style(g6, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, 0px)");
    			toggle_class(g6, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			add_location(g6, file$i, 90, 4, 4886);
    			attr_dev(g7, "id", "type-vis-container");
    			add_location(g7, file$i, 79, 0, 3787);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g7, anchor);
    			append_dev(g7, g2);
    			append_dev(g2, g0);
    			append_dev(g0, text0);
    			append_dev(text0, tspan0);
    			append_dev(tspan0, t0);
    			append_dev(text0, t1);
    			append_dev(g0, text1);
    			append_dev(text1, t2);
    			append_dev(g2, g1);
    			append_dev(g1, text2);
    			append_dev(text2, tspan1);
    			append_dev(tspan1, t3);
    			append_dev(text2, t4);
    			append_dev(g1, text3);
    			append_dev(text3, t5);
    			append_dev(g7, g6);
    			append_dev(g6, g3);
    			append_dev(g6, g4);
    			append_dev(g6, g5);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$ui*/ 2) {
    				toggle_class(tspan0, "none", /*$ui*/ ctx[1].state.actionVis.scene !== 3);
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(text0, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(text1, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			}

    			if (dirty & /*$ui, dims*/ 3) {
    				set_style(g0, "transform", "translate(" + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    				? 0
    				: /*dims*/ ctx[0].width * 0.5) + "px, " + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    				? /*dims*/ ctx[0].height * 0.05
    				: /*dims*/ ctx[0].height * 0.025) + "px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(tspan1, "none", /*$ui*/ ctx[1].state.actionVis.scene !== 3);
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(text2, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(text3, "centered", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			}

    			if (dirty & /*$ui, dims*/ 3) {
    				set_style(g1, "transform", "translate(" + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    				? 0
    				: /*dims*/ ctx[0].width * 0.5) + "px, " + (/*$ui*/ ctx[1].state.actionVis.scene !== 3
    				? /*dims*/ ctx[0].height * 0.65
    				: /*dims*/ ctx[0].height * 0.85) + "px)");
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g6, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, 0px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g6, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 3);
    			}
    		},
    		i: function intro(local) {
    			if (!g7_intro) {
    				add_render_callback(() => {
    					g7_intro = create_in_transition(g7, fade, {});
    					g7_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $data;
    	let $ui;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(3, $data = $$value));
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(1, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Type', slots, []);
    	let { dims = { width: 1600, height: 1600 } } = $$props;

    	let { typeData = {
    		nodes: $data.schema.actionTypeNodes.data,
    		links: $data.schema.actionTypeLinks.data
    	} } = $$props;

    	// Drawn on mount to allow for calling of text wrapping
    	onMount(() => {
    		const connectors = select('.connector-container'),
    			actionTypeNodes = select('.action-type-node-container');
    			select('.outcomes-label-container');

    		// Action type nodes
    		actionTypeNodes.selectAll('.action-type-node').data(typeData.nodes).join(enter => {
    			const group = enter.append('g').attr("class", d => slugify(d.Class)).style('transform', d => `translate( ${d.xPos * 0.5 * dims.width}px, ${d.yPos * dims.height}px`);
    			const bg = group.append('rect').style('fill', 'var(--bg-color)').style('stroke', d => d.Class === 'foundation' ? 'var(--lightGreen)' : 'none').style('stroke-width', '2px').style('border-radius', '3px').style('rx', '5px').style('ry', '5px');

    			group.append('path').classed('flow', true).style('transform', d => d.nodeCurve !== "invert"
    			? `translate(0px, ${d.curveYoffset}px)`
    			: `translate(0px, ${d.curveYoffset - 20}px) scaleY(-1)`).attr('d', d => d.Class === 'type'
    			? "M -100 10 C -30 50, 30 50, 100 10"
    			: null).classed('remove', d => d.Class !== 'type').style('fill', 'var(--bg-color');

    			let text;
    			text = group.append('text').classed(`action-node-label `, true).attr('x', 0).attr('y', 5).attr('dy', 0).text(d => d.Name).classed(d => d.Class, true).call(textWrap, dims.width * 0.2, 1.1, true);
    			let box = text.node().getBBox();
    			bg.attr('width', d => d.Class === 'foundation' ? box.width + 80 : 180);

    			bg.attr('height', d => d.Class === 'foundation' || d.Class === 'response'
    			? box.height + 50
    			: 70);

    			bg.attr('x', d => d.Class === 'foundation' ? -box.width * 0.5 - 40 : -90);

    			bg.attr('y', d => d.Class === 'foundation' || d.Class === 'response'
    			? -box.height * 0.5 - 30
    			: -35);
    		});

    		// Links 
    		for (const link of typeData.links) {
    			const source = typeData.nodes.filter(e => e.Name === link._source.replaceAll('\"', ''))[0];
    			const target = typeData.nodes.filter(e => e.Name === link._target.replaceAll('\"', ''))[0];

    			connectors.append('path').classed('flow', true).attr('d', typeof link.midX !== 'undefined'
    			? `M${source.xPos * 0.5 * dims.width}, ${source.yPos * dims.height} 
                    L${link.midX * 0.5 * dims.width}, ${link.midY * dims.height} 
                    L${target.xPos * 0.5 * dims.width}, ${target.yPos * dims.height}`
    			: `M${source.xPos * 0.5 * dims.width}, ${source.yPos * dims.height} 
                        L${target.xPos * 0.5 * dims.width}, ${target.yPos * dims.height}`);
    		}
    	});

    	const writable_props = ['dims', 'typeData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Type> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('typeData' in $$props) $$invalidate(2, typeData = $$props.typeData);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		scale,
    		onMount,
    		d3,
    		textWrap,
    		slugify,
    		ui,
    		data,
    		dims,
    		typeData,
    		$data,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('typeData' in $$props) $$invalidate(2, typeData = $$props.typeData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $ui, typeData];
    }

    class Type extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, { dims: 0, typeData: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Type",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get dims() {
    		throw new Error("<Type>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Type>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get typeData() {
    		throw new Error("<Type>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set typeData(value) {
    		throw new Error("<Type>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/adaptation/vis/ClimateVariables.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1 } = globals;
    const file$h = "src/components/byPage/adaptation/vis/ClimateVariables.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[8] = i;
    	const constants_0 = /*$data*/ child_ctx[1].climate.variables.projectedChange["RCP4.5"].Annual[/*d*/ child_ctx[9].Variable];
    	child_ctx[10] = constants_0;
    	const constants_1 = /*$data*/ child_ctx[1].climate.variables.projectedChange["RCP8.5"].Annual[/*d*/ child_ctx[9].Variable];
    	child_ctx[11] = constants_1;
    	const constants_2 = /*$data*/ child_ctx[1].schema.climateVariables.data.filter(e => e.Variable === /*d*/ child_ctx[9].Variable)[0]["Change unit"];
    	child_ctx[12] = constants_2;

    	const constants_3 = /*$data*/ child_ctx[1].climate.variables.projectedChange["RCP8.5"].Annual[/*d*/ child_ctx[9].Variable]
    	? max$3([
    			/*$data*/ child_ctx[1].climate.variables.projectedChange["RCP8.5"].Annual[/*d*/ child_ctx[9].Variable].Upper["2090"],
    			/*$data*/ child_ctx[1].climate.variables.projectedChange["RCP4.5"].Annual[/*d*/ child_ctx[9].Variable].Upper["2090"]
    		])
    	: 0;

    	child_ctx[13] = constants_3;

    	const constants_4 = /*$data*/ child_ctx[1].climate.variables.projectedChange["RCP8.5"].Annual[/*d*/ child_ctx[9].Variable]
    	? min$2([
    			/*$data*/ child_ctx[1].climate.variables.projectedChange["RCP8.5"].Annual[/*d*/ child_ctx[9].Variable].Lower["2090"],
    			/*$data*/ child_ctx[1].climate.variables.projectedChange["RCP4.5"].Annual[/*d*/ child_ctx[9].Variable].Lower["2090"]
    		])
    	: 0;

    	child_ctx[14] = constants_4;
    	const constants_5 = /*getScaleY*/ child_ctx[4](/*d*/ child_ctx[9].Variable);
    	child_ctx[15] = constants_5;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	const constants_0 = /*$data*/ child_ctx[1].schema.hazards.data.filter(d => d.recordID === /*recordID*/ child_ctx[22])[0].Hazard;
    	child_ctx[23] = constants_0;

    	const constants_1 = {
    		x: /*dims*/ child_ctx[0].width * 0.67 - 50,
    		y: /*dims*/ child_ctx[0].variableSpacing * /*i*/ child_ctx[8] + /*dims*/ child_ctx[0].height * 0.25
    	};

    	child_ctx[24] = constants_1;

    	const constants_2 = {
    		x: /*dims*/ child_ctx[0].width * 0.85,
    		y: /*$data*/ child_ctx[1].schema.hazards.data.map(d => d.Hazard).indexOf(/*hazard*/ child_ctx[23]) / /*$data*/ child_ctx[1].schema.hazards.data.length * /*dims*/ child_ctx[0].height * 0.7 + /*dims*/ child_ctx[0].height * 0.3
    	};

    	child_ctx[25] = constants_2;
    	return child_ctx;
    }

    // (130:16) {#if nodeObj["Linked hazards"] }
    function create_if_block_2$4(ctx) {
    	let each_1_anchor;
    	let each_value_4 = /*nodeObj*/ ctx[20]["Linked hazards"];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*d3, dims, $data*/ 3) {
    				each_value_4 = /*nodeObj*/ ctx[20]["Linked hazards"];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(130:16) {#if nodeObj[\\\"Linked hazards\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (131:20) {#each nodeObj["Linked hazards"] as recordID}
    function create_each_block_4(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "gridline svelte-12ipaly");

    			attr_dev(path, "d", path_d_value = linkHorizontal()({
    				source: [/*sourcePos*/ ctx[24].x, /*sourcePos*/ ctx[24].y],
    				target: [/*targetPos*/ ctx[25].x, /*targetPos*/ ctx[25].y]
    			}));

    			add_location(path, file$h, 142, 24, 6904);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims, $data*/ 3 && path_d_value !== (path_d_value = linkHorizontal()({
    				source: [/*sourcePos*/ ctx[24].x, /*sourcePos*/ ctx[24].y],
    				target: [/*targetPos*/ ctx[25].x, /*targetPos*/ ctx[25].y]
    			}))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(131:20) {#each nodeObj[\\\"Linked hazards\\\"] as recordID}",
    		ctx
    	});

    	return block;
    }

    // (129:12) {#each $data.schema.climateVariables.data as nodeObj, i }
    function create_each_block_3(ctx) {
    	let if_block_anchor;
    	let if_block = /*nodeObj*/ ctx[20]["Linked hazards"] && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*nodeObj*/ ctx[20]["Linked hazards"]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(129:12) {#each $data.schema.climateVariables.data as nodeObj, i }",
    		ctx
    	});

    	return block;
    }

    // (153:12) {#each [2019, 2030, 2050, 2070, 2090] as year}
    function create_each_block_2(ctx) {
    	let g;
    	let path;
    	let path_d_value;
    	let text0;
    	let text1;
    	let text1_y_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			path = svg_element("path");
    			text0 = svg_element("text");
    			text1 = svg_element("text");
    			attr_dev(path, "class", "gridline time svelte-12ipaly");
    			attr_dev(path, "d", path_d_value = "M" + /*scaleX*/ ctx[3](/*year*/ ctx[17]) + ", " + (-/*chartDims*/ ctx[2].height - 10) + " V" + /*dims*/ ctx[0].height * 0.715);
    			add_location(path, file$h, 154, 20, 7474);
    			attr_dev(text0, "class", "label-year svelte-12ipaly");
    			attr_dev(text0, "x", /*scaleX*/ ctx[3](/*year*/ ctx[17]));
    			attr_dev(text0, "y", -/*chartDims*/ ctx[2].height - 20);
    			add_location(text0, file$h, 155, 20, 7598);
    			attr_dev(text1, "class", "label-year svelte-12ipaly");
    			attr_dev(text1, "x", /*scaleX*/ ctx[3](/*year*/ ctx[17]));
    			attr_dev(text1, "y", text1_y_value = /*dims*/ ctx[0].height * 0.715 + 15);
    			add_location(text1, file$h, 156, 20, 7711);
    			set_style(g, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, " + 0 + "px)");
    			add_location(g, file$h, 153, 16, 7366);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, path);
    			append_dev(g, text0);
    			text0.innerHTML = /*year*/ ctx[17];
    			append_dev(g, text1);
    			text1.innerHTML = /*year*/ ctx[17];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path_d_value !== (path_d_value = "M" + /*scaleX*/ ctx[3](/*year*/ ctx[17]) + ", " + (-/*chartDims*/ ctx[2].height - 10) + " V" + /*dims*/ ctx[0].height * 0.715)) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*dims*/ 1 && text1_y_value !== (text1_y_value = /*dims*/ ctx[0].height * 0.715 + 15)) {
    				attr_dev(text1, "y", text1_y_value);
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, " + 0 + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(153:12) {#each [2019, 2030, 2050, 2070, 2090] as year}",
    		ctx
    	});

    	return block;
    }

    // (180:32) {#if max > 0}
    function create_if_block_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(180:32) {#if max > 0}",
    		ctx
    	});

    	return block;
    }

    // (183:32) {#if min > 0}
    function create_if_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(183:32) {#if min > 0}",
    		ctx
    	});

    	return block;
    }

    // (162:12) {#each $data.schema.climateVariables.data as d, i}
    function create_each_block_1$4(ctx) {
    	let g2;
    	let path0;
    	let path0_d_value;
    	let text0;
    	let raw_value = /*d*/ ctx[9].Variable + "";
    	let g1;
    	let g0;
    	let path1;
    	let path1_d_value;
    	let path2;
    	let path2_d_value;
    	let text1;
    	let t0_value = /*max*/ ctx[13] + "";
    	let t0;
    	let t1_value = /*chartUnit*/ ctx[12] + "";
    	let t1;
    	let text2;
    	let t2_value = /*min*/ ctx[14] + "";
    	let t2;
    	let t3_value = /*chartUnit*/ ctx[12] + "";
    	let t3;
    	let if_block0 = /*max*/ ctx[13] > 0 && create_if_block_1$4(ctx);
    	let if_block1 = /*min*/ ctx[14] > 0 && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			g2 = svg_element("g");
    			path0 = svg_element("path");
    			text0 = svg_element("text");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			text1 = svg_element("text");
    			if (if_block0) if_block0.c();
    			t0 = text$1(t0_value);
    			t1 = text$1(t1_value);
    			text2 = svg_element("text");
    			if (if_block1) if_block1.c();
    			t2 = text$1(t2_value);
    			t3 = text$1(t3_value);
    			attr_dev(path0, "class", "gridline svelte-12ipaly");
    			attr_dev(path0, "d", path0_d_value = "M" + 50 + ", 0 H" + (/*dims*/ ctx[0].width * 0.67 - 50));
    			add_location(path0, file$h, 170, 20, 9047);
    			attr_dev(text0, "class", "variable-label svelte-12ipaly");
    			set_style(text0, "transform", "translate(" + 50 + "px, " + -10 + "px)");
    			add_location(text0, file$h, 171, 20, 9136);
    			attr_dev(path1, "class", "area-chart rcp-45 svelte-12ipaly");
    			attr_dev(path1, "d", path1_d_value = /*chartPath*/ ctx[5](/*chartData45*/ ctx[10], /*scaleY*/ ctx[15], /*d*/ ctx[9].Variable));
    			add_location(path1, file$h, 176, 28, 9504);
    			attr_dev(path2, "class", "area-chart rcp-85 svelte-12ipaly");
    			attr_dev(path2, "d", path2_d_value = /*chartPath*/ ctx[5](/*chartData85*/ ctx[11], /*scaleY*/ ctx[15], /*d*/ ctx[9].Variable));
    			add_location(path2, file$h, 177, 28, 9619);
    			attr_dev(text1, "class", "unit-label svelte-12ipaly");
    			set_style(text1, "transform", "translate(" + (/*chartDims*/ ctx[2].width + 5) + "px, " + (/*scaleY*/ ctx[15](/*max*/ ctx[13]) + 6) + "px)");
    			add_location(text1, file$h, 178, 28, 9734);
    			attr_dev(text2, "class", "unit-label svelte-12ipaly");
    			set_style(text2, "transform", "translate(" + (/*chartDims*/ ctx[2].width + 5) + "px, " + (/*scaleY*/ ctx[15](/*min*/ ctx[14]) + 6) + "px)");
    			add_location(text2, file$h, 181, 28, 9971);
    			set_style(g0, "transform", "translate(0px, " + -/*scaleY*/ ctx[15](0) + "px)");
    			add_location(g0, file$h, 175, 24, 9420);
    			set_style(g1, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, " + 0 + "px)");
    			add_location(g1, file$h, 174, 20, 9307);
    			set_style(g2, "transform", "translate(" + 0 + "px, " + /*dims*/ ctx[0].variableSpacing * /*i*/ ctx[8] + "px)");
    			add_location(g2, file$h, 169, 16, 8955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g2, anchor);
    			append_dev(g2, path0);
    			append_dev(g2, text0);
    			text0.innerHTML = raw_value;
    			append_dev(g2, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path1);
    			append_dev(g0, path2);
    			append_dev(g0, text1);
    			if (if_block0) if_block0.m(text1, null);
    			append_dev(text1, t0);
    			append_dev(text1, t1);
    			append_dev(g0, text2);
    			if (if_block1) if_block1.m(text2, null);
    			append_dev(text2, t2);
    			append_dev(text2, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path0_d_value !== (path0_d_value = "M" + 50 + ", 0 H" + (/*dims*/ ctx[0].width * 0.67 - 50))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw_value !== (raw_value = /*d*/ ctx[9].Variable + "")) text0.innerHTML = raw_value;
    			if (dirty & /*$data*/ 2 && path1_d_value !== (path1_d_value = /*chartPath*/ ctx[5](/*chartData45*/ ctx[10], /*scaleY*/ ctx[15], /*d*/ ctx[9].Variable))) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*$data*/ 2 && path2_d_value !== (path2_d_value = /*chartPath*/ ctx[5](/*chartData85*/ ctx[11], /*scaleY*/ ctx[15], /*d*/ ctx[9].Variable))) {
    				attr_dev(path2, "d", path2_d_value);
    			}

    			if (/*max*/ ctx[13] > 0) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(text1, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*$data*/ 2 && t0_value !== (t0_value = /*max*/ ctx[13] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$data*/ 2 && t1_value !== (t1_value = /*chartUnit*/ ctx[12] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$data*/ 2) {
    				set_style(text1, "transform", "translate(" + (/*chartDims*/ ctx[2].width + 5) + "px, " + (/*scaleY*/ ctx[15](/*max*/ ctx[13]) + 6) + "px)");
    			}

    			if (/*min*/ ctx[14] > 0) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					if_block1.m(text2, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$data*/ 2 && t2_value !== (t2_value = /*min*/ ctx[14] + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$data*/ 2 && t3_value !== (t3_value = /*chartUnit*/ ctx[12] + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*$data*/ 2) {
    				set_style(text2, "transform", "translate(" + (/*chartDims*/ ctx[2].width + 5) + "px, " + (/*scaleY*/ ctx[15](/*min*/ ctx[14]) + 6) + "px)");
    			}

    			if (dirty & /*$data*/ 2) {
    				set_style(g0, "transform", "translate(0px, " + -/*scaleY*/ ctx[15](0) + "px)");
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g1, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, " + 0 + "px)");
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g2, "transform", "translate(" + 0 + "px, " + /*dims*/ ctx[0].variableSpacing * /*i*/ ctx[8] + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(162:12) {#each $data.schema.climateVariables.data as d, i}",
    		ctx
    	});

    	return block;
    }

    // (192:12) {#each $data.schema.hazards.data as obj , i}
    function create_each_block$a(ctx) {
    	let g;
    	let path;
    	let path_d_value;
    	let text0;
    	let raw0_value = /*obj*/ ctx[6].Hazard + "";
    	let text1;
    	let raw1_value = /*obj*/ ctx[6].Trend + "";

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			path = svg_element("path");
    			text0 = svg_element("text");
    			text1 = svg_element("text");
    			attr_dev(path, "class", "hazard-icon svelte-12ipaly");
    			attr_dev(path, "d", path_d_value = icons[slugify(/*obj*/ ctx[6].Hazard)]);
    			set_style(path, "transform", "translate(0px, -100px) scale(2)");
    			add_location(path, file$h, 194, 16, 10588);
    			attr_dev(text0, "class", "hazard-label svelte-12ipaly");
    			add_location(text0, file$h, 195, 16, 10718);
    			attr_dev(text1, "class", "hazard-trend projection svelte-12ipaly");
    			attr_dev(text1, "y", "35");
    			add_location(text1, file$h, 196, 16, 10789);
    			set_style(g, "transform", "translate(" + /*dims*/ ctx[0].width * 0.825 + "px, " + (/*i*/ ctx[8] / /*$data*/ ctx[1].schema.hazards.data.length * /*dims*/ ctx[0].height * 0.7 + /*dims*/ ctx[0].height * 0.3 + 20) + "px)");
    			add_location(g, file$h, 193, 12, 10426);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, path);
    			append_dev(g, text0);
    			text0.innerHTML = raw0_value;
    			append_dev(g, text1);
    			text1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path_d_value !== (path_d_value = icons[slugify(/*obj*/ ctx[6].Hazard)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw0_value !== (raw0_value = /*obj*/ ctx[6].Hazard + "")) text0.innerHTML = raw0_value;			if (dirty & /*$data*/ 2 && raw1_value !== (raw1_value = /*obj*/ ctx[6].Trend + "")) text1.innerHTML = raw1_value;
    			if (dirty & /*dims, $data*/ 3) {
    				set_style(g, "transform", "translate(" + /*dims*/ ctx[0].width * 0.825 + "px, " + (/*i*/ ctx[8] / /*$data*/ ctx[1].schema.hazards.data.length * /*dims*/ ctx[0].height * 0.7 + /*dims*/ ctx[0].height * 0.3 + 20) + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(192:12) {#each $data.schema.hazards.data as obj , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let figure;
    	let svg;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let rect;
    	let rect_width_value;
    	let rect_height_value;
    	let text0;
    	let t0;
    	let text0_x_value;
    	let text0_y_value;
    	let g3;
    	let g0;
    	let text1;
    	let t1;
    	let text2;
    	let t2;
    	let text3;
    	let t3;
    	let text4;
    	let t4;
    	let g1;
    	let text5;
    	let t5;
    	let text6;
    	let t6;
    	let text7;
    	let tspan0;
    	let t7;
    	let t8;
    	let tspan1;
    	let t9;
    	let t10;
    	let text8;
    	let t11;
    	let g2;
    	let text9;
    	let t12;
    	let text10;
    	let t13;
    	let text11;
    	let t14;
    	let text12;
    	let t15;
    	let g4;
    	let g6;
    	let g5;
    	let g7;
    	let svg_viewBox_value;
    	let each_value_3 = /*$data*/ ctx[1].schema.climateVariables.data;
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_2 = [2019, 2030, 2050, 2070, 2090];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < 5; i += 1) {
    		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*$data*/ ctx[1].schema.climateVariables.data;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	let each_value = /*$data*/ ctx[1].schema.hazards.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			rect = svg_element("rect");
    			text0 = svg_element("text");
    			t0 = text$1("Source: All projection data and variable definitions from CSIRO and the Victorian Government, 2019");
    			g3 = svg_element("g");
    			g0 = svg_element("g");
    			text1 = svg_element("text");
    			t1 = text$1("Climate variables");
    			text2 = svg_element("text");
    			t2 = text$1("Measures of the climate models used in");
    			text3 = svg_element("text");
    			t3 = text$1("the Victorian Climate Projections 2019");
    			text4 = svg_element("text");
    			t4 = text$1("for the Central Highlands region");
    			g1 = svg_element("g");
    			text5 = svg_element("text");
    			t5 = text$1("Projections");
    			text6 = svg_element("text");
    			t6 = text$1("Range of projected change for the ");
    			text7 = svg_element("text");
    			tspan0 = svg_element("tspan");
    			t7 = text$1("RCP 4.5");
    			t8 = text$1(" and ");
    			tspan1 = svg_element("tspan");
    			t9 = text$1("RCP 8.5");
    			t10 = text$1(" scenarios ");
    			text8 = svg_element("text");
    			t11 = text$1("from 2019 (baseline) to 2090 ");
    			g2 = svg_element("g");
    			text9 = svg_element("text");
    			t12 = text$1("Hazards");
    			text10 = svg_element("text");
    			t13 = text$1("How climate variables and trends");
    			text11 = svg_element("text");
    			t14 = text$1("are linked to the climate hazards");
    			text12 = svg_element("text");
    			t15 = text$1("facing Hepburn Shire");
    			g4 = svg_element("g");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			g6 = svg_element("g");

    			for (let i = 0; i < 5; i += 1) {
    				each_blocks_2[i].c();
    			}

    			g5 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g7 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(stop0, "stop-color", "#e21ffc");
    			attr_dev(stop0, "offset", "10%");
    			add_location(stop0, file$h, 97, 16, 4133);
    			attr_dev(stop1, "stop-color", "#00ffff");
    			attr_dev(stop1, "offset", "90%");
    			add_location(stop1, file$h, 98, 16, 4191);
    			attr_dev(linearGradient, "id", "rcp");
    			attr_dev(linearGradient, "x1", "0");
    			attr_dev(linearGradient, "y1", "0");
    			attr_dev(linearGradient, "x2", "100%");
    			attr_dev(linearGradient, "y2", "100%");
    			add_location(linearGradient, file$h, 96, 12, 4057);
    			add_location(defs, file$h, 95, 8, 4038);
    			attr_dev(rect, "class", "bg svelte-12ipaly");
    			attr_dev(rect, "x", "-300");
    			attr_dev(rect, "y", "0");
    			attr_dev(rect, "width", rect_width_value = /*dims*/ ctx[0].width + 600);
    			attr_dev(rect, "height", rect_height_value = /*dims*/ ctx[0].height);
    			add_location(rect, file$h, 103, 8, 4289);
    			attr_dev(text0, "class", "source svelte-12ipaly");
    			attr_dev(text0, "x", text0_x_value = /*dims*/ ctx[0].width - 50);
    			attr_dev(text0, "y", text0_y_value = /*dims*/ ctx[0].height - 50);
    			add_location(text0, file$h, 104, 8, 4385);
    			attr_dev(text1, "class", "header svelte-12ipaly");
    			add_location(text1, file$h, 108, 16, 4693);
    			attr_dev(text2, "class", "sub-header svelte-12ipaly");
    			attr_dev(text2, "y", "40");
    			add_location(text2, file$h, 109, 16, 4758);
    			attr_dev(text3, "class", "sub-header svelte-12ipaly");
    			attr_dev(text3, "y", "70");
    			add_location(text3, file$h, 110, 16, 4854);
    			attr_dev(text4, "class", "sub-header svelte-12ipaly");
    			attr_dev(text4, "y", "100");
    			add_location(text4, file$h, 111, 16, 4950);
    			set_style(g0, "transform", "translate(" + 50 + "px, 0px)");
    			add_location(g0, file$h, 107, 12, 4631);
    			attr_dev(text5, "class", "header projection svelte-12ipaly");
    			add_location(text5, file$h, 114, 16, 5154);
    			attr_dev(text6, "class", "sub-header svelte-12ipaly");
    			attr_dev(text6, "y", "40");
    			add_location(text6, file$h, 115, 16, 5223);
    			attr_dev(tspan0, "class", "rcp-45 svelte-12ipaly");
    			add_location(tspan0, file$h, 116, 50, 5349);
    			attr_dev(tspan1, "class", "rcp-85 svelte-12ipaly");
    			add_location(tspan1, file$h, 116, 92, 5391);
    			attr_dev(text7, "class", "sub-header svelte-12ipaly");
    			attr_dev(text7, "y", "70");
    			add_location(text7, file$h, 116, 16, 5315);
    			attr_dev(text8, "class", "sub-header svelte-12ipaly");
    			attr_dev(text8, "y", "100");
    			add_location(text8, file$h, 117, 16, 5463);
    			set_style(g1, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, 0px)");
    			add_location(g1, file$h, 113, 12, 5054);
    			attr_dev(text9, "class", "header svelte-12ipaly");
    			add_location(text9, file$h, 120, 16, 5642);
    			attr_dev(text10, "class", "sub-header svelte-12ipaly");
    			attr_dev(text10, "y", "40");
    			add_location(text10, file$h, 121, 16, 5696);
    			attr_dev(text11, "class", "sub-header svelte-12ipaly");
    			attr_dev(text11, "y", "70");
    			add_location(text11, file$h, 122, 16, 5786);
    			attr_dev(text12, "class", "sub-header svelte-12ipaly");
    			attr_dev(text12, "y", "100");
    			add_location(text12, file$h, 123, 16, 5877);
    			set_style(g2, "transform", "translate(" + /*dims*/ ctx[0].width * 0.725 + "px, 0px)");
    			add_location(g2, file$h, 119, 12, 5564);
    			set_style(g3, "transform", "translate(" + 0 + "px, " + 100 + "px)");
    			add_location(g3, file$h, 106, 8, 4568);
    			attr_dev(g4, "class", "links-group");
    			add_location(g4, file$h, 127, 8, 5979);
    			attr_dev(g5, "class", "text-wrap-layer");
    			add_location(g5, file$h, 159, 12, 7859);
    			attr_dev(g6, "class", "chart-group");
    			set_style(g6, "transform", "translate(0px, " + /*dims*/ ctx[0].height * 0.25 + "px)");
    			add_location(g6, file$h, 151, 8, 7205);
    			attr_dev(g7, "class", "hazards-group");
    			add_location(g7, file$h, 190, 8, 10316);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "class", "climate-variables-vis svelte-12ipaly");
    			attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + /*dims*/ ctx[0].width + " " + /*dims*/ ctx[0].height);
    			attr_dev(svg, "width", "100%");
    			add_location(svg, file$h, 93, 4, 3836);
    			attr_dev(figure, "class", "svg-container svelte-12ipaly");
    			add_location(figure, file$h, 92, 0, 3799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, svg);
    			append_dev(svg, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(svg, rect);
    			append_dev(svg, text0);
    			append_dev(text0, t0);
    			append_dev(svg, g3);
    			append_dev(g3, g0);
    			append_dev(g0, text1);
    			append_dev(text1, t1);
    			append_dev(g0, text2);
    			append_dev(text2, t2);
    			append_dev(g0, text3);
    			append_dev(text3, t3);
    			append_dev(g0, text4);
    			append_dev(text4, t4);
    			append_dev(g3, g1);
    			append_dev(g1, text5);
    			append_dev(text5, t5);
    			append_dev(g1, text6);
    			append_dev(text6, t6);
    			append_dev(g1, text7);
    			append_dev(text7, tspan0);
    			append_dev(tspan0, t7);
    			append_dev(text7, t8);
    			append_dev(text7, tspan1);
    			append_dev(tspan1, t9);
    			append_dev(text7, t10);
    			append_dev(g1, text8);
    			append_dev(text8, t11);
    			append_dev(g3, g2);
    			append_dev(g2, text9);
    			append_dev(text9, t12);
    			append_dev(g2, text10);
    			append_dev(text10, t13);
    			append_dev(g2, text11);
    			append_dev(text11, t14);
    			append_dev(g2, text12);
    			append_dev(text12, t15);
    			append_dev(svg, g4);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(g4, null);
    			}

    			append_dev(svg, g6);

    			for (let i = 0; i < 5; i += 1) {
    				each_blocks_2[i].m(g6, null);
    			}

    			append_dev(g6, g5);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g6, null);
    			}

    			append_dev(svg, g7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g7, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dims*/ 1 && rect_width_value !== (rect_width_value = /*dims*/ ctx[0].width + 600)) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty & /*dims*/ 1 && rect_height_value !== (rect_height_value = /*dims*/ ctx[0].height)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*dims*/ 1 && text0_x_value !== (text0_x_value = /*dims*/ ctx[0].width - 50)) {
    				attr_dev(text0, "x", text0_x_value);
    			}

    			if (dirty & /*dims*/ 1 && text0_y_value !== (text0_y_value = /*dims*/ ctx[0].height - 50)) {
    				attr_dev(text0, "y", text0_y_value);
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g1, "transform", "translate(" + (/*dims*/ ctx[0].width * 0.5 - /*chartDims*/ ctx[2].width * 0.5) + "px, 0px)");
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g2, "transform", "translate(" + /*dims*/ ctx[0].width * 0.725 + "px, 0px)");
    			}

    			if (dirty & /*$data, d3, dims*/ 3) {
    				each_value_3 = /*$data*/ ctx[1].schema.climateVariables.data;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(g4, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty & /*dims, chartDims, scaleX*/ 13) {
    				each_value_2 = [2019, 2030, 2050, 2070, 2090];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < 5; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(g6, g5);
    					}
    				}

    				for (; i < 5; i += 1) {
    					each_blocks_2[i].d(1);
    				}
    			}

    			if (dirty & /*dims, chartDims, getScaleY, $data, d3, chartPath*/ 55) {
    				each_value_1 = /*$data*/ ctx[1].schema.climateVariables.data;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$4(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g6, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g6, "transform", "translate(0px, " + /*dims*/ ctx[0].height * 0.25 + "px)");
    			}

    			if (dirty & /*dims, $data, icons, slugify*/ 3) {
    				each_value = /*$data*/ ctx[1].schema.hazards.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*dims*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*dims*/ ctx[0].width + " " + /*dims*/ ctx[0].height)) {
    				attr_dev(svg, "viewBox", svg_viewBox_value);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClimateVariables', slots, []);

    	let { dims = {
    		width: 1600,
    		height: 1600,
    		variableSpacing: 105
    	} } = $$props;

    	const chartDims = { width: 350, height: 90 };
    	const scaleX = linear().range([0, chartDims.width]).domain([2019, $data.climate.schema.years[$data.climate.schema.years.length - 1]]);

    	function getScaleY(variable) {
    		const chartData45 = $data.climate.variables.projectedChange["RCP4.5"].Annual[variable];
    		const chartData85 = $data.climate.variables.projectedChange["RCP8.5"].Annual[variable];
    		if (typeof $data.climate.variables.projectedChange["RCP4.5"].Annual[variable] === 'undefined') return null;
    		const chartData45_points = [0].concat(Object.values(chartData45.Lower)).concat(Object.values(chartData45.Median)).concat(Object.values(chartData45.Upper));
    		const chartData85_points = [0].concat(Object.values(chartData85.Lower)).concat(Object.values(chartData85.Median)).concat(Object.values(chartData85.Upper));
    		const dataPoints = chartData45_points.concat(chartData85_points);
    		return linear().range([0, -chartDims.height]).domain(extent$1(dataPoints));
    	}

    	function chartPath(chartData, scaleY, variable) {
    		const areaData = [
    			[2019, 0, 0],
    			[
    				2030,
    				min$2([
    					Object.values(chartData.Lower)[0],
    					Object.values(chartData.Median)[0],
    					Object.values(chartData.Upper)[0]
    				]),
    				max$3([
    					Object.values(chartData.Lower)[0],
    					Object.values(chartData.Median)[0],
    					Object.values(chartData.Upper)[0]
    				])
    			],
    			[
    				2050,
    				min$2([
    					Object.values(chartData.Lower)[1],
    					Object.values(chartData.Median)[1],
    					Object.values(chartData.Upper)[1]
    				]),
    				max$3([
    					Object.values(chartData.Lower)[1],
    					Object.values(chartData.Median)[1],
    					Object.values(chartData.Upper)[1]
    				])
    			],
    			[
    				2070,
    				min$2([
    					Object.values(chartData.Lower)[2],
    					Object.values(chartData.Median)[2],
    					Object.values(chartData.Upper)[2]
    				]),
    				max$3([
    					Object.values(chartData.Lower)[2],
    					Object.values(chartData.Median)[2],
    					Object.values(chartData.Upper)[2]
    				])
    			],
    			[
    				2090,
    				min$2([
    					Object.values(chartData.Lower)[3],
    					Object.values(chartData.Median)[3],
    					Object.values(chartData.Upper)[3]
    				]),
    				max$3([
    					Object.values(chartData.Lower)[3],
    					Object.values(chartData.Median)[3],
    					Object.values(chartData.Upper)[3]
    				])
    			]
    		];

    		const areaGenerator = area().x(d => scaleX(+d[0])).y0(d => scaleY(+d[1])).y1(d => scaleY(+d[2]));
    		return areaGenerator(areaData);
    	}

    	onMount(() => {
    		const variablesLayer = select('.text-wrap-layer');
    		variablesLayer.selectAll('.variable-description').data($data.schema.climateVariables.data).join('text').classed('variable-description', true).attr('x', 50).attr('y', (d, i) => dims.variableSpacing * i + 20).attr('dy', 0).text(d => d.Description).style('fill', '#fff').style('font-weight', 300).style('font-size', 14).call(textWrap, 450, 1.1, false);
    	});

    	const writable_props = ['dims'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClimateVariables> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		textWrap,
    		slugify,
    		icons,
    		ui,
    		data,
    		dims,
    		chartDims,
    		scaleX,
    		getScaleY,
    		chartPath,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $data, chartDims, scaleX, getScaleY, chartPath];
    }

    class ClimateVariables extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClimateVariables",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get dims() {
    		throw new Error("<ClimateVariables>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<ClimateVariables>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/adaptation/vis/ClimateHazards.svelte generated by Svelte v3.48.0 */
    const file$g = "src/components/byPage/adaptation/vis/ClimateHazards.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (82:12) {#each shockStressOffsets as offset}
    function create_each_block_1$3(ctx) {
    	let g;
    	let text0;
    	let t0;
    	let text1;
    	let t1;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			text0 = svg_element("text");
    			t0 = text$1("Shock");
    			text1 = svg_element("text");
    			t1 = text$1("Stress");
    			attr_dev(text0, "class", "type-label shock svelte-1ktcv8p");
    			set_style(text0, "transform", "translate(" + (/*dims*/ ctx[1].width - 50) + "px, " + 0 + "px)");
    			add_location(text0, file$g, 83, 16, 3899);
    			attr_dev(text1, "class", "type-label stress svelte-1ktcv8p");
    			set_style(text1, "transform", "translate(" + 50 + "px, " + 0 + "px)");
    			add_location(text1, file$g, 84, 16, 4018);
    			set_style(g, "transform", "translate(" + 0 + "px, " + (/*dims*/ ctx[1].width * 0.25 + /*offset*/ ctx[7]) + "px)");
    			add_location(g, file$g, 82, 12, 3811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, text0);
    			append_dev(text0, t0);
    			append_dev(g, text1);
    			append_dev(text1, t1);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(82:12) {#each shockStressOffsets as offset}",
    		ctx
    	});

    	return block;
    }

    // (91:12) {#each $data.schema.hazards.data as obj , i}
    function create_each_block$9(ctx) {
    	let g;
    	let path;
    	let path_d_value;
    	let text_1;
    	let raw_value = /*obj*/ ctx[4].Hazard + "";

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			path = svg_element("path");
    			text_1 = svg_element("text");
    			attr_dev(path, "class", "hazard-icon svelte-1ktcv8p");
    			attr_dev(path, "d", path_d_value = icons[slugify(/*obj*/ ctx[4].Hazard)]);
    			set_style(path, "transform", "translate(0px, -80px) scale(1.25)");
    			add_location(path, file$g, 92, 16, 4486);
    			attr_dev(text_1, "class", "hazard-label svelte-1ktcv8p");
    			add_location(text_1, file$g, 93, 16, 4618);
    			set_style(g, "transform", "translate(0px, " + (/*eventsByHazard*/ ctx[3][/*i*/ ctx[6]] / /*$data*/ ctx[0].schema.hazardEvents.data.length * /*dims*/ ctx[1].height * 0.8 + /*dims*/ ctx[1].height * 0.2) + "px)");
    			add_location(g, file$g, 91, 12, 4322);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, path);
    			append_dev(g, text_1);
    			text_1.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1 && path_d_value !== (path_d_value = icons[slugify(/*obj*/ ctx[4].Hazard)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 1 && raw_value !== (raw_value = /*obj*/ ctx[4].Hazard + "")) text_1.innerHTML = raw_value;
    			if (dirty & /*$data*/ 1) {
    				set_style(g, "transform", "translate(0px, " + (/*eventsByHazard*/ ctx[3][/*i*/ ctx[6]] / /*$data*/ ctx[0].schema.hazardEvents.data.length * /*dims*/ ctx[1].height * 0.8 + /*dims*/ ctx[1].height * 0.2) + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(91:12) {#each $data.schema.hazards.data as obj , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let figure;
    	let svg;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let g1;
    	let g0;
    	let text0;
    	let t0;
    	let tspan;
    	let t1;
    	let t2;
    	let text1;
    	let t3;
    	let text2;
    	let t4;
    	let g2;
    	let g4;
    	let g3;
    	let each_value_1 = /*shockStressOffsets*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	let each_value = /*$data*/ ctx[0].schema.hazards.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			text0 = svg_element("text");
    			t0 = text$1("Climate ");
    			tspan = svg_element("tspan");
    			t1 = text$1("hazards");
    			t2 = text$1(" and related events");
    			text1 = svg_element("text");
    			t3 = text$1("There are four climate hazards that trigger events that impact the Hepburn community.");
    			text2 = svg_element("text");
    			t4 = text$1("Projected climate change will lead to an increase the frequency and/or intensity of these events.");
    			g2 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g4 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			g3 = svg_element("g");
    			attr_dev(stop0, "stop-color", "hsl(50, 100%, 70%)");
    			attr_dev(stop0, "offset", "10%");
    			add_location(stop0, file$g, 67, 16, 2956);
    			attr_dev(stop1, "stop-color", "hsl(320, 100%, 50%)");
    			attr_dev(stop1, "offset", "90%");
    			add_location(stop1, file$g, 68, 16, 3025);
    			attr_dev(linearGradient, "id", "gr-hazard");
    			attr_dev(linearGradient, "x1", "0");
    			attr_dev(linearGradient, "y1", "0");
    			attr_dev(linearGradient, "x2", "100%");
    			attr_dev(linearGradient, "y2", "100%");
    			add_location(linearGradient, file$g, 66, 12, 2874);
    			add_location(defs, file$g, 65, 8, 2855);
    			attr_dev(tspan, "class", "hazard-text svelte-1ktcv8p");
    			add_location(tspan, file$g, 74, 48, 3305);
    			attr_dev(text0, "class", "header svelte-1ktcv8p");
    			add_location(text0, file$g, 74, 16, 3273);
    			attr_dev(text1, "class", "sub-header svelte-1ktcv8p");
    			attr_dev(text1, "y", "40");
    			add_location(text1, file$g, 75, 16, 3392);
    			attr_dev(text2, "class", "sub-header svelte-1ktcv8p");
    			attr_dev(text2, "y", "70");
    			add_location(text2, file$g, 76, 16, 3535);
    			set_style(g0, "transform", "translate(" + /*dims*/ ctx[1].width * 0.5 + "px, 0px)");
    			add_location(g0, file$g, 73, 12, 3197);
    			set_style(g1, "transform", "translate(" + 0 + "px, " + 100 + "px)");
    			add_location(g1, file$g, 72, 8, 3134);
    			attr_dev(g2, "class", "shock-stress-group");
    			add_location(g2, file$g, 80, 8, 3713);
    			attr_dev(g3, "class", "event-description-group");
    			add_location(g3, file$g, 96, 12, 4722);
    			attr_dev(g4, "class", "hazards-group");
    			set_style(g4, "transform", "translate(" + /*dims*/ ctx[1].width * 0.5 + "px, 0px)");
    			add_location(g4, file$g, 89, 8, 4169);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "class", "climate-hazards-vis svelte-1ktcv8p");
    			attr_dev(svg, "viewBox", "0 0 " + /*dims*/ ctx[1].width + " " + /*dims*/ ctx[1].height);
    			add_location(svg, file$g, 63, 4, 2668);
    			attr_dev(figure, "class", "svg-container svelte-1ktcv8p");
    			add_location(figure, file$g, 62, 0, 2631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, svg);
    			append_dev(svg, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, text0);
    			append_dev(text0, t0);
    			append_dev(text0, tspan);
    			append_dev(tspan, t1);
    			append_dev(text0, t2);
    			append_dev(g0, text1);
    			append_dev(text1, t3);
    			append_dev(g0, text2);
    			append_dev(text2, t4);
    			append_dev(svg, g2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g2, null);
    			}

    			append_dev(svg, g4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g4, null);
    			}

    			append_dev(g4, g3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dims, shockStressOffsets*/ 6) {
    				each_value_1 = /*shockStressOffsets*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*eventsByHazard, $data, dims, icons, slugify*/ 11) {
    				each_value = /*$data*/ ctx[0].schema.hazards.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g4, g3);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const hazardOffset = 0.6;
    const eventOffset = 72.5;
    const textLength = 550;

    function instance$g($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClimateHazards', slots, []);
    	const dims = { width: 1600, height: 1600 };
    	const shockStressOffsets = [0, 150, 300, 450, 600, 750, 900, 1050, 1200];
    	const eventsByHazard = [1].concat($data.schema.hazards.data.map(d => d["Linked hazard events"].length).map((sum => value => sum += value)(0))).map((d, i) => d + i * hazardOffset - 1);

    	onMount(() => {
    		selectAll('event.description');

    		$data.schema.hazards.data.forEach((obj, i) => {
    			$data.schema.hazardEvents.data.filter(e => e.Hazard[0] === obj.recordID).forEach((d, j) => {
    				const group = select('.event-description-group').append('g').style('transform', `translate(${0}px, ${0 + (eventsByHazard[i] / $data.schema.hazardEvents.data.length * dims.height * 0.8 + dims.height * 0.2) + (eventOffset * j + 60)}px`);
    				const label = group.append('text').classed('event-label', true).style('font-size', 40).style('font-weight', 700).style('text-anchor', 'middle').style('fill', '#fff').text(d["Hazard event"]);

    				group.append('text').classed('event-description', true).attr('dy', 0).attr('x', d.Type === 'Shock'
    				? dims.width * 0.125
    				: -dims.width * 0.125 - textLength).attr('y', 0).style('font-size', 14).style('fill', '#fff').text(d["Description"]).call(textWrap, textLength, 1.05, true);

    				group.append('path').style('stroke', '#fff').style('stroke-widhth', 2).style('fill', 'none').attr('d', `M${(d.Type === 'Shock' ? -1 : 1) * label.node().getBBox().width * 0.5}, 10 
                                H${(d.Type === 'Shock' ? 1 : -1) * (dims.width * 0.5 - 50)}`);
    			});
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClimateHazards> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		textWrap,
    		slugify,
    		ui,
    		data,
    		icons,
    		dims,
    		shockStressOffsets,
    		hazardOffset,
    		eventOffset,
    		textLength,
    		eventsByHazard,
    		$data
    	});

    	return [$data, dims, shockStressOffsets, eventsByHazard];
    }

    class ClimateHazards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClimateHazards",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src/components/byPage/adaptation/vis/ClimateRisks.svelte generated by Svelte v3.48.0 */
    const file$f = "src/components/byPage/adaptation/vis/ClimateRisks.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (44:16) {#each $data.schema.riskDeterminants.data as obj , i}
    function create_each_block$8(ctx) {
    	let g1;
    	let ellipse0;
    	let ellipse1;
    	let g0;
    	let text_1;
    	let t_value = /*obj*/ ctx[3].Name + "";
    	let t;
    	let g1_class_value;

    	const block = {
    		c: function create() {
    			g1 = svg_element("g");
    			ellipse0 = svg_element("ellipse");
    			ellipse1 = svg_element("ellipse");
    			g0 = svg_element("g");
    			text_1 = svg_element("text");
    			t = text$1(t_value);
    			attr_dev(ellipse0, "class", "oval-bg svelte-ekibjj");
    			attr_dev(ellipse0, "cx", "0");
    			attr_dev(ellipse0, "cy", "0");
    			attr_dev(ellipse0, "rx", /*dims*/ ctx[1].width * 0.2);
    			attr_dev(ellipse0, "ry", /*dims*/ ctx[1].width * 0.125);
    			set_style(ellipse0, "transform-origin", -/*dims*/ ctx[1].width * 0.1 + "px 0");
    			set_style(ellipse0, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			add_location(ellipse0, file$f, 45, 20, 2216);
    			attr_dev(ellipse1, "class", "oval-fg svelte-ekibjj");
    			attr_dev(ellipse1, "cx", "0");
    			attr_dev(ellipse1, "cy", "0");
    			attr_dev(ellipse1, "rx", /*dims*/ ctx[1].width * 0.2);
    			attr_dev(ellipse1, "ry", /*dims*/ ctx[1].width * 0.125);
    			set_style(ellipse1, "transform-origin", -/*dims*/ ctx[1].width * 0.1 + "px 0");
    			set_style(ellipse1, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			add_location(ellipse1, file$f, 46, 20, 2461);
    			attr_dev(text_1, "class", "determinant-label svelte-ekibjj");
    			attr_dev(text_1, "x", /*dims*/ ctx[1].width * 0.1 * (/*i*/ ctx[5] === 2 ? -1 : 1));
    			set_style(text_1, "transform", "rotate(" + (/*i*/ ctx[5] === 2 ? 180 : 0) + "deg)");
    			add_location(text_1, file$f, 48, 24, 2864);
    			set_style(g0, "transform-origin", -/*dims*/ ctx[1].width * 0.1 + "px 0");
    			set_style(g0, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			add_location(g0, file$f, 47, 20, 2706);
    			attr_dev(g1, "class", g1_class_value = "oval-group " + slugify(/*obj*/ ctx[3].Name) + " svelte-ekibjj");
    			add_location(g1, file$f, 44, 16, 2151);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g1, anchor);
    			append_dev(g1, ellipse0);
    			append_dev(g1, ellipse1);
    			append_dev(g1, g0);
    			append_dev(g0, text_1);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1) {
    				set_style(ellipse0, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			}

    			if (dirty & /*$data*/ 1) {
    				set_style(ellipse1, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			}

    			if (dirty & /*$data*/ 1 && t_value !== (t_value = /*obj*/ ctx[3].Name + "")) set_data_dev(t, t_value);

    			if (dirty & /*$data*/ 1) {
    				set_style(g0, "transform", "rotate(" + (/*i*/ ctx[5] * 360 / /*$data*/ ctx[0].schema.riskDeterminants.data.length - 90) + "deg)");
    			}

    			if (dirty & /*$data*/ 1 && g1_class_value !== (g1_class_value = "oval-group " + slugify(/*obj*/ ctx[3].Name) + " svelte-ekibjj")) {
    				attr_dev(g1, "class", g1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(44:16) {#each $data.schema.riskDeterminants.data as obj , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let figure;
    	let svg;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let g1;
    	let g0;
    	let text0;
    	let t0;
    	let tspan;
    	let t1;
    	let text1;
    	let t2;
    	let text2;
    	let t3;
    	let g3;
    	let circle;
    	let g2;
    	let text3;
    	let t4;
    	let path;
    	let text4;
    	let textPath;
    	let t5;
    	let each_value = /*$data*/ ctx[0].schema.riskDeterminants.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			text0 = svg_element("text");
    			t0 = text$1("Determinants of ");
    			tspan = svg_element("tspan");
    			t1 = text$1("Climate risk");
    			text1 = svg_element("text");
    			t2 = text$1("How climate hazards interact with hazard exposure and vulnerability to form risk.");
    			text2 = svg_element("text");
    			t3 = text$1("And the how our response through adaptation and mitigation actions can manage and frame climate risk.");
    			g3 = svg_element("g");
    			circle = svg_element("circle");
    			g2 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text3 = svg_element("text");
    			t4 = text$1("Risk");
    			path = svg_element("path");
    			text4 = svg_element("text");
    			textPath = svg_element("textPath");
    			t5 = text$1("Response to climate change");
    			attr_dev(stop0, "stop-color", "hsl(144, 97%, 70%)");
    			attr_dev(stop0, "offset", "30%");
    			add_location(stop0, file$f, 27, 16, 1056);
    			attr_dev(stop1, "stop-color", "hsl(236, 60%, 85%)");
    			attr_dev(stop1, "offset", "90%");
    			add_location(stop1, file$f, 28, 16, 1125);
    			attr_dev(linearGradient, "id", "gr-risk");
    			attr_dev(linearGradient, "x1", "0");
    			attr_dev(linearGradient, "y1", "0");
    			attr_dev(linearGradient, "x2", "100%");
    			attr_dev(linearGradient, "y2", "100%");
    			add_location(linearGradient, file$f, 26, 12, 976);
    			add_location(defs, file$f, 24, 8, 956);
    			attr_dev(tspan, "class", "risk-text svelte-ekibjj");
    			add_location(tspan, file$f, 34, 55, 1411);
    			attr_dev(text0, "class", "header svelte-ekibjj");
    			add_location(text0, file$f, 34, 16, 1372);
    			attr_dev(text1, "class", "sub-header svelte-ekibjj");
    			attr_dev(text1, "y", "40");
    			add_location(text1, file$f, 35, 16, 1482);
    			attr_dev(text2, "class", "sub-header svelte-ekibjj");
    			attr_dev(text2, "y", "70");
    			add_location(text2, file$f, 36, 16, 1621);
    			set_style(g0, "transform", "translate(" + /*dims*/ ctx[1].width * 0.5 + "px, 0px)");
    			add_location(g0, file$f, 33, 12, 1296);
    			set_style(g1, "transform", "translate(" + 0 + "px, " + 100 + "px)");
    			add_location(g1, file$f, 32, 8, 1233);
    			attr_dev(circle, "class", "response-circle svelte-ekibjj");
    			attr_dev(circle, "r", /*dims*/ ctx[1].width * 0.35);
    			add_location(circle, file$f, 41, 12, 1921);
    			set_style(g2, "transform", "translate(" + /*dims*/ ctx[1].width * 0.1 + "px, " + /*dims*/ ctx[1].width * 0 + "px)");
    			add_location(g2, file$f, 42, 12, 1991);
    			attr_dev(text3, "class", "center-label risk-label svelte-ekibjj");
    			attr_dev(text3, "dy", "40");
    			add_location(text3, file$f, 57, 12, 3220);
    			attr_dev(path, "id", "response-label-path");
    			attr_dev(path, "class", "label-path svelte-ekibjj");
    			attr_dev(path, "d", circleAntiClockwise({ x: 0, y: 0 }, /*dims*/ ctx[1].width * 0.35 + 45));
    			add_location(path, file$f, 58, 12, 3292);
    			attr_dev(textPath, "class", "response-label svelte-ekibjj");
    			attr_dev(textPath, "href", "#response-label-path");
    			attr_dev(textPath, "startOffset", "25%");
    			add_location(textPath, file$f, 60, 16, 3447);
    			attr_dev(text4, "class", "svelte-ekibjj");
    			add_location(text4, file$f, 59, 12, 3424);
    			attr_dev(g3, "class", "risk-ovals-group");
    			set_style(g3, "transform", "translate(" + /*dims*/ ctx[1].width * 0.5 + "px, " + /*dims*/ ctx[1].height * 0.55 + "px)");
    			add_location(g3, file$f, 40, 8, 1803);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "class", "climate-hazards-vis svelte-ekibjj");
    			attr_dev(svg, "viewBox", "0 0 " + /*dims*/ ctx[1].width + " " + /*dims*/ ctx[1].height);
    			add_location(svg, file$f, 22, 4, 769);
    			attr_dev(figure, "class", "svg-container svelte-ekibjj");
    			add_location(figure, file$f, 21, 0, 732);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, svg);
    			append_dev(svg, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, text0);
    			append_dev(text0, t0);
    			append_dev(text0, tspan);
    			append_dev(tspan, t1);
    			append_dev(g0, text1);
    			append_dev(text1, t2);
    			append_dev(g0, text2);
    			append_dev(text2, t3);
    			append_dev(svg, g3);
    			append_dev(g3, circle);
    			append_dev(g3, g2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g2, null);
    			}

    			append_dev(g3, text3);
    			append_dev(text3, t4);
    			append_dev(g3, path);
    			append_dev(g3, text4);
    			append_dev(text4, textPath);
    			append_dev(textPath, t5);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*slugify, $data, dims*/ 3) {
    				each_value = /*$data*/ ctx[0].schema.riskDeterminants.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClimateRisks', slots, []);
    	const dims = { width: 1600, height: 1600 };
    	const eventsByHazard = [1].concat($data.schema.hazards.data.map(d => d["Linked hazard events"].length).map((sum => value => sum += value)(0))).map((d, i) => d + i * 0.65 - 1);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClimateRisks> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		textWrap,
    		slugify,
    		ui,
    		data,
    		icons,
    		circleAntiClockwise,
    		dims,
    		eventsByHazard,
    		$data
    	});

    	return [$data, dims];
    }

    class ClimateRisks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClimateRisks",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/components/byPage/adaptation/RiskTable.svelte generated by Svelte v3.48.0 */
    const file$e = "src/components/byPage/adaptation/RiskTable.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[8] = i;
    	const constants_0 = /*d*/ child_ctx[4]["Risk area"].map(recordID => /*$data*/ child_ctx[0].schema.riskArea.data.filter(e => e.recordID === recordID)[0]["Risk area"]);
    	child_ctx[5] = constants_0;
    	const constants_1 = [...new Set(/*d*/ child_ctx[4]["Linked hazards"])].map(recordID => /*$data*/ child_ctx[0].schema.hazards.data.filter(e => e.recordID === recordID)[0]["Hazard"]);
    	child_ctx[6] = constants_1;
    	return child_ctx;
    }

    function get_if_ctx(ctx) {
    	const child_ctx = ctx.slice();
    	const constants_0 = /*rowspanData*/ child_ctx[1][/*rowspanIndexes*/ child_ctx[2].indexOf(/*i*/ child_ctx[8])];
    	child_ctx[9] = constants_0;
    	return child_ctx;
    }

    // (30:12) {#if rowspanIndexes.indexOf(i) > -1}
    function create_if_block$5(ctx) {
    	let td;

    	let t_value = (/*riskGroupArray*/ ctx[5]
    	? /*riskGroupArray*/ ctx[5].join(", ")
    	: '') + "";

    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text$1(t_value);
    			attr_dev(td, "class", "community-theme svelte-1fde3it");
    			attr_dev(td, "rowspan", /*spanData*/ ctx[9].count);
    			add_location(td, file$e, 31, 12, 1263);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 1 && t_value !== (t_value = (/*riskGroupArray*/ ctx[5]
    			? /*riskGroupArray*/ ctx[5].join(", ")
    			: '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(30:12) {#if rowspanIndexes.indexOf(i) > -1}",
    		ctx
    	});

    	return block;
    }

    // (26:4) {#each $data.schema.communityRisks.data as d, i}
    function create_each_block$7(ctx) {
    	let tr;
    	let show_if = /*rowspanIndexes*/ ctx[2].indexOf(/*i*/ ctx[8]) > -1;
    	let t0;
    	let td0;
    	let t1_value = /*d*/ ctx[4]["Community risk"] + "";
    	let t1;
    	let t2;
    	let td1;

    	let t3_value = (/*d*/ ctx[4]["Hazard events"]
    	? /*d*/ ctx[4]["Hazard events"].map(/*func*/ ctx[3]).join(", ")
    	: 'None') + "";

    	let t3;
    	let t4;
    	let if_block = show_if && create_if_block$5(get_if_ctx(ctx));

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			if (if_block) if_block.c();
    			t0 = space();
    			td0 = element("td");
    			t1 = text$1(t1_value);
    			t2 = space();
    			td1 = element("td");
    			t3 = text$1(t3_value);
    			t4 = space();
    			attr_dev(td0, "class", "community-risk svelte-1fde3it");
    			add_location(td0, file$e, 33, 12, 1406);
    			attr_dev(td1, "class", "hazard-event svelte-1fde3it");
    			add_location(td1, file$e, 34, 12, 1474);
    			attr_dev(tr, "class", "svelte-1fde3it");
    			add_location(tr, file$e, 28, 8, 1126);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			if (if_block) if_block.m(tr, null);
    			append_dev(tr, t0);
    			append_dev(tr, td0);
    			append_dev(td0, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td1);
    			append_dev(td1, t3);
    			append_dev(tr, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if) if_block.p(get_if_ctx(ctx), dirty);
    			if (dirty & /*$data*/ 1 && t1_value !== (t1_value = /*d*/ ctx[4]["Community risk"] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$data*/ 1 && t3_value !== (t3_value = (/*d*/ ctx[4]["Hazard events"]
    			? /*d*/ ctx[4]["Hazard events"].map(/*func*/ ctx[3]).join(", ")
    			: 'None') + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(26:4) {#each $data.schema.communityRisks.data as d, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let each_value = /*$data*/ ctx[0].schema.communityRisks.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Risk area";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Climate risk to the community";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Hazard events";
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "svelte-1fde3it");
    			add_location(th0, file$e, 18, 12, 579);
    			attr_dev(th1, "class", "svelte-1fde3it");
    			add_location(th1, file$e, 19, 12, 610);
    			attr_dev(th2, "class", "svelte-1fde3it");
    			add_location(th2, file$e, 20, 12, 661);
    			attr_dev(tr, "class", "svelte-1fde3it");
    			add_location(tr, file$e, 17, 8, 562);
    			attr_dev(thead, "class", "svelte-1fde3it");
    			add_location(thead, file$e, 16, 4, 546);
    			attr_dev(table, "class", "svelte-1fde3it");
    			add_location(table, file$e, 15, 0, 534);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(table, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$data, rowspanData, rowspanIndexes*/ 7) {
    				each_value = /*$data*/ ctx[0].schema.communityRisks.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $data;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RiskTable', slots, []);

    	const rowspanData = $data.schema.riskArea.data.map(d => {
    		return {
    			area: d["Risk area"],
    			count: $data.schema.communityRisks.data.filter(e => e["Risk area"][0] === d.recordID).length
    		};
    	});

    	const rowspanIndexes = [0].concat(rowspanData.map(d => d.count).reduce((a, x, i) => [...a, x + (a[i - 1] || 0)], []));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RiskTable> was created with unknown prop '${key}'`);
    	});

    	const func = d => $data.schema.hazardEvents.data.filter(e => e.recordID === d)[0]["Hazard event"];

    	$$self.$capture_state = () => ({
    		ui,
    		data,
    		fade,
    		rowspanData,
    		rowspanIndexes,
    		$data
    	});

    	return [$data, rowspanData, rowspanIndexes, func];
    }

    class RiskTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RiskTable",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/pages/Adaptation.svelte generated by Svelte v3.48.0 */
    const file$d = "src/pages/Adaptation.svelte";

    function create_fragment$d(ctx) {
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let logo;
    	let t0;
    	let h1;
    	let span0;
    	let br0;
    	let t2;
    	let br1;
    	let t3;
    	let span1;
    	let t5;
    	let div2;
    	let p0;
    	let t7;
    	let div3;
    	let ul0;
    	let li0;
    	let t9;
    	let li1;
    	let t11;
    	let li2;
    	let t13;
    	let li3;
    	let t15;
    	let li4;
    	let t17;
    	let div26;
    	let section0;
    	let div7;
    	let div6;
    	let hr0;
    	let t18;
    	let h20;
    	let t20;
    	let p1;
    	let t21;
    	let em0;
    	let t23;
    	let strong0;
    	let t25;
    	let a0;
    	let t27;
    	let em1;
    	let t29;
    	let t30;
    	let p2;
    	let t31;
    	let em2;
    	let t33;
    	let t34;
    	let p3;
    	let t36;
    	let div8;
    	let img0;
    	let img0_src_value;
    	let t37;
    	let section1;
    	let div10;
    	let div9;
    	let hr1;
    	let t38;
    	let h21;
    	let t40;
    	let p4;
    	let t41;
    	let strong1;
    	let t43;
    	let t44;
    	let p5;
    	let t45;
    	let a1;
    	let t47;
    	let a2;
    	let t49;
    	let strong2;
    	let t51;
    	let strong3;
    	let t53;
    	let t54;
    	let p6;
    	let t55;
    	let strong4;
    	let t57;
    	let t58;
    	let p7;
    	let t59;
    	let strong5;
    	let t61;
    	let a3;
    	let t63;
    	let a4;
    	let t65;
    	let strong6;
    	let t67;
    	let strong7;
    	let t69;
    	let t70;
    	let div11;
    	let climatevariables;
    	let t71;
    	let section2;
    	let div13;
    	let div12;
    	let hr2;
    	let t72;
    	let h22;
    	let t74;
    	let p8;
    	let t75;
    	let strong8;
    	let t77;
    	let t78;
    	let ul1;
    	let li5;
    	let strong9;
    	let t80;
    	let t81;
    	let li6;
    	let strong10;
    	let t83;
    	let t84;
    	let p9;
    	let t85;
    	let strong11;
    	let t87;
    	let t88;
    	let div14;
    	let climatehazards;
    	let t89;
    	let section3;
    	let div16;
    	let div15;
    	let hr3;
    	let t90;
    	let h23;
    	let t92;
    	let p10;
    	let t93;
    	let a5;
    	let t95;
    	let strong12;
    	let t97;
    	let em3;
    	let t99;
    	let em4;
    	let t101;
    	let t102;
    	let p11;
    	let t103;
    	let strong13;
    	let t105;
    	let strong14;
    	let t107;
    	let strong15;
    	let t109;
    	let t110;
    	let p12;
    	let t111;
    	let strong16;
    	let t113;
    	let strong17;
    	let t115;
    	let t116;
    	let p13;
    	let t117;
    	let strong18;
    	let t119;
    	let a6;
    	let t121;
    	let t122;
    	let div17;
    	let climaterisks;
    	let t123;
    	let section4;
    	let div19;
    	let div18;
    	let hr4;
    	let t124;
    	let h24;
    	let t126;
    	let p14;
    	let t128;
    	let p15;
    	let em5;
    	let t130;
    	let t131;
    	let p16;
    	let em6;
    	let t133;
    	let t134;
    	let div20;
    	let img1;
    	let img1_src_value;
    	let t135;
    	let section5;
    	let div22;
    	let div21;
    	let t136;
    	let div24;
    	let div23;
    	let h25;
    	let t138;
    	let div25;
    	let risktable;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ $$inline: true });
    	climatevariables = new ClimateVariables({ $$inline: true });
    	climatehazards = new ClimateHazards({ $$inline: true });
    	climaterisks = new ClimateRisks({ $$inline: true });
    	risktable = new RiskTable({ $$inline: true });

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			span0 = element("span");
    			span0.textContent = "Adapting to";
    			br0 = element("br");
    			t2 = text$1("\n            climate change");
    			br1 = element("br");
    			t3 = space();
    			span1 = element("span");
    			span1.textContent = "in Hepburn";
    			t5 = space();
    			div2 = element("div");
    			p0 = element("p");
    			p0.textContent = "The climate is changing and we need to make sure our community is ready to adapt to future with more frequent adn severe climate-related events like bushfires, floods, droughts and heatwaves. In this section we will: summarise the latest climate change modelling for Hepburn; introduce the key concepts that underpin climate change adaptation; and identify the climate risks facing our community.";
    			t7 = space();
    			div3 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			li0.textContent = "Introduction";
    			t9 = space();
    			li1 = element("li");
    			li1.textContent = "Climate variables";
    			t11 = space();
    			li2 = element("li");
    			li2.textContent = "Hazards and events";
    			t13 = space();
    			li3 = element("li");
    			li3.textContent = "Climate risk";
    			t15 = space();
    			li4 = element("li");
    			li4.textContent = "Community impact";
    			t17 = space();
    			div26 = element("div");
    			section0 = element("section");
    			div7 = element("div");
    			div6 = element("div");
    			hr0 = element("hr");
    			t18 = space();
    			h20 = element("h2");
    			h20.textContent = "Climate change adaptation";
    			t20 = space();
    			p1 = element("p");
    			t21 = text$1("Our climate ");
    			em0 = element("em");
    			em0.textContent = "is";
    			t23 = text$1(" changing. The Paris Agreement - the legally binding international treaty on climate change - sets the goal of ");
    			strong0 = element("strong");
    			strong0.textContent = "limiting global warming to well below 2, preferably to 1.5 degrees Celsius";
    			t25 = text$1(", compared to pre-industrial levels. To achieve this, the world needs to reduce, eliminate and drawdown greenhouse gas emissions. And in Hepburn, we've been coordinating actions to reduce emissions through ");
    			a0 = element("a");
    			a0.textContent = "Z-NET Hepburn";
    			t27 = text$1(". These emissions reduction actions also known as ");
    			em1 = element("em");
    			em1.textContent = "mitigation";
    			t29 = text$1(" actions. But how do we deal with the climate change we're already locked into?");
    			t30 = space();
    			p2 = element("p");
    			t31 = text$1("This is where climate change adaptation comes in: it's the \"process of adjustment to actual or expected climate and its effects\". In other words, making sure our community is prepared and able to cope with climate change. On the surface, adaptation seems ");
    			em2 = element("em");
    			em2.textContent = "fairly";
    			t33 = text$1(" straightforward however it encompasses a chain of concepts - many of which overlap with other domains and 'ways of seeing the world' - which can make adaptation difficult to fully grasp.");
    			t34 = space();
    			p3 = element("p");
    			p3.textContent = "This aim of this guide is help you understand what adaptation is all about, and why it matters to Hepburn.";
    			t36 = space();
    			div8 = element("div");
    			img0 = element("img");
    			t37 = space();
    			section1 = element("section");
    			div10 = element("div");
    			div9 = element("div");
    			hr1 = element("hr");
    			t38 = space();
    			h21 = element("h2");
    			h21.textContent = "How the climate is changing";
    			t40 = space();
    			p4 = element("p");
    			t41 = text$1("Let's start with some definitions (and data!) ");
    			strong1 = element("strong");
    			strong1.textContent = "Climate variables";
    			t43 = text$1(" are observations that you might recognise from weather forecasts and meteorological data. These are ways we can describe and measure climate change.");
    			t44 = space();
    			p5 = element("p");
    			t45 = text$1("It gets more interesting when we look at climate models that project how these variables might change over time. Modelling by ");
    			a1 = element("a");
    			a1.textContent = "CSIRO for the Victorian Government (DEWLP)";
    			t47 = text$1(" for the Central Highlands region (which includes Hepburn) ");
    			a2 = element("a");
    			a2.textContent = "projects the change in each climate variable";
    			t49 = text$1(" between 2019 and 2090. Each model projection assumes an emissions scenarios that corresponds to a \"Representative Concentration Pathway\" (RCP) that corresponds to different levels of average global warming by 2100. The ");
    			strong2 = element("strong");
    			strong2.textContent = "RCP4.5";
    			t51 = text$1(" and ");
    			strong3 = element("strong");
    			strong3.textContent = "RCP8.5";
    			t53 = text$1(" scenarios shown here and correspond to global warming of 4.5℃ and 8.5℃ respectively, by 2100.");
    			t54 = space();
    			p6 = element("p");
    			t55 = text$1("We can (very simply) think of these as medium and higher warming scenarios. But more importantly, together they are illustrate");
    			strong4 = element("strong");
    			strong4.textContent = "the general trend and level of uncertainty";
    			t57 = text$1(" of climate modelling for Hepburn.");
    			t58 = space();
    			p7 = element("p");
    			t59 = text$1("The last idea we'll consider here are ");
    			strong5 = element("strong");
    			strong5.textContent = "climate hazards";
    			t61 = text$1(" and how they are driven by climate variables. Four hazards were identified in a ");
    			a3 = element("a");
    			a3.textContent = "situational analysis";
    			t63 = text$1(" (by RMIT) that supports the regional ");
    			a4 = element("a");
    			a4.textContent = "Adapt Grampians";
    			t65 = text$1("  initiative, which includes Hepburn Shire. These ");
    			strong6 = element("strong");
    			strong6.textContent = "hazards represent threats to our community ";
    			t67 = text$1("that will be ");
    			strong7 = element("strong");
    			strong7.textContent = "amplified under all climate change scenarios";
    			t69 = text$1(".");
    			t70 = space();
    			div11 = element("div");
    			create_component(climatevariables.$$.fragment);
    			t71 = space();
    			section2 = element("section");
    			div13 = element("div");
    			div12 = element("div");
    			hr2 = element("hr");
    			t72 = space();
    			h22 = element("h2");
    			h22.textContent = "Climate hazards in Hepburn";
    			t74 = space();
    			p8 = element("p");
    			t75 = text$1("Hazards are quite easy for us to understand, however it's their related ");
    			strong8 = element("strong");
    			strong8.textContent = "climate events";
    			t77 = text$1(" that are directly experienced by the community. Climate events come in two kinds:");
    			t78 = space();
    			ul1 = element("ul");
    			li5 = element("li");
    			strong9 = element("strong");
    			strong9.textContent = "Shocks";
    			t80 = text$1(": these are intense, shortly sustained events that are commonly known natural (or climate) disasters; and");
    			t81 = space();
    			li6 = element("li");
    			strong10 = element("strong");
    			strong10.textContent = "Stresses";
    			t83 = text$1(": these are events that build and compound over longer periods.");
    			t84 = space();
    			p9 = element("p");
    			t85 = text$1("Climate scientists - aided by models and projections - tell us that climate change will lead to ");
    			strong11 = element("strong");
    			strong11.textContent = "more frequent and more intense climate events";
    			t87 = text$1(". Armed with these warnings, our next challenge is to understand what climate risks means to Hepburn.");
    			t88 = space();
    			div14 = element("div");
    			create_component(climatehazards.$$.fragment);
    			t89 = space();
    			section3 = element("section");
    			div16 = element("div");
    			div15 = element("div");
    			hr3 = element("hr");
    			t90 = space();
    			h23 = element("h2");
    			h23.textContent = "Climate risk";
    			t92 = space();
    			p10 = element("p");
    			t93 = text$1("The core definition of climate risk — provided by the ");
    			a5 = element("a");
    			a5.textContent = "IPCC";
    			t95 = text$1(" — is the ");
    			strong12 = element("strong");
    			strong12.textContent = "\"potential for adverse consequence for human or ecological systems";
    			t97 = text$1(" [.. and I]n the context of climate change, risks can arise from potential ");
    			em3 = element("em");
    			em3.textContent = "impacts";
    			t99 = text$1(" of climate change as well as human ");
    			em4 = element("em");
    			em4.textContent = "responses";
    			t101 = text$1(" to climate change\".");
    			t102 = space();
    			p11 = element("p");
    			t103 = text$1("We'll start by focusing on risk in the context of the impacts of climate change as these impacts are directly experienced by the community. These ");
    			strong13 = element("strong");
    			strong13.textContent = "\"risks result from dynamic interactions between climate-related hazards with the exposure and vulnerability of the affected human or ecological system to the hazards\"";
    			t105 = text$1(". In other words, the hazards that we've been talking about are just one determinant of risk: we also need to consider the concepts of ");
    			strong14 = element("strong");
    			strong14.textContent = "exposure";
    			t107 = text$1(" and ");
    			strong15 = element("strong");
    			strong15.textContent = "vulnerability";
    			t109 = text$1(".");
    			t110 = space();
    			p12 = element("p");
    			t111 = text$1("Exposure to a hazard (related event) is hopefully an easy concept to grasp, because events are spatial and protection often involves a physical response or intervention. Vulnerability is trickier as it involves our individual and collective capacities to adapt to and cope with \"adverse consequences\". Vulnerability is closely associated with ");
    			strong16 = element("strong");
    			strong16.textContent = "adaptive capacity";
    			t113 = text$1(" and  ");
    			strong17 = element("strong");
    			strong17.textContent = "resilience";
    			t115 = text$1(" (which is often be used in other closely related contexts). For our purposes, we think of resilience and adaptive capacity as having similar qualities that reduce vulnerability.");
    			t116 = space();
    			p13 = element("p");
    			t117 = text$1("The ");
    			strong18 = element("strong");
    			strong18.textContent = "response";
    			t119 = text$1(" to climate change can also ");
    			a6 = element("a");
    			a6.textContent = "be considered as a fourth determinant or risk";
    			t121 = text$1(". We'll look at this in more detail by examining Hepburn's adaptation actions (in the next module). But before we do that, let's take a closer look at climate risk in  community level.");
    			t122 = space();
    			div17 = element("div");
    			create_component(climaterisks.$$.fragment);
    			t123 = space();
    			section4 = element("section");
    			div19 = element("div");
    			div18 = element("div");
    			hr4 = element("hr");
    			t124 = space();
    			h24 = element("h2");
    			h24.textContent = "Climate risks and community impacts";
    			t126 = space();
    			p14 = element("p");
    			p14.textContent = "We've traversed a number concepts of concepts and definitions that help us link projected climate change to risk. But we haven't yet given a concrete example of a risk to the community. The following table of risks frame a wide range of climate risks as potential impacts on the community. These are tangible examples of what climate risk means to Hepburn, and help us to understand what's at stake.";
    			t128 = space();
    			p15 = element("p");
    			em5 = element("em");
    			em5.textContent = "Placeholder message for before consultation";
    			t130 = text$1(": These risks have been proposed as a starting point and prompt for community input and review. They are grouped into \"risk areas\" that help to group and classify them into broader themes that can help us think about the wide-ranging impacts of climate hazards and events.");
    			t131 = space();
    			p16 = element("p");
    			em6 = element("em");
    			em6.textContent = "To be updated to after community consultation and input";
    			t133 = text$1(": These risks and risk areas have been sourced and reviewed by the Hepburn community and reflect their concerns, inputs and experience of how these known climate hazards affect the community.");
    			t134 = space();
    			div20 = element("div");
    			img1 = element("img");
    			t135 = space();
    			section5 = element("section");
    			div22 = element("div");
    			div21 = element("div");
    			t136 = space();
    			div24 = element("div");
    			div23 = element("div");
    			h25 = element("h2");
    			h25.textContent = "Translating risk into community impacts";
    			t138 = space();
    			div25 = element("div");
    			create_component(risktable.$$.fragment);
    			attr_dev(div0, "class", "hero-logo__wrapper svelte-1mpa81l");
    			add_location(div0, file$d, 22, 12, 976);
    			attr_dev(div1, "class", "hero-logo svelte-1mpa81l");
    			add_location(div1, file$d, 21, 8, 940);
    			attr_dev(span0, "class", "title--mute svelte-1mpa81l");
    			add_location(span0, file$d, 25, 12, 1090);
    			add_location(br0, file$d, 25, 58, 1136);
    			add_location(br1, file$d, 26, 26, 1168);
    			attr_dev(span1, "class", "title--highlight svelte-1mpa81l");
    			add_location(span1, file$d, 27, 12, 1186);
    			attr_dev(h1, "class", "hero-content__title svelte-1mpa81l");
    			add_location(h1, file$d, 24, 8, 1045);
    			attr_dev(p0, "class", "svelte-1mpa81l");
    			add_location(p0, file$d, 30, 12, 1304);
    			attr_dev(div2, "class", "hero-content__text svelte-1mpa81l");
    			add_location(div2, file$d, 29, 8, 1259);
    			attr_dev(li0, "class", "select__item svelte-1mpa81l");
    			attr_dev(li0, "actname", "intro");
    			add_location(li0, file$d, 36, 16, 1874);
    			attr_dev(li1, "class", "select__item svelte-1mpa81l");
    			attr_dev(li1, "actname", "variables");
    			add_location(li1, file$d, 37, 16, 1973);
    			attr_dev(li2, "class", "select__item svelte-1mpa81l");
    			attr_dev(li2, "actname", "hazards");
    			add_location(li2, file$d, 38, 16, 2081);
    			attr_dev(li3, "class", "select__item svelte-1mpa81l");
    			attr_dev(li3, "actname", "climateRisk");
    			add_location(li3, file$d, 39, 16, 2188);
    			attr_dev(li4, "class", "select__item svelte-1mpa81l");
    			attr_dev(li4, "actname", "communityRisk");
    			add_location(li4, file$d, 40, 16, 2293);
    			attr_dev(ul0, "class", "svelte-1mpa81l");
    			add_location(ul0, file$d, 35, 12, 1853);
    			attr_dev(div3, "class", "select svelte-1mpa81l");
    			add_location(div3, file$d, 33, 8, 1744);
    			attr_dev(div4, "class", "hero-content svelte-1mpa81l");
    			add_location(div4, file$d, 19, 4, 870);
    			attr_dev(div5, "class", "hero-wrapper svelte-1mpa81l");
    			add_location(div5, file$d, 18, 0, 837);
    			attr_dev(hr0, "class", "svelte-1mpa81l");
    			add_location(hr0, file$d, 52, 16, 2688);
    			attr_dev(h20, "class", "svelte-1mpa81l");
    			add_location(h20, file$d, 53, 16, 2709);
    			add_location(em0, file$d, 54, 31, 2775);
    			add_location(strong0, file$d, 54, 153, 2897);
    			attr_dev(a0, "class", "underline");
    			attr_dev(a0, "href", "https://hepburnznet.org.au/");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$d, 54, 450, 3194);
    			add_location(em1, file$d, 54, 592, 3336);
    			attr_dev(p1, "class", "svelte-1mpa81l");
    			add_location(p1, file$d, 54, 16, 2760);
    			add_location(em2, file$d, 56, 274, 3731);
    			attr_dev(p2, "class", "svelte-1mpa81l");
    			add_location(p2, file$d, 56, 16, 3473);
    			attr_dev(p3, "class", "svelte-1mpa81l");
    			add_location(p3, file$d, 58, 16, 3972);
    			attr_dev(div6, "scene", "0");
    			add_location(div6, file$d, 51, 12, 2656);
    			attr_dev(div7, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div7, file$d, 50, 8, 2610);
    			if (!src_url_equal(img0.src, img0_src_value = "./static/img/christian-bass-11UT32fql64-unsplash.jpg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			attr_dev(img0, "class", "svelte-1mpa81l");
    			add_location(img0, file$d, 64, 12, 4186);
    			attr_dev(div8, "class", "vis-wrapper svelte-1mpa81l");
    			add_location(div8, file$d, 63, 8, 4146);
    			attr_dev(section0, "act", "intro");
    			attr_dev(section0, "class", "section-wrapper col-1-2 svelte-1mpa81l");
    			add_location(section0, file$d, 49, 4, 2543);
    			attr_dev(hr1, "class", "svelte-1mpa81l");
    			add_location(hr1, file$d, 72, 16, 4476);
    			attr_dev(h21, "class", "svelte-1mpa81l");
    			add_location(h21, file$d, 73, 16, 4497);
    			add_location(strong1, file$d, 74, 65, 4599);
    			attr_dev(p4, "class", "svelte-1mpa81l");
    			add_location(p4, file$d, 74, 16, 4550);
    			attr_dev(a1, "href", "https://www.climatechange.vic.gov.au/victorias-changing-climate");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$d, 76, 145, 4949);
    			attr_dev(a2, "href", "https://www.climatechangeinaustralia.gov.au/en/projects/victorian-climate-projections-2019/vcp19-accessing-datasets/");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$d, 76, 344, 5148);
    			add_location(strong2, file$d, 76, 758, 5562);
    			add_location(strong3, file$d, 76, 786, 5590);
    			attr_dev(p5, "class", "svelte-1mpa81l");
    			add_location(p5, file$d, 76, 16, 4820);
    			add_location(strong4, file$d, 78, 145, 5887);
    			attr_dev(p6, "class", "svelte-1mpa81l");
    			add_location(p6, file$d, 78, 16, 5758);
    			add_location(strong5, file$d, 80, 57, 6060);
    			attr_dev(a3, "href", "https://adaptgrampians.com.au/wp-content/uploads/2021/06/Grampians_Region_Climate_Adaptation_Strategy_Situation_Analysis_Final_.pdf");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$d, 80, 170, 6173);
    			attr_dev(a4, "href", "https://adaptgrampians.com.au/");
    			attr_dev(a4, "target", "_blank");
    			add_location(a4, file$d, 80, 391, 6394);
    			add_location(strong6, file$d, 80, 517, 6520);
    			add_location(strong7, file$d, 80, 591, 6594);
    			attr_dev(p7, "class", "svelte-1mpa81l");
    			add_location(p7, file$d, 80, 16, 6019);
    			attr_dev(div9, "scene", "0");
    			add_location(div9, file$d, 71, 12, 4444);
    			attr_dev(div10, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div10, file$d, 70, 8, 4398);
    			attr_dev(div11, "class", "vis-wrapper svelte-1mpa81l");
    			add_location(div11, file$d, 85, 8, 6725);
    			attr_dev(section1, "act", "variables");
    			attr_dev(section1, "class", "section-wrapper col-2-1 svelte-1mpa81l");
    			add_location(section1, file$d, 69, 4, 4327);
    			attr_dev(hr2, "class", "svelte-1mpa81l");
    			add_location(hr2, file$d, 94, 16, 6999);
    			attr_dev(h22, "class", "svelte-1mpa81l");
    			add_location(h22, file$d, 95, 16, 7020);
    			add_location(strong8, file$d, 96, 91, 7147);
    			attr_dev(p8, "class", "svelte-1mpa81l");
    			add_location(p8, file$d, 96, 16, 7072);
    			add_location(strong9, file$d, 98, 24, 7310);
    			add_location(li5, file$d, 98, 20, 7306);
    			add_location(strong10, file$d, 99, 24, 7469);
    			add_location(li6, file$d, 99, 20, 7465);
    			attr_dev(ul1, "class", "svelte-1mpa81l");
    			add_location(ul1, file$d, 97, 16, 7281);
    			add_location(strong11, file$d, 101, 115, 7700);
    			attr_dev(p9, "class", "svelte-1mpa81l");
    			add_location(p9, file$d, 101, 16, 7601);
    			attr_dev(div12, "scene", "0");
    			add_location(div12, file$d, 93, 12, 6967);
    			attr_dev(div13, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div13, file$d, 92, 8, 6921);
    			attr_dev(div14, "class", "vis-wrapper svelte-1mpa81l");
    			add_location(div14, file$d, 106, 8, 7929);
    			attr_dev(section2, "act", "hazards");
    			attr_dev(section2, "class", "section-wrapper col-1-2 svelte-1mpa81l");
    			add_location(section2, file$d, 91, 4, 6852);
    			attr_dev(hr3, "class", "svelte-1mpa81l");
    			add_location(hr3, file$d, 115, 16, 8220);
    			attr_dev(h23, "class", "svelte-1mpa81l");
    			add_location(h23, file$d, 116, 16, 8241);
    			attr_dev(a5, "href", "https://www.ipcc.ch/site/assets/uploads/2021/02/Risk-guidance-FINAL_15Feb2021.pdf");
    			attr_dev(a5, "target", "_blank");
    			add_location(a5, file$d, 117, 79, 8342);
    			add_location(strong12, file$d, 117, 211, 8474);
    			add_location(em3, file$d, 117, 369, 8632);
    			add_location(em4, file$d, 117, 421, 8684);
    			attr_dev(p10, "class", "svelte-1mpa81l");
    			add_location(p10, file$d, 117, 16, 8279);
    			add_location(strong13, file$d, 119, 165, 8910);
    			add_location(strong14, file$d, 119, 483, 9228);
    			add_location(strong15, file$d, 119, 513, 9258);
    			attr_dev(p11, "class", "svelte-1mpa81l");
    			add_location(p11, file$d, 119, 16, 8761);
    			add_location(strong16, file$d, 121, 362, 9674);
    			add_location(strong17, file$d, 121, 402, 9714);
    			attr_dev(p12, "class", "svelte-1mpa81l");
    			add_location(p12, file$d, 121, 16, 9328);
    			add_location(strong18, file$d, 123, 23, 9964);
    			attr_dev(a6, "href", "https://www.sciencedirect.com/science/article/pii/S2590332221001792");
    			attr_dev(a6, "target", "_blank");
    			add_location(a6, file$d, 123, 76, 10017);
    			attr_dev(p13, "class", "svelte-1mpa81l");
    			add_location(p13, file$d, 123, 16, 9957);
    			attr_dev(div15, "scene", "0");
    			add_location(div15, file$d, 114, 12, 8188);
    			attr_dev(div16, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div16, file$d, 113, 8, 8142);
    			attr_dev(div17, "class", "vis-wrapper svelte-1mpa81l");
    			add_location(div17, file$d, 128, 8, 10412);
    			attr_dev(section3, "act", "climateRisk");
    			attr_dev(section3, "class", "section-wrapper col-2-1 svelte-1mpa81l");
    			add_location(section3, file$d, 112, 4, 8069);
    			attr_dev(hr4, "class", "svelte-1mpa81l");
    			add_location(hr4, file$d, 137, 16, 10711);
    			attr_dev(h24, "class", "svelte-1mpa81l");
    			add_location(h24, file$d, 138, 16, 10732);
    			attr_dev(p14, "class", "svelte-1mpa81l");
    			add_location(p14, file$d, 139, 16, 10794);
    			add_location(em5, file$d, 141, 19, 11238);
    			attr_dev(p15, "class", "svelte-1mpa81l");
    			add_location(p15, file$d, 141, 16, 11235);
    			add_location(em6, file$d, 142, 19, 11586);
    			attr_dev(p16, "class", "svelte-1mpa81l");
    			add_location(p16, file$d, 142, 16, 11583);
    			attr_dev(div18, "scene", "0");
    			add_location(div18, file$d, 136, 12, 10679);
    			attr_dev(div19, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div19, file$d, 135, 8, 10633);
    			if (!src_url_equal(img1.src, img1_src_value = "./static/img/david-clode-Yg_sNKOiXvY-unsplash.jpg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "class", "svelte-1mpa81l");
    			add_location(img1, file$d, 147, 12, 11929);
    			attr_dev(div20, "class", "vis-wrapper svelte-1mpa81l");
    			add_location(div20, file$d, 146, 8, 11889);
    			attr_dev(section4, "act", "communityRisk");
    			attr_dev(section4, "class", "section-wrapper col-1-2 svelte-1mpa81l");
    			add_location(section4, file$d, 134, 4, 10558);
    			attr_dev(div21, "class", "invert-bg-clip svelte-1mpa81l");
    			add_location(div21, file$d, 154, 12, 12189);
    			attr_dev(div22, "class", "invert-bg svelte-1mpa81l");
    			add_location(div22, file$d, 153, 8, 12150);
    			attr_dev(h25, "class", "svelte-1mpa81l");
    			add_location(h25, file$d, 158, 16, 12326);
    			attr_dev(div23, "scene", "0");
    			add_location(div23, file$d, 157, 12, 12294);
    			attr_dev(div24, "class", "narrative-wrapper svelte-1mpa81l");
    			add_location(div24, file$d, 156, 8, 12248);
    			attr_dev(div25, "class", "table-wrapper svelte-1mpa81l");
    			add_location(div25, file$d, 161, 8, 12417);
    			attr_dev(section5, "act", "communityImpact");
    			attr_dev(section5, "class", "section-wrapper table invert svelte-1mpa81l");
    			add_location(section5, file$d, 152, 4, 12068);
    			attr_dev(div26, "class", "content-wrapper svelte-1mpa81l");
    			add_location(div26, file$d, 47, 0, 2469);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			mount_component(logo, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, h1);
    			append_dev(h1, span0);
    			append_dev(h1, br0);
    			append_dev(h1, t2);
    			append_dev(h1, br1);
    			append_dev(h1, t3);
    			append_dev(h1, span1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div2, p0);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, ul0);
    			append_dev(ul0, li0);
    			append_dev(ul0, t9);
    			append_dev(ul0, li1);
    			append_dev(ul0, t11);
    			append_dev(ul0, li2);
    			append_dev(ul0, t13);
    			append_dev(ul0, li3);
    			append_dev(ul0, t15);
    			append_dev(ul0, li4);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div26, anchor);
    			append_dev(div26, section0);
    			append_dev(section0, div7);
    			append_dev(div7, div6);
    			append_dev(div6, hr0);
    			append_dev(div6, t18);
    			append_dev(div6, h20);
    			append_dev(div6, t20);
    			append_dev(div6, p1);
    			append_dev(p1, t21);
    			append_dev(p1, em0);
    			append_dev(p1, t23);
    			append_dev(p1, strong0);
    			append_dev(p1, t25);
    			append_dev(p1, a0);
    			append_dev(p1, t27);
    			append_dev(p1, em1);
    			append_dev(p1, t29);
    			append_dev(div6, t30);
    			append_dev(div6, p2);
    			append_dev(p2, t31);
    			append_dev(p2, em2);
    			append_dev(p2, t33);
    			append_dev(div6, t34);
    			append_dev(div6, p3);
    			append_dev(section0, t36);
    			append_dev(section0, div8);
    			append_dev(div8, img0);
    			append_dev(div26, t37);
    			append_dev(div26, section1);
    			append_dev(section1, div10);
    			append_dev(div10, div9);
    			append_dev(div9, hr1);
    			append_dev(div9, t38);
    			append_dev(div9, h21);
    			append_dev(div9, t40);
    			append_dev(div9, p4);
    			append_dev(p4, t41);
    			append_dev(p4, strong1);
    			append_dev(p4, t43);
    			append_dev(div9, t44);
    			append_dev(div9, p5);
    			append_dev(p5, t45);
    			append_dev(p5, a1);
    			append_dev(p5, t47);
    			append_dev(p5, a2);
    			append_dev(p5, t49);
    			append_dev(p5, strong2);
    			append_dev(p5, t51);
    			append_dev(p5, strong3);
    			append_dev(p5, t53);
    			append_dev(div9, t54);
    			append_dev(div9, p6);
    			append_dev(p6, t55);
    			append_dev(p6, strong4);
    			append_dev(p6, t57);
    			append_dev(div9, t58);
    			append_dev(div9, p7);
    			append_dev(p7, t59);
    			append_dev(p7, strong5);
    			append_dev(p7, t61);
    			append_dev(p7, a3);
    			append_dev(p7, t63);
    			append_dev(p7, a4);
    			append_dev(p7, t65);
    			append_dev(p7, strong6);
    			append_dev(p7, t67);
    			append_dev(p7, strong7);
    			append_dev(p7, t69);
    			append_dev(section1, t70);
    			append_dev(section1, div11);
    			mount_component(climatevariables, div11, null);
    			append_dev(div26, t71);
    			append_dev(div26, section2);
    			append_dev(section2, div13);
    			append_dev(div13, div12);
    			append_dev(div12, hr2);
    			append_dev(div12, t72);
    			append_dev(div12, h22);
    			append_dev(div12, t74);
    			append_dev(div12, p8);
    			append_dev(p8, t75);
    			append_dev(p8, strong8);
    			append_dev(p8, t77);
    			append_dev(div12, t78);
    			append_dev(div12, ul1);
    			append_dev(ul1, li5);
    			append_dev(li5, strong9);
    			append_dev(li5, t80);
    			append_dev(ul1, t81);
    			append_dev(ul1, li6);
    			append_dev(li6, strong10);
    			append_dev(li6, t83);
    			append_dev(div12, t84);
    			append_dev(div12, p9);
    			append_dev(p9, t85);
    			append_dev(p9, strong11);
    			append_dev(p9, t87);
    			append_dev(section2, t88);
    			append_dev(section2, div14);
    			mount_component(climatehazards, div14, null);
    			append_dev(div26, t89);
    			append_dev(div26, section3);
    			append_dev(section3, div16);
    			append_dev(div16, div15);
    			append_dev(div15, hr3);
    			append_dev(div15, t90);
    			append_dev(div15, h23);
    			append_dev(div15, t92);
    			append_dev(div15, p10);
    			append_dev(p10, t93);
    			append_dev(p10, a5);
    			append_dev(p10, t95);
    			append_dev(p10, strong12);
    			append_dev(p10, t97);
    			append_dev(p10, em3);
    			append_dev(p10, t99);
    			append_dev(p10, em4);
    			append_dev(p10, t101);
    			append_dev(div15, t102);
    			append_dev(div15, p11);
    			append_dev(p11, t103);
    			append_dev(p11, strong13);
    			append_dev(p11, t105);
    			append_dev(p11, strong14);
    			append_dev(p11, t107);
    			append_dev(p11, strong15);
    			append_dev(p11, t109);
    			append_dev(div15, t110);
    			append_dev(div15, p12);
    			append_dev(p12, t111);
    			append_dev(p12, strong16);
    			append_dev(p12, t113);
    			append_dev(p12, strong17);
    			append_dev(p12, t115);
    			append_dev(div15, t116);
    			append_dev(div15, p13);
    			append_dev(p13, t117);
    			append_dev(p13, strong18);
    			append_dev(p13, t119);
    			append_dev(p13, a6);
    			append_dev(p13, t121);
    			append_dev(section3, t122);
    			append_dev(section3, div17);
    			mount_component(climaterisks, div17, null);
    			append_dev(div26, t123);
    			append_dev(div26, section4);
    			append_dev(section4, div19);
    			append_dev(div19, div18);
    			append_dev(div18, hr4);
    			append_dev(div18, t124);
    			append_dev(div18, h24);
    			append_dev(div18, t126);
    			append_dev(div18, p14);
    			append_dev(div18, t128);
    			append_dev(div18, p15);
    			append_dev(p15, em5);
    			append_dev(p15, t130);
    			append_dev(div18, t131);
    			append_dev(div18, p16);
    			append_dev(p16, em6);
    			append_dev(p16, t133);
    			append_dev(section4, t134);
    			append_dev(section4, div20);
    			append_dev(div20, img1);
    			append_dev(div26, t135);
    			append_dev(div26, section5);
    			append_dev(section5, div22);
    			append_dev(div22, div21);
    			append_dev(section5, t136);
    			append_dev(section5, div24);
    			append_dev(div24, div23);
    			append_dev(div23, h25);
    			append_dev(section5, t138);
    			append_dev(section5, div25);
    			mount_component(risktable, div25, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*scrollTo*/ ctx[0], false, false, false),
    					listen_dev(li1, "click", /*scrollTo*/ ctx[0], false, false, false),
    					listen_dev(li2, "click", /*scrollTo*/ ctx[0], false, false, false),
    					listen_dev(li3, "click", /*scrollTo*/ ctx[0], false, false, false),
    					listen_dev(li4, "click", /*scrollTo*/ ctx[0], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(climatevariables.$$.fragment, local);
    			transition_in(climatehazards.$$.fragment, local);
    			transition_in(climaterisks.$$.fragment, local);
    			transition_in(risktable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(climatevariables.$$.fragment, local);
    			transition_out(climatehazards.$$.fragment, local);
    			transition_out(climaterisks.$$.fragment, local);
    			transition_out(risktable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(logo);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div26);
    			destroy_component(climatevariables);
    			destroy_component(climatehazards);
    			destroy_component(climaterisks);
    			destroy_component(risktable);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Adaptation', slots, []);

    	const scrollTo = function () {
    		document.querySelector(`section[act=${this.getAttribute('actName')}]`).scrollIntoView({ behavior: 'smooth' });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Adaptation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Logo,
    		ui,
    		data,
    		Type,
    		ClimateVariables,
    		ClimateHazards,
    		ClimateRisks,
    		RiskTable,
    		scrollTo
    	});

    	return [scrollTo];
    }

    class Adaptation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Adaptation",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /*!
     * Observer 3.10.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */

    /* eslint-disable */
    var gsap$1,
        _coreInitted$1,
        _win$1,
        _doc$1,
        _docEl$1,
        _body$1,
        _isTouch,
        _pointerType,
        ScrollTrigger$1,
        _root$1,
        _normalizer$1,
        _eventTypes,
        _getGSAP$1 = function _getGSAP() {
      return gsap$1 || typeof window !== "undefined" && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
    },
        _startup$1 = 1,
        _observers = [],
        _scrollers = [],
        _proxies = [],
        _getTime$1 = Date.now,
        _bridge = function _bridge(name, value) {
      return value;
    },
        _integrate = function _integrate() {
      var core = ScrollTrigger$1.core,
          data = core.bridge || {},
          scrollers = core._scrollers,
          proxies = core._proxies;
      scrollers.push.apply(scrollers, _scrollers);
      proxies.push.apply(proxies, _proxies);
      _scrollers = scrollers;
      _proxies = proxies;

      _bridge = function _bridge(name, value) {
        return data[name](value);
      };
    },
        _getProxyProp = function _getProxyProp(element, property) {
      return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
    },
        _isViewport$1 = function _isViewport(el) {
      return !!~_root$1.indexOf(el);
    },
        _addListener$1 = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
        _removeListener$1 = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
        _scrollLeft = "scrollLeft",
        _scrollTop = "scrollTop",
        _onScroll$1 = function _onScroll() {
      return _normalizer$1 && _normalizer$1.isPressed || _scrollers.cache++;
    },
        _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
      var cachingFunc = function cachingFunc(value) {
        // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
        if (value || value === 0) {
          _startup$1 && (_win$1.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

          var isNormalizing = _normalizer$1 && _normalizer$1.isPressed;
          value = cachingFunc.v = Math.round(value) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

          f(value);
          cachingFunc.cacheID = _scrollers.cache;
          isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
          cachingFunc.cacheID = _scrollers.cache;
          cachingFunc.v = f();
        }

        return cachingFunc.v + cachingFunc.offset;
      };

      cachingFunc.offset = 0;
      return f && cachingFunc;
    },
        _horizontal = {
      s: _scrollLeft,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win$1.scrollTo(value, _vertical.sc()) : _win$1.pageXOffset || _doc$1[_scrollLeft] || _docEl$1[_scrollLeft] || _body$1[_scrollLeft] || 0;
      })
    },
        _vertical = {
      s: _scrollTop,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: _horizontal,
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win$1.scrollTo(_horizontal.sc(), value) : _win$1.pageYOffset || _doc$1[_scrollTop] || _docEl$1[_scrollTop] || _body$1[_scrollTop] || 0;
      })
    },
        _getTarget = function _getTarget(t) {
      return gsap$1.utils.toArray(t)[0] || (typeof t === "string" && gsap$1.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
    },
        _getScrollFunc = function _getScrollFunc(element, _ref) {
      var s = _ref.s,
          sc = _ref.sc;

      // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
      var i = _scrollers.indexOf(element),
          offset = sc === _vertical.sc ? 1 : 2;

      !~i && (i = _scrollers.push(element) - 1);
      return _scrollers[i + offset] || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport$1(element) ? sc : _scrollCacheFunc(function (value) {
        return arguments.length ? element[s] = value : element[s];
      })));
    },
        _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
      var v1 = value,
          v2 = value,
          t1 = _getTime$1(),
          t2 = t1,
          min = minTimeRefresh || 50,
          dropToZeroTime = Math.max(500, min * 3),
          update = function update(value, force) {
        var t = _getTime$1();

        if (force || t - t1 > min) {
          v2 = v1;
          v1 = value;
          t2 = t1;
          t1 = t;
        } else if (useDelta) {
          v1 += value;
        } else {
          // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
          v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
        }
      },
          reset = function reset() {
        v2 = v1 = useDelta ? 0 : v1;
        t2 = t1 = 0;
      },
          getVelocity = function getVelocity(latestValue) {
        var tOld = t2,
            vOld = v2,
            t = _getTime$1();

        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
      };

      return {
        update: update,
        reset: reset,
        getVelocity: getVelocity
      };
    },
        _getEvent = function _getEvent(e, preventDefault) {
      preventDefault && !e._gsapAllow && e.preventDefault();
      return e.changedTouches ? e.changedTouches[0] : e;
    },
        _getAbsoluteMax = function _getAbsoluteMax(a) {
      var max = Math.max.apply(Math, a),
          min = Math.min.apply(Math, a);
      return Math.abs(max) >= Math.abs(min) ? max : min;
    },
        _setScrollTrigger = function _setScrollTrigger() {
      ScrollTrigger$1 = gsap$1.core.globals().ScrollTrigger;
      ScrollTrigger$1 && ScrollTrigger$1.core && _integrate();
    },
        _initCore = function _initCore(core) {
      gsap$1 = core || _getGSAP$1();

      if (gsap$1 && typeof document !== "undefined" && document.body) {
        _win$1 = window;
        _doc$1 = document;
        _docEl$1 = _doc$1.documentElement;
        _body$1 = _doc$1.body;
        _root$1 = [_win$1, _doc$1, _docEl$1, _body$1];
        gsap$1.utils.clamp;
        _pointerType = "onpointerenter" in _body$1 ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

        _isTouch = Observer.isTouch = _win$1.matchMedia && _win$1.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win$1 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
        _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl$1 ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl$1) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
        setTimeout(function () {
          return _startup$1 = 0;
        }, 500);

        _setScrollTrigger();

        _coreInitted$1 = 1;
      }

      return _coreInitted$1;
    };

    _horizontal.op = _vertical;
    _scrollers.cache = 0;
    var Observer = /*#__PURE__*/function () {
      function Observer(vars) {
        this.init(vars);
      }

      var _proto = Observer.prototype;

      _proto.init = function init(vars) {
        _coreInitted$1 || _initCore(gsap$1) || console.warn("Please gsap.registerPlugin(Observer)");
        ScrollTrigger$1 || _setScrollTrigger();
        var tolerance = vars.tolerance,
            dragMinimum = vars.dragMinimum,
            type = vars.type,
            target = vars.target,
            lineHeight = vars.lineHeight,
            debounce = vars.debounce,
            preventDefault = vars.preventDefault,
            onStop = vars.onStop,
            onStopDelay = vars.onStopDelay,
            ignore = vars.ignore,
            wheelSpeed = vars.wheelSpeed,
            event = vars.event,
            onDragStart = vars.onDragStart,
            onDragEnd = vars.onDragEnd,
            onDrag = vars.onDrag,
            onPress = vars.onPress,
            onRelease = vars.onRelease,
            onRight = vars.onRight,
            onLeft = vars.onLeft,
            onUp = vars.onUp,
            onDown = vars.onDown,
            onChangeX = vars.onChangeX,
            onChangeY = vars.onChangeY,
            onChange = vars.onChange,
            onToggleX = vars.onToggleX,
            onToggleY = vars.onToggleY,
            onHover = vars.onHover,
            onHoverEnd = vars.onHoverEnd,
            onMove = vars.onMove,
            ignoreCheck = vars.ignoreCheck,
            isNormalizer = vars.isNormalizer,
            onGestureStart = vars.onGestureStart,
            onGestureEnd = vars.onGestureEnd,
            onWheel = vars.onWheel,
            onEnable = vars.onEnable,
            onDisable = vars.onDisable,
            onClick = vars.onClick,
            scrollSpeed = vars.scrollSpeed,
            capture = vars.capture,
            allowClicks = vars.allowClicks,
            lockAxis = vars.lockAxis,
            onLockAxis = vars.onLockAxis;
        this.target = target = _getTarget(target) || _docEl$1;
        this.vars = vars;
        ignore && (ignore = gsap$1.utils.toArray(ignore));
        tolerance = tolerance || 0;
        dragMinimum = dragMinimum || 0;
        wheelSpeed = wheelSpeed || 1;
        scrollSpeed = scrollSpeed || 1;
        type = type || "wheel,touch,pointer";
        debounce = debounce !== false;
        lineHeight || (lineHeight = parseFloat(_win$1.getComputedStyle(_body$1).lineHeight) || 22); // note: browser may report "normal", so default to 22.

        var id,
            onStopDelayedCall,
            dragged,
            moved,
            wheeled,
            locked,
            axis,
            self = this,
            prevDeltaX = 0,
            prevDeltaY = 0,
            scrollFuncX = _getScrollFunc(target, _horizontal),
            scrollFuncY = _getScrollFunc(target, _vertical),
            scrollX = scrollFuncX(),
            scrollY = scrollFuncY(),
            limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
            // for devices that accommodate mouse events and touch events, we need to distinguish.
        isViewport = _isViewport$1(target),
            ownerDoc = target.ownerDocument || _doc$1,
            deltaX = [0, 0, 0],
            // wheel, scroll, pointer/touch
        deltaY = [0, 0, 0],
            onClickTime = 0,
            clickCapture = function clickCapture() {
          return onClickTime = _getTime$1();
        },
            _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
          return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
        },
            onStopFunc = function onStopFunc() {
          self._vx.reset();

          self._vy.reset();

          onStopDelayedCall.pause();
          onStop && onStop(self);
        },
            update = function update() {
          var dx = self.deltaX = _getAbsoluteMax(deltaX),
              dy = self.deltaY = _getAbsoluteMax(deltaY),
              changedX = Math.abs(dx) >= tolerance,
              changedY = Math.abs(dy) >= tolerance;

          onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

          if (changedX) {
            onRight && self.deltaX > 0 && onRight(self);
            onLeft && self.deltaX < 0 && onLeft(self);
            onChangeX && onChangeX(self);
            onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
            prevDeltaX = self.deltaX;
            deltaX[0] = deltaX[1] = deltaX[2] = 0;
          }

          if (changedY) {
            onDown && self.deltaY > 0 && onDown(self);
            onUp && self.deltaY < 0 && onUp(self);
            onChangeY && onChangeY(self);
            onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
            prevDeltaY = self.deltaY;
            deltaY[0] = deltaY[1] = deltaY[2] = 0;
          }

          if (moved || dragged) {
            onMove && onMove(self);
            onLockAxis && locked && onLockAxis(self);

            if (dragged) {
              onDrag(self);
              dragged = false;
            }

            moved = locked = false;
          }

          if (wheeled) {
            onWheel(self);
            wheeled = false;
          }

          id = 0;
        },
            onDelta = function onDelta(x, y, index) {
          deltaX[index] += x;
          deltaY[index] += y;

          self._vx.update(x);

          self._vy.update(y);

          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
            onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
          if (axis !== "y") {
            deltaX[2] += x;

            self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

          }

          if (axis !== "x") {
            deltaY[2] += y;

            self._vy.update(y, true);
          }

          if (lockAxis && !axis) {
            self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
            locked = true;
          }

          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
            _onDrag = function _onDrag(e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }

          e = _getEvent(e, preventDefault);
          var x = e.clientX,
              y = e.clientY,
              dx = x - self.x,
              dy = y - self.y,
              isDragging = self.isDragging;
          self.x = x;
          self.y = y;

          if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
            onDrag && (dragged = true);
            isDragging || (self.isDragging = true);
            onTouchOrPointerDelta(dx, dy);
            isDragging || onDragStart && onDragStart(self);
          }
        },
            _onPress = self.onPress = function (e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }

          self.axis = axis = null;
          onStopDelayedCall.pause();
          self.isPressed = true;
          e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

          prevDeltaX = prevDeltaY = 0;
          self.startX = self.x = e.clientX;
          self.startY = self.y = e.clientY;

          self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


          self._vy.reset();

          _addListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);

          self.deltaX = self.deltaY = 0;
          onPress && onPress(self);
        },
            _onRelease = function _onRelease(e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }

          _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

          var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
              // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
          eventData = _getEvent(e);

          if (!wasDragging) {
            self._vx.reset();

            self._vy.reset();

            if (preventDefault && allowClicks) {
              gsap$1.delayedCall(0.08, function () {
                // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
                if (_getTime$1() - onClickTime > 300 && !e.defaultPrevented) {
                  if (e.target.click) {
                    //some browsers (like mobile Safari) don't properly trigger the click event
                    e.target.click();
                  } else if (ownerDoc.createEvent) {
                    var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                    syntheticEvent.initMouseEvent("click", true, true, _win$1, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                    e.target.dispatchEvent(syntheticEvent);
                  }
                }
              });
            }
          }

          self.isDragging = self.isGesturing = self.isPressed = false;
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
          onDragEnd && wasDragging && onDragEnd(self);
          onRelease && onRelease(self, wasDragging);
        },
            _onGestureStart = function _onGestureStart(e) {
          return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
        },
            _onGestureEnd = function _onGestureEnd() {
          return (self.isGesturing = false) || onGestureEnd(self);
        },
            onScroll = function onScroll(e) {
          if (_ignoreCheck(e)) {
            return;
          }

          var x = scrollFuncX(),
              y = scrollFuncY();
          onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
          scrollX = x;
          scrollY = y;
          onStop && onStopDelayedCall.restart(true);
        },
            _onWheel = function _onWheel(e) {
          if (_ignoreCheck(e)) {
            return;
          }

          e = _getEvent(e, preventDefault);
          onWheel && (wheeled = true);
          var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win$1.innerHeight : 1) * wheelSpeed;
          onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
        },
            _onMove = function _onMove(e) {
          if (_ignoreCheck(e)) {
            return;
          }

          var x = e.clientX,
              y = e.clientY,
              dx = x - self.x,
              dy = y - self.y;
          self.x = x;
          self.y = y;
          moved = true;
          (dx || dy) && onTouchOrPointerDelta(dx, dy);
        },
            _onHover = function _onHover(e) {
          self.event = e;
          onHover(self);
        },
            _onHoverEnd = function _onHoverEnd(e) {
          self.event = e;
          onHoverEnd(self);
        },
            _onClick = function _onClick(e) {
          return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
        };

        onStopDelayedCall = self._dc = gsap$1.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
        self.deltaX = self.deltaY = 0;
        self._vx = _getVelocityProp(0, 50, true);
        self._vy = _getVelocityProp(0, 50, true);
        self.scrollX = scrollFuncX;
        self.scrollY = scrollFuncY;
        self.isDragging = self.isGesturing = self.isPressed = false;

        self.enable = function (e) {
          if (!self.isEnabled) {
            _addListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

            type.indexOf("scroll") >= 0 && _addListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
            type.indexOf("wheel") >= 0 && _addListener$1(target, "wheel", _onWheel, preventDefault, capture);

            if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
              _addListener$1(target, _eventTypes[0], _onPress, preventDefault, capture);

              _addListener$1(ownerDoc, _eventTypes[2], _onRelease);

              _addListener$1(ownerDoc, _eventTypes[3], _onRelease);

              allowClicks && _addListener$1(target, "click", clickCapture, false, true);
              onClick && _addListener$1(target, "click", _onClick);
              onGestureStart && _addListener$1(ownerDoc, "gesturestart", _onGestureStart);
              onGestureEnd && _addListener$1(ownerDoc, "gestureend", _onGestureEnd);
              onHover && _addListener$1(target, _pointerType + "enter", _onHover);
              onHoverEnd && _addListener$1(target, _pointerType + "leave", _onHoverEnd);
              onMove && _addListener$1(target, _pointerType + "move", _onMove);
            }

            self.isEnabled = true;
            e && e.type && _onPress(e);
            onEnable && onEnable(self);
          }

          return self;
        };

        self.disable = function () {
          if (self.isEnabled) {
            // only remove the _onScroll listener if there aren't any others that rely on the functionality.
            _observers.filter(function (o) {
              return o !== self && _isViewport$1(o.target);
            }).length || _removeListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

            if (self.isPressed) {
              self._vx.reset();

              self._vy.reset();

              _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
            }

            _removeListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

            _removeListener$1(target, "wheel", _onWheel, capture);

            _removeListener$1(target, _eventTypes[0], _onPress, capture);

            _removeListener$1(ownerDoc, _eventTypes[2], _onRelease);

            _removeListener$1(ownerDoc, _eventTypes[3], _onRelease);

            _removeListener$1(target, "click", clickCapture, true);

            _removeListener$1(target, "click", _onClick);

            _removeListener$1(ownerDoc, "gesturestart", _onGestureStart);

            _removeListener$1(ownerDoc, "gestureend", _onGestureEnd);

            _removeListener$1(target, _pointerType + "enter", _onHover);

            _removeListener$1(target, _pointerType + "leave", _onHoverEnd);

            _removeListener$1(target, _pointerType + "move", _onMove);

            self.isEnabled = self.isPressed = self.isDragging = false;
            onDisable && onDisable(self);
          }
        };

        self.kill = function () {
          self.disable();

          var i = _observers.indexOf(self);

          i >= 0 && _observers.splice(i, 1);
          _normalizer$1 === self && (_normalizer$1 = 0);
        };

        _observers.push(self);

        isNormalizer && _isViewport$1(target) && (_normalizer$1 = self);
        self.enable(event);
      };

      _createClass(Observer, [{
        key: "velocityX",
        get: function get() {
          return this._vx.getVelocity();
        }
      }, {
        key: "velocityY",
        get: function get() {
          return this._vy.getVelocity();
        }
      }]);

      return Observer;
    }();
    Observer.version = "3.10.4";

    Observer.create = function (vars) {
      return new Observer(vars);
    };

    Observer.register = _initCore;

    Observer.getAll = function () {
      return _observers.slice();
    };

    Observer.getById = function (id) {
      return _observers.filter(function (o) {
        return o.vars.id === id;
      })[0];
    };

    _getGSAP$1() && gsap$1.registerPlugin(Observer);

    /*!
     * ScrollTrigger 3.10.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */

    var gsap,
        _coreInitted,
        _win,
        _doc,
        _docEl,
        _body,
        _root,
        _resizeDelay,
        _toArray,
        _clamp,
        _time2,
        _syncInterval,
        _refreshing,
        _pointerIsDown,
        _transformProp,
        _i,
        _prevWidth,
        _prevHeight,
        _autoRefresh,
        _sort,
        _suppressOverwrites,
        _ignoreResize,
        _normalizer,
        _ignoreMobileResize,
        _baseScreenHeight,
        _baseScreenWidth,
        _fixIOSBug,
        _limitCallbacks,
        // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
    _startup = 1,
        _getTime = Date.now,
        _time1 = _getTime(),
        _lastScrollTime = 0,
        _enabled = 0,
        _pointerDownHandler = function _pointerDownHandler() {
      return _pointerIsDown = 1;
    },
        _pointerUpHandler = function _pointerUpHandler() {
      return _pointerIsDown = 0;
    },
        _passThrough = function _passThrough(v) {
      return v;
    },
        _round = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
        _windowExists = function _windowExists() {
      return typeof window !== "undefined";
    },
        _getGSAP = function _getGSAP() {
      return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
    },
        _isViewport = function _isViewport(e) {
      return !!~_root.indexOf(e);
    },
        _getBoundsFunc = function _getBoundsFunc(element) {
      return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
        _winOffsets.width = _win.innerWidth;
        _winOffsets.height = _win.innerHeight;
        return _winOffsets;
      } : function () {
        return _getBounds(element);
      });
    },
        _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
      var d = _ref.d,
          d2 = _ref.d2,
          a = _ref.a;
      return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
        return a()[d];
      } : function () {
        return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
      };
    },
        _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
      return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
        return _winOffsets;
      };
    },
        _maxScroll = function _maxScroll(element, _ref2) {
      var s = _ref2.s,
          d2 = _ref2.d2,
          d = _ref2.d,
          a = _ref2.a;
      return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
    },
        _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
      for (var i = 0; i < _autoRefresh.length; i += 3) {
        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
      }
    },
        _isString = function _isString(value) {
      return typeof value === "string";
    },
        _isFunction = function _isFunction(value) {
      return typeof value === "function";
    },
        _isNumber = function _isNumber(value) {
      return typeof value === "number";
    },
        _isObject = function _isObject(value) {
      return typeof value === "object";
    },
        _callIfFunc = function _callIfFunc(value) {
      return _isFunction(value) && value();
    },
        _combineFunc = function _combineFunc(f1, f2) {
      return function () {
        var result1 = _callIfFunc(f1),
            result2 = _callIfFunc(f2);

        return function () {
          _callIfFunc(result1);

          _callIfFunc(result2);
        };
      };
    },
        _endAnimation = function _endAnimation(animation, reversed, pause) {
      return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
    },
        _callback = function _callback(self, func) {
      if (self.enabled) {
        var result = func(self);
        result && result.totalTime && (self.callbackAnimation = result);
      }
    },
        _abs = Math.abs,
        _left = "left",
        _top = "top",
        _right = "right",
        _bottom = "bottom",
        _width = "width",
        _height = "height",
        _Right = "Right",
        _Left = "Left",
        _Top = "Top",
        _Bottom = "Bottom",
        _padding = "padding",
        _margin = "margin",
        _Width = "Width",
        _Height = "Height",
        _px = "px",
        _getComputedStyle = function _getComputedStyle(element) {
      return _win.getComputedStyle(element);
    },
        _makePositionable = function _makePositionable(element) {
      // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
      var position = _getComputedStyle(element).position;

      element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
    },
        _setDefaults = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }

      return obj;
    },
        _getBounds = function _getBounds(element, withoutTransforms) {
      var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
      }).progress(1),
          bounds = element.getBoundingClientRect();
      tween && tween.progress(0).kill();
      return bounds;
    },
        _getSize = function _getSize(element, _ref3) {
      var d2 = _ref3.d2;
      return element["offset" + d2] || element["client" + d2] || 0;
    },
        _getLabelRatioArray = function _getLabelRatioArray(timeline) {
      var a = [],
          labels = timeline.labels,
          duration = timeline.duration(),
          p;

      for (p in labels) {
        a.push(labels[p] / duration);
      }

      return a;
    },
        _getClosestLabel = function _getClosestLabel(animation) {
      return function (value) {
        return gsap.utils.snap(_getLabelRatioArray(animation), value);
      };
    },
        _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
      var snap = gsap.utils.snap(snapIncrementOrArray),
          a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
        return a - b;
      });
      return a ? function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }

        var i;

        if (!direction) {
          return snap(value);
        }

        if (direction > 0) {
          value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

          for (i = 0; i < a.length; i++) {
            if (a[i] >= value) {
              return a[i];
            }
          }

          return a[i - 1];
        } else {
          i = a.length;
          value += threshold;

          while (i--) {
            if (a[i] <= value) {
              return a[i];
            }
          }
        }

        return a[0];
      } : function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }

        var snapped = snap(value);
        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
      };
    },
        _getLabelAtDirection = function _getLabelAtDirection(timeline) {
      return function (value, st) {
        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
      };
    },
        _multiListener = function _multiListener(func, element, types, callback) {
      return types.split(",").forEach(function (type) {
        return func(element, type, callback);
      });
    },
        _addListener = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
        _removeListener = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
        _wheelListener = function _wheelListener(func, el, scrollFunc) {
      return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
    },
        _markerDefaults = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
    },
        _defaults = {
      toggleActions: "play",
      anticipatePin: 0
    },
        _keywords = {
      top: 0,
      left: 0,
      center: 0.5,
      bottom: 1,
      right: 1
    },
        _offsetToPx = function _offsetToPx(value, size) {
      if (_isString(value)) {
        var eqIndex = value.indexOf("="),
            relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

        if (~eqIndex) {
          value.indexOf("%") > eqIndex && (relative *= size / 100);
          value = value.substr(0, eqIndex - 1);
        }

        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
      }

      return value;
    },
        _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
      var startColor = _ref4.startColor,
          endColor = _ref4.endColor,
          fontSize = _ref4.fontSize,
          indent = _ref4.indent,
          fontWeight = _ref4.fontWeight;

      var e = _doc.createElement("div"),
          useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
          isScroller = type.indexOf("scroller") !== -1,
          parent = useFixedPosition ? _body : container,
          isStart = type.indexOf("start") !== -1,
          color = isStart ? startColor : endColor,
          css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

      css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
      (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
      matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
      e._isStart = isStart;
      e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
      e.style.cssText = css;
      e.innerText = name || name === 0 ? type + "-" + name : type;
      parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
      e._offset = e["offset" + direction.op.d2];

      _positionMarker(e, 0, direction, isStart);

      return e;
    },
        _positionMarker = function _positionMarker(marker, start, direction, flipped) {
      var vars = {
        display: "block"
      },
          side = direction[flipped ? "os2" : "p2"],
          oppositeSide = direction[flipped ? "p2" : "os2"];
      marker._isFlipped = flipped;
      vars[direction.a + "Percent"] = flipped ? -100 : 0;
      vars[direction.a] = flipped ? "1px" : 0;
      vars["border" + side + _Width] = 1;
      vars["border" + oppositeSide + _Width] = 0;
      vars[direction.p] = start + "px";
      gsap.set(marker, vars);
    },
        _triggers = [],
        _ids = {},
        _rafID,
        _sync = function _sync() {
      return _getTime() - _lastScrollTime > 34 && _updateAll();
    },
        _onScroll = function _onScroll() {
      // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
      if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {
        // if the user is dragging the scrollbar, allow it.
        _scrollers.cache++;
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime();
      }
    },
        _setBaseDimensions = function _setBaseDimensions() {
      _baseScreenWidth = _win.innerWidth;
      _baseScreenHeight = _win.innerHeight;
    },
        _onResize = function _onResize() {
      _scrollers.cache++;
      !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);
    },
        // ignore resizes triggered by refresh()
    _listeners = {},
        _emptyArray = [],
        _media = [],
        _creatingMedia,
        // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
    _lastMediaTick,
        _onMediaChange = function _onMediaChange(e) {
      var tick = gsap.ticker.frame,
          matches = [],
          i = 0,
          index;

      if (_lastMediaTick !== tick || _startup) {
        _revertAll();

        for (; i < _media.length; i += 4) {
          index = _win.matchMedia(_media[i]).matches;

          if (index !== _media[i + 3]) {
            // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
            _media[i + 3] = index;
            index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
          }
        }

        _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.


        for (i = 0; i < matches.length; i++) {
          index = matches[i];
          _creatingMedia = _media[index];
          _media[index + 2] = _media[index + 1](e);
        }

        _creatingMedia = 0;
        _coreInitted && _refreshAll(0, 1);
        _lastMediaTick = tick;

        _dispatch("matchMedia");
      }
    },
        _softRefresh = function _softRefresh() {
      return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
    },
        _dispatch = function _dispatch(type) {
      return _listeners[type] && _listeners[type].map(function (f) {
        return f();
      }) || _emptyArray;
    },
        _savedStyles = [],
        // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
    _revertRecorded = function _revertRecorded(media) {
      for (var i = 0; i < _savedStyles.length; i += 5) {
        if (!media || _savedStyles[i + 4] === media) {
          _savedStyles[i].style.cssText = _savedStyles[i + 1];
          _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
          _savedStyles[i + 3].uncache = 1;
        }
      }
    },
        _revertAll = function _revertAll(kill, media) {
      var trigger;

      for (_i = 0; _i < _triggers.length; _i++) {
        trigger = _triggers[_i];

        if (!media || trigger.media === media) {
          if (kill) {
            trigger.kill(1);
          } else {
            trigger.revert();
          }
        }
      }

      media && _revertRecorded(media);
      media || _dispatch("revert");
    },
        _clearScrollMemory = function _clearScrollMemory() {
      return _scrollers.cache++ && _scrollers.forEach(function (obj) {
        return typeof obj === "function" && (obj.rec = 0);
      });
    },
        // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
    _refreshingAll,
        _refreshID = 0,
        _refreshAll = function _refreshAll(force, skipRevert) {
      if (_lastScrollTime && !force) {
        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

        return;
      }

      _refreshingAll = true;

      var refreshInits = _dispatch("refreshInit");

      _sort && ScrollTrigger.sort();
      skipRevert || _revertAll();

      _triggers.slice(0).forEach(function (t) {
        return t.refresh();
      }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


      _triggers.forEach(function (t) {
        return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
      }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".


      refreshInits.forEach(function (result) {
        return result && result.render && result.render(-1);
      }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

      _clearScrollMemory();

      _resizeDelay.pause();

      _refreshID++;
      _refreshingAll = false;

      _dispatch("refresh");
    },
        _lastScroll = 0,
        _direction = 1,
        _primary,
        _updateAll = function _updateAll() {
      if (!_refreshingAll) {
        ScrollTrigger.isUpdating = true;
        _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

        var l = _triggers.length,
            time = _getTime(),
            recordVelocity = time - _time1 >= 50,
            scroll = l && _triggers[0].scroll();

        _direction = _lastScroll > scroll ? -1 : 1;
        _lastScroll = scroll;

        if (recordVelocity) {
          if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
            _lastScrollTime = 0;

            _dispatch("scrollEnd");
          }

          _time2 = _time1;
          _time1 = time;
        }

        if (_direction < 0) {
          _i = l;

          while (_i-- > 0) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }

          _direction = 1;
        } else {
          for (_i = 0; _i < l; _i++) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }
        }

        ScrollTrigger.isUpdating = false;
      }

      _rafID = 0;
    },
        _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
        _swapPinOut = function _swapPinOut(pin, spacer, state) {
      _setState(state);

      var cache = pin._gsap;

      if (cache.spacerIsNative) {
        _setState(cache.spacerState);
      } else if (pin.parentNode === spacer) {
        var parent = spacer.parentNode;

        if (parent) {
          parent.insertBefore(pin, spacer);
          parent.removeChild(spacer);
        }
      }
    },
        _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
      if (pin.parentNode !== spacer) {
        var i = _propNamesToCopy.length,
            spacerStyle = spacer.style,
            pinStyle = pin.style,
            p;

        while (i--) {
          p = _propNamesToCopy[i];
          spacerStyle[p] = cs[p];
        }

        spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
        cs.display === "inline" && (spacerStyle.display = "inline-block");
        pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
        spacerStyle.overflow = "visible";
        spacerStyle.boxSizing = "border-box";
        spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
        spacerStyle[_height] = _getSize(pin, _vertical) + _px;
        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

        _setState(spacerState);

        pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
        pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
        pinStyle[_padding] = cs[_padding];
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
    },
        _capsExp = /([A-Z])/g,
        _setState = function _setState(state) {
      if (state) {
        var style = state.t.style,
            l = state.length,
            i = 0,
            p,
            value;
        (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

        for (; i < l; i += 2) {
          value = state[i + 1];
          p = state[i];

          if (value) {
            style[p] = value;
          } else if (style[p]) {
            style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
          }
        }
      }
    },
        _getState = function _getState(element) {
      // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
      var l = _stateProps.length,
          style = element.style,
          state = [],
          i = 0;

      for (; i < l; i++) {
        state.push(_stateProps[i], style[_stateProps[i]]);
      }

      state.t = element;
      return state;
    },
        _copyState = function _copyState(state, override, omitOffsets) {
      var result = [],
          l = state.length,
          i = omitOffsets ? 8 : 0,
          // skip top, left, right, bottom if omitOffsets is true
      p;

      for (; i < l; i += 2) {
        p = state[i];
        result.push(p, p in override ? override[p] : state[i + 1]);
      }

      result.t = state.t;
      return result;
    },
        _winOffsets = {
      left: 0,
      top: 0
    },
        // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
    // _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
    // 	scroller = _getTarget(scroller || _win);
    // 	let direction = horizontal ? _horizontal : _vertical,
    // 		isViewport = _isViewport(scroller);
    // 	_getSizeFunc(scroller, isViewport, direction);
    // 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
    // },
    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
      _isFunction(value) && (value = value(self));

      if (_isString(value) && value.substr(0, 3) === "max") {
        value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
      }

      var time = containerAnimation ? containerAnimation.time() : 0,
          p1,
          p2,
          element;
      containerAnimation && containerAnimation.seek(0);

      if (!_isNumber(value)) {
        _isFunction(trigger) && (trigger = trigger(self));
        var offsets = value.split(" "),
            bounds,
            localOffset,
            globalOffset,
            display;
        element = _getTarget(trigger) || _body;
        bounds = _getBounds(element) || {};

        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
          // if display is "none", it won't report getBoundingClientRect() properly
          display = element.style.display;
          element.style.display = "block";
          bounds = _getBounds(element);
          display ? element.style.display = display : element.style.removeProperty("display");
        }

        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
        globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
        scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
      } else if (markerScroller) {
        _positionMarker(markerScroller, scrollerSize, direction, true);
      }

      if (marker) {
        var position = value + scrollerSize,
            isStart = marker._isStart;
        p1 = "scroll" + direction.d2;

        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);

        if (useFixedPosition) {
          scrollerBounds = _getBounds(markerScroller);
          useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
        }
      }

      if (containerAnimation && element) {
        p1 = _getBounds(element);
        containerAnimation.seek(scrollerMax);
        p2 = _getBounds(element);
        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
        value = value / containerAnimation._caScrollDist * scrollerMax;
      }

      containerAnimation && containerAnimation.seek(time);
      return containerAnimation ? value : Math.round(value);
    },
        _prefixExp = /(webkit|moz|length|cssText|inset)/i,
        _reparent = function _reparent(element, parent, top, left) {
      if (element.parentNode !== parent) {
        var style = element.style,
            p,
            cs;

        if (parent === _body) {
          element._stOrig = style.cssText; // record original inline styles so we can revert them later

          cs = _getComputedStyle(element);

          for (p in cs) {
            // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
            if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
              style[p] = cs[p];
            }
          }

          style.top = top;
          style.left = left;
        } else {
          style.cssText = element._stOrig;
        }

        gsap.core.getCache(element).uncache = 1;
        parent.appendChild(element);
      }
    },
        // _mergeAnimations = animations => {
    // 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
    // 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
    // 	tl.smoothChildTiming = false;
    // 	return tl;
    // },
    // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
    _getTweenCreator = function _getTweenCreator(scroller, direction) {
      var getScroll = _getScrollFunc(scroller, direction),
          prop = "_scroll" + direction.p2,
          // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
      lastScroll1,
          lastScroll2,
          getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
        var tween = getTween.tween,
            onComplete = vars.onComplete,
            modifiers = {};
        initialValue = initialValue || getScroll();
        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

        change1 = change1 || scrollTo - initialValue;
        tween && tween.kill();
        lastScroll1 = Math.round(initialValue);
        vars[prop] = scrollTo;
        vars.modifiers = modifiers;

        modifiers[prop] = function (value) {
          value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

          if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
            tween.kill();
            getTween.tween = 0;
          } else {
            value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
          }

          lastScroll2 = lastScroll1;
          return lastScroll1 = _round(value);
        };

        vars.onComplete = function () {
          getTween.tween = 0;
          onComplete && onComplete.call(tween);
        };

        tween = getTween.tween = gsap.to(scroller, vars);
        return tween;
      };

      scroller[prop] = getScroll;

      getScroll.wheelHandler = function () {
        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
      };

      _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


      return getTween;
    };

    var ScrollTrigger = /*#__PURE__*/function () {
      function ScrollTrigger(vars, animation) {
        _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
        this.init(vars, animation);
      }

      var _proto = ScrollTrigger.prototype;

      _proto.init = function init(vars, animation) {
        this.progress = this.start = 0;
        this.vars && this.kill(true, true); // in case it's being initted again

        if (!_enabled) {
          this.update = this.refresh = this.kill = _passThrough;
          return;
        }

        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
          trigger: vars
        } : vars, _defaults);

        var _vars = vars,
            onUpdate = _vars.onUpdate,
            toggleClass = _vars.toggleClass,
            id = _vars.id,
            onToggle = _vars.onToggle,
            onRefresh = _vars.onRefresh,
            scrub = _vars.scrub,
            trigger = _vars.trigger,
            pin = _vars.pin,
            pinSpacing = _vars.pinSpacing,
            invalidateOnRefresh = _vars.invalidateOnRefresh,
            anticipatePin = _vars.anticipatePin,
            onScrubComplete = _vars.onScrubComplete,
            onSnapComplete = _vars.onSnapComplete,
            once = _vars.once,
            snap = _vars.snap,
            pinReparent = _vars.pinReparent,
            pinSpacer = _vars.pinSpacer,
            containerAnimation = _vars.containerAnimation,
            fastScrollEnd = _vars.fastScrollEnd,
            preventOverlaps = _vars.preventOverlaps,
            direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
            isToggle = !scrub && scrub !== 0,
            scroller = _getTarget(vars.scroller || _win),
            scrollerCache = gsap.core.getCache(scroller),
            isViewport = _isViewport(scroller),
            useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
            callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
            toggleActions = isToggle && vars.toggleActions.split(" "),
            markers = "markers" in vars ? vars.markers : _defaults.markers,
            borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
            self = this,
            onRefreshInit = vars.onRefreshInit && function () {
          return vars.onRefreshInit(self);
        },
            getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
            getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
            lastSnap = 0,
            lastRefresh = 0,
            scrollFunc = _getScrollFunc(scroller, direction),
            tweenTo,
            pinCache,
            snapFunc,
            scroll1,
            scroll2,
            start,
            end,
            markerStart,
            markerEnd,
            markerStartTrigger,
            markerEndTrigger,
            markerVars,
            change,
            pinOriginalState,
            pinActiveState,
            pinState,
            spacer,
            offset,
            pinGetter,
            pinSetter,
            pinStart,
            pinChange,
            spacingStart,
            spacerState,
            markerStartSetter,
            markerEndSetter,
            cs,
            snap1,
            snap2,
            scrubTween,
            scrubSmooth,
            snapDurClamp,
            snapDelayedCall,
            prevProgress,
            prevScroll,
            prevAnimProgress,
            caMarkerSetter,
            customRevertReturn;

        self.media = _creatingMedia;
        self._dir = direction;
        anticipatePin *= 45;
        self.scroller = scroller;
        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
        scroll1 = scrollFunc();
        self.vars = vars;
        animation = animation || vars.animation;

        if ("refreshPriority" in vars) {
          _sort = 1;
          vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
        }

        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
          top: _getTweenCreator(scroller, _vertical),
          left: _getTweenCreator(scroller, _horizontal)
        };
        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

        self.scrubDuration = function (value) {
          scrubSmooth = _isNumber(value) && value;

          if (!scrubSmooth) {
            scrubTween && scrubTween.progress(1).kill();
            scrubTween = 0;
          } else {
            scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
              ease: "expo",
              totalProgress: "+=0.001",
              duration: scrubSmooth,
              paused: true,
              onComplete: function onComplete() {
                return onScrubComplete && onScrubComplete(self);
              }
            });
          }
        };

        if (animation) {
          animation.vars.lazy = false;
          animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
          self.animation = animation.pause();
          animation.scrollTrigger = self;
          self.scrubDuration(scrub);
          snap1 = 0;
          id || (id = animation.vars.id);
        }

        _triggers.push(self);

        if (snap) {
          if (!_isObject(snap) || snap.push) {
            snap = {
              snapTo: snap
            };
          }

          "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
            scrollBehavior: "auto"
          }); // smooth scrolling doesn't work with snap.

          snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
            return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
          } : gsap.utils.snap(snap.snapTo);
          snapDurClamp = snap.duration || {
            min: 0.1,
            max: 2
          };
          snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
          snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
            var scroll = scrollFunc(),
                refreshedRecently = _getTime() - lastRefresh < 500,
                tween = tweenTo.tween;

            if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
              var progress = (scroll - start) / change,
                  totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                  velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
                  change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                  naturalEnd = progress + (snap.inertia === false ? 0 : change1),
                  endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
                  endScroll = Math.round(start + endValue * change),
                  _snap = snap,
                  onStart = _snap.onStart,
                  _onInterrupt = _snap.onInterrupt,
                  _onComplete = _snap.onComplete;

              if (scroll <= end && scroll >= start && endScroll !== scroll) {
                if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                  // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
                  return;
                }

                if (snap.inertia === false) {
                  change1 = endValue - progress;
                }

                tweenTo(endScroll, {
                  duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                  ease: snap.ease || "power3",
                  data: _abs(endScroll - scroll),
                  // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                  onInterrupt: function onInterrupt() {
                    return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                  },
                  onComplete: function onComplete() {
                    self.update();
                    lastSnap = scrollFunc();
                    snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                    onSnapComplete && onSnapComplete(self);
                    _onComplete && _onComplete(self);
                  }
                }, scroll, change1 * change, endScroll - scroll - change1 * change);
                onStart && onStart(self, tweenTo.tween);
              }
            } else if (self.isActive && lastSnap !== scroll) {
              snapDelayedCall.restart(true);
            }
          }).pause();
        }

        id && (_ids[id] = self);
        trigger = self.trigger = _getTarget(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
        customRevertReturn && (customRevertReturn = customRevertReturn(self));
        pin = pin === true ? trigger : _getTarget(pin);
        _isString(toggleClass) && (toggleClass = {
          targets: trigger,
          className: toggleClass
        });

        if (pin) {
          pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.

          self.pin = pin;
          vars.force3D !== false && gsap.set(pin, {
            force3D: true
          });
          pinCache = gsap.core.getCache(pin);

          if (!pinCache.spacer) {
            // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
            if (pinSpacer) {
              pinSpacer = _getTarget(pinSpacer);
              pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

              pinCache.spacerIsNative = !!pinSpacer;
              pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
            }

            pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
            spacer.classList.add("pin-spacer");
            id && spacer.classList.add("pin-spacer-" + id);
            pinCache.pinState = pinOriginalState = _getState(pin);
          } else {
            pinOriginalState = pinCache.pinState;
          }

          self.spacer = spacer = pinCache.spacer;
          cs = _getComputedStyle(pin);
          spacingStart = cs[pinSpacing + direction.os2];
          pinGetter = gsap.getProperty(pin);
          pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

          _swapPinIn(pin, spacer, cs);

          pinState = _getState(pin);
        }

        if (markers) {
          markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
          markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
          markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
          offset = markerStartTrigger["offset" + direction.op.d2];

          var content = _getTarget(_getProxyProp(scroller, "content") || scroller);

          markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
          markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
          containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

          if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
            _makePositionable(isViewport ? _body : scroller);

            gsap.set([markerStartTrigger, markerEndTrigger], {
              force3D: true
            });
            markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
            markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
          }
        }

        if (containerAnimation) {
          var oldOnUpdate = containerAnimation.vars.onUpdate,
              oldParams = containerAnimation.vars.onUpdateParams;
          containerAnimation.eventCallback("onUpdate", function () {
            self.update(0, 0, 1);
            oldOnUpdate && oldOnUpdate.apply(oldParams || []);
          });
        }

        self.previous = function () {
          return _triggers[_triggers.indexOf(self) - 1];
        };

        self.next = function () {
          return _triggers[_triggers.indexOf(self) + 1];
        };

        self.revert = function (revert) {
          var r = revert !== false || !self.enabled,
              prevRefreshing = _refreshing;

          if (r !== self.isReverted) {
            if (r) {
              self.scroll.rec || !_refreshing || !_refreshingAll || (self.scroll.rec = scrollFunc());
              prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

              prevProgress = self.progress;
              prevAnimProgress = animation && animation.progress();
            }

            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
              return m.style.display = r ? "none" : "block";
            });
            r && (_refreshing = 1);
            self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.

            _refreshing = prevRefreshing;
            pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
            self.isReverted = r;
          }
        };

        self.refresh = function (soft, force) {
          if ((_refreshing || !self.enabled) && !force) {
            return;
          }

          if (pin && soft && _lastScrollTime) {
            _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

            return;
          }

          !_refreshingAll && onRefreshInit && onRefreshInit(self);
          _refreshing = 1;
          lastRefresh = _getTime();

          if (tweenTo.tween) {
            tweenTo.tween.kill();
            tweenTo.tween = 0;
          }

          scrubTween && scrubTween.pause();
          invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
          self.isReverted || self.revert();

          var size = getScrollerSize(),
              scrollerBounds = getScrollerOffsets(),
              max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
              offset = 0,
              otherPinOffset = 0,
              parsedEnd = vars.end,
              parsedEndTrigger = vars.endTrigger || trigger,
              parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
              pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),
              triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
              i = triggerIndex,
              cs,
              bounds,
              scroll,
              isVertical,
              override,
              curTrigger,
              curPin,
              oppositeScroll,
              initted,
              revertedPins;

          while (i--) {
            // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
            curTrigger = _triggers[i];
            curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

            curPin = curTrigger.pin;

            if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
              revertedPins || (revertedPins = []);
              revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

              curTrigger.revert();
            }

            if (curTrigger !== _triggers[i]) {
              // in case it got removed.
              triggerIndex--;
              i--;
            }
          }

          _isFunction(parsedStart) && (parsedStart = parsedStart(self));
          start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
          _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

          if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
            if (~parsedEnd.indexOf(" ")) {
              parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
            } else {
              offset = _offsetToPx(parsedEnd.substr(2), size);
              parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

              parsedEndTrigger = trigger;
            }
          }

          end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
          change = end - start || (start -= 0.01) && 0.001;
          offset = 0;
          i = triggerIndex;

          while (i--) {
            curTrigger = _triggers[i];
            curPin = curTrigger.pin;

            if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {
              cs = curTrigger.end - curTrigger.start;

              if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
                // numeric start values shouldn't be offset at all - treat them as absolute
                offset += cs * (1 - curTrigger.progress);
              }

              curPin === pin && (otherPinOffset += cs);
            }
          }

          start += offset;
          end += offset;
          self._pinPush = otherPinOffset;

          if (markerStart && offset) {
            // offset the markers if necessary
            cs = {};
            cs[direction.a] = "+=" + offset;
            pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
            gsap.set([markerStart, markerEnd], cs);
          }

          if (pin) {
            cs = _getComputedStyle(pin);
            isVertical = direction === _vertical;
            scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

            pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
            !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/

            _swapPinIn(pin, spacer, cs);

            pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

            bounds = _getBounds(pin, true);
            oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

            if (pinSpacing) {
              spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
              spacerState.t = spacer;
              i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
              i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

              _setState(spacerState);

              useFixedPosition && scrollFunc(prevScroll);
            }

            if (useFixedPosition) {
              override = {
                top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                boxSizing: "border-box",
                position: "fixed"
              };
              override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
              override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
              override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
              override[_padding] = cs[_padding];
              override[_padding + _Top] = cs[_padding + _Top];
              override[_padding + _Right] = cs[_padding + _Right];
              override[_padding + _Bottom] = cs[_padding + _Bottom];
              override[_padding + _Left] = cs[_padding + _Left];
              pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            }

            if (animation) {
              // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
              initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

              _suppressOverwrites(1);

              animation.render(animation.duration(), true, true);
              pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
              change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

              animation.render(0, true, true);
              initted || animation.invalidate();

              _suppressOverwrites(0);
            } else {
              pinChange = change;
            }
          } else if (trigger && scrollFunc() && !containerAnimation) {
            // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
            bounds = trigger.parentNode;

            while (bounds && bounds !== _body) {
              if (bounds._pinOffset) {
                start -= bounds._pinOffset;
                end -= bounds._pinOffset;
              }

              bounds = bounds.parentNode;
            }
          }

          revertedPins && revertedPins.forEach(function (t) {
            return t.revert(false);
          });
          self.start = start;
          self.end = end;
          scroll1 = scroll2 = scrollFunc(); // reset velocity

          if (!containerAnimation) {
            scroll1 < prevScroll && scrollFunc(prevScroll);
            self.scroll.rec = 0;
          }

          self.revert(false);

          if (snapDelayedCall) {
            lastSnap = -1;
            self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value

            snapDelayedCall.restart(true);
          }

          _refreshing = 0;
          animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

          if (prevProgress !== self.progress || containerAnimation) {
            // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
            animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

            self.progress = prevProgress;
            self.update(0, 0, 1);
          }

          pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //			scrubTween && scrubTween.invalidate();

          onRefresh && onRefresh(self);
        };

        self.getVelocity = function () {
          return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
        };

        self.endAnimation = function () {
          _endAnimation(self.callbackAnimation);

          if (animation) {
            scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
          }
        };

        self.labelToScroll = function (label) {
          return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
        };

        self.getTrailing = function (name) {
          var i = _triggers.indexOf(self),
              a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

          return (_isString(name) ? a.filter(function (t) {
            return t.vars.preventOverlaps === name;
          }) : a).filter(function (t) {
            return self.direction > 0 ? t.end <= start : t.start >= end;
          });
        };

        self.update = function (reset, recordVelocity, forceFake) {
          if (containerAnimation && !forceFake && !reset) {
            return;
          }

          var scroll = self.scroll(),
              p = reset ? 0 : (scroll - start) / change,
              clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
              prevProgress = self.progress,
              isActive,
              wasActive,
              toggleState,
              action,
              stateChanged,
              toggled,
              isAtMax,
              isTakingAction;

          if (recordVelocity) {
            scroll2 = scroll1;
            scroll1 = containerAnimation ? scrollFunc() : scroll;

            if (snap) {
              snap2 = snap1;
              snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
            }
          } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


          anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

          if (clipped !== prevProgress && self.enabled) {
            isActive = self.isActive = !!clipped && clipped < 1;
            wasActive = !!prevProgress && prevProgress < 1;
            toggled = isActive !== wasActive;
            stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

            self.direction = clipped > prevProgress ? 1 : -1;
            self.progress = clipped;

            if (stateChanged && !_refreshing) {
              toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

              if (isToggle) {
                action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

                isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
              }
            }

            preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
              return t.endAnimation();
            }));

            if (!isToggle) {
              if (scrubTween && !_refreshing && !_startup) {
                (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

                if (scrubTween.resetTo) {
                  scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
                } else {
                  // legacy support (courtesy), before 3.10.0
                  scrubTween.vars.totalProgress = clipped;
                  scrubTween.invalidate().restart();
                }
              } else if (animation) {
                animation.totalProgress(clipped, !!_refreshing);
              }
            }

            if (pin) {
              reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

              if (!useFixedPosition) {
                pinSetter(_round(pinStart + pinChange * clipped));
              } else if (stateChanged) {
                isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

                if (pinReparent) {
                  if (!reset && (isActive || isAtMax)) {
                    var bounds = _getBounds(pin, true),
                        _offset = scroll - start;

                    _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                  } else {
                    _reparent(pin, spacer);
                  }
                }

                _setState(isActive || isAtMax ? pinActiveState : pinState);

                pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
              }
            }

            snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
            toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
              return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
            }); // classes could affect positioning, so do it even if reset or refreshing is true.

            onUpdate && !isToggle && !reset && onUpdate(self);

            if (stateChanged && !_refreshing) {
              if (isToggle) {
                if (isTakingAction) {
                  if (action === "complete") {
                    animation.pause().totalProgress(1);
                  } else if (action === "reset") {
                    animation.restart(true).pause();
                  } else if (action === "restart") {
                    animation.restart(true);
                  } else {
                    animation[action]();
                  }
                }

                onUpdate && onUpdate(self);
              }

              if (toggled || !_limitCallbacks) {
                // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
                onToggle && toggled && _callback(self, onToggle);
                callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

                if (!toggled) {
                  // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
                  toggleState = clipped === 1 ? 1 : 3;
                  callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                }
              }

              if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                _endAnimation(self.callbackAnimation);

                scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
              }
            } else if (isToggle && onUpdate && !_refreshing) {
              onUpdate(self);
            }
          } // update absolutely-positioned markers (only if the scroller isn't the viewport)


          if (markerEndSetter) {
            var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
            markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
            markerEndSetter(n);
          }

          caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
        };

        self.enable = function (reset, refresh) {
          if (!self.enabled) {
            self.enabled = true;

            _addListener(scroller, "resize", _onResize);

            _addListener(isViewport ? _doc : scroller, "scroll", _onScroll);

            onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

            if (reset !== false) {
              self.progress = prevProgress = 0;
              scroll1 = scroll2 = lastSnap = scrollFunc();
            }

            refresh !== false && self.refresh();
          }
        };

        self.getTween = function (snap) {
          return snap && tweenTo ? tweenTo.tween : scrubTween;
        };

        self.setPositions = function (newStart, newEnd) {
          // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
          if (pin) {
            pinStart += newStart - start;
            pinChange += newEnd - newStart - change;
          }

          self.start = start = newStart;
          self.end = end = newEnd;
          change = newEnd - newStart;
          self.update();
        };

        self.disable = function (reset, allowAnimation) {
          if (self.enabled) {
            reset !== false && self.revert();
            self.enabled = self.isActive = false;
            allowAnimation || scrubTween && scrubTween.pause();
            prevScroll = 0;
            pinCache && (pinCache.uncache = 1);
            onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

            if (snapDelayedCall) {
              snapDelayedCall.pause();
              tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
            }

            if (!isViewport) {
              var i = _triggers.length;

              while (i--) {
                if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                  return; //don't remove the listeners if there are still other triggers referencing it.
                }
              }

              _removeListener(scroller, "resize", _onResize);

              _removeListener(scroller, "scroll", _onScroll);
            }
          }
        };

        self.kill = function (revert, allowAnimation) {
          self.disable(revert, allowAnimation);
          scrubTween && !allowAnimation && scrubTween.kill();
          id && delete _ids[id];

          var i = _triggers.indexOf(self);

          i >= 0 && _triggers.splice(i, 1);
          i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
          // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

          i = 0;

          _triggers.forEach(function (t) {
            return t.scroller === self.scroller && (i = 1);
          });

          i || (self.scroll.rec = 0);

          if (animation) {
            animation.scrollTrigger = null;
            revert && animation.render(-1);
            allowAnimation || animation.kill();
          }

          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.parentNode && m.parentNode.removeChild(m);
          });
          _primary === self && (_primary = 0);

          if (pin) {
            pinCache && (pinCache.uncache = 1);
            i = 0;

            _triggers.forEach(function (t) {
              return t.pin === pin && i++;
            });

            i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
          }

          vars.onKill && vars.onKill(self);
        };

        self.enable(false, false);
        customRevertReturn && customRevertReturn(self);
        !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
          return start || end || self.refresh();
        }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
      };

      ScrollTrigger.register = function register(core) {
        if (!_coreInitted) {
          gsap = core || _getGSAP();
          _windowExists() && window.document && ScrollTrigger.enable();
          _coreInitted = _enabled;
        }

        return _coreInitted;
      };

      ScrollTrigger.defaults = function defaults(config) {
        if (config) {
          for (var p in config) {
            _defaults[p] = config[p];
          }
        }

        return _defaults;
      };

      ScrollTrigger.disable = function disable(reset, kill) {
        _enabled = 0;

        _triggers.forEach(function (trigger) {
          return trigger[kill ? "kill" : "disable"](reset);
        });

        _removeListener(_win, "wheel", _onScroll);

        _removeListener(_doc, "scroll", _onScroll);

        clearInterval(_syncInterval);

        _removeListener(_doc, "touchcancel", _passThrough);

        _removeListener(_body, "touchstart", _passThrough);

        _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

        _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

        _resizeDelay.kill();

        _iterateAutoRefresh(_removeListener);

        for (var i = 0; i < _scrollers.length; i += 3) {
          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
        }
      };

      ScrollTrigger.enable = function enable() {
        _win = window;
        _doc = document;
        _docEl = _doc.documentElement;
        _body = _doc.body;

        if (gsap) {
          _toArray = gsap.utils.toArray;
          _clamp = gsap.utils.clamp;
          _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
          gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

          if (_body) {
            _enabled = 1;
            Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

            ScrollTrigger.isTouch = Observer.isTouch;
            _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

            _addListener(_win, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.


            _root = [_win, _doc, _docEl, _body];
            ScrollTrigger.matchMedia({
              // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
              "(orientation: portrait)": function orientationPortrait() {
                _setBaseDimensions();

                return _setBaseDimensions;
              }
            });

            _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


            var bodyStyle = _body.style,
                border = bodyStyle.borderTopStyle,
                bounds,
                i;
            bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

            bounds = _getBounds(_body);
            _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

            _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
            border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

            _syncInterval = setInterval(_sync, 250);
            gsap.delayedCall(0.5, function () {
              return _startup = 0;
            });

            _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


            _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


            _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

            _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

            _transformProp = gsap.utils.checkPrefix("transform");

            _stateProps.push(_transformProp);

            _coreInitted = _getTime();
            _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
            _autoRefresh = [_doc, "visibilitychange", function () {
              var w = _win.innerWidth,
                  h = _win.innerHeight;

              if (_doc.hidden) {
                _prevWidth = w;
                _prevHeight = h;
              } else if (_prevWidth !== w || _prevHeight !== h) {
                _onResize();
              }
            }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];

            _iterateAutoRefresh(_addListener);

            _triggers.forEach(function (trigger) {
              return trigger.enable(0, 1);
            });

            for (i = 0; i < _scrollers.length; i += 3) {
              _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

              _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
            }
          }
        }
      };

      ScrollTrigger.config = function config(vars) {
        "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
        var ms = vars.syncInterval;
        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
        "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

        if ("autoRefreshEvents" in vars) {
          _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
          _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
        }
      };

      ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
        var t = _getTarget(target),
            i = _scrollers.indexOf(t),
            isViewport = _isViewport(t);

        if (~i) {
          _scrollers.splice(i, isViewport ? 6 : 2);
        }

        if (vars) {
          isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);
        }
      };

      ScrollTrigger.matchMedia = function matchMedia(vars) {
        // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
        var mq, p, i, func, result;

        for (p in vars) {
          i = _media.indexOf(p);
          func = vars[p];
          _creatingMedia = p;

          if (p === "all") {
            func();
          } else {
            mq = _win.matchMedia(p);

            if (mq) {
              mq.matches && (result = func());

              if (~i) {
                _media[i + 1] = _combineFunc(_media[i + 1], func);
                _media[i + 2] = _combineFunc(_media[i + 2], result);
              } else {
                i = _media.length;

                _media.push(p, func, result);

                mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
              }

              _media[i + 3] = mq.matches;
            }
          }

          _creatingMedia = 0;
        }

        return _media;
      };

      ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
        query || (_media.length = 0);
        query = _media.indexOf(query);
        query >= 0 && _media.splice(query, 4);
      };

      ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
        var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
            offset = bounds[horizontal ? _width : _height] * ratio || 0;
        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
      };

      ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
        _isString(element) && (element = _getTarget(element));
        var bounds = element.getBoundingClientRect(),
            size = bounds[horizontal ? _width : _height],
            offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
      };

      return ScrollTrigger;
    }();
    ScrollTrigger.version = "3.10.4";

    ScrollTrigger.saveStyles = function (targets) {
      return targets ? _toArray(targets).forEach(function (target) {
        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
        if (target && target.style) {
          var i = _savedStyles.indexOf(target);

          i >= 0 && _savedStyles.splice(i, 5);

          _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
        }
      }) : _savedStyles;
    };

    ScrollTrigger.revert = function (soft, media) {
      return _revertAll(!soft, media);
    };

    ScrollTrigger.create = function (vars, animation) {
      return new ScrollTrigger(vars, animation);
    };

    ScrollTrigger.refresh = function (safe) {
      return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
    };

    ScrollTrigger.update = _updateAll;
    ScrollTrigger.clearScrollMemory = _clearScrollMemory;

    ScrollTrigger.maxScroll = function (element, horizontal) {
      return _maxScroll(element, horizontal ? _horizontal : _vertical);
    };

    ScrollTrigger.getScrollFunc = function (element, horizontal) {
      return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
    };

    ScrollTrigger.getById = function (id) {
      return _ids[id];
    };

    ScrollTrigger.getAll = function () {
      return _triggers.filter(function (t) {
        return t.vars.id !== "ScrollSmoother";
      });
    }; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


    ScrollTrigger.isScrolling = function () {
      return !!_lastScrollTime;
    };

    ScrollTrigger.snapDirectional = _snapDirectional;

    ScrollTrigger.addEventListener = function (type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    };

    ScrollTrigger.removeEventListener = function (type, callback) {
      var a = _listeners[type],
          i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    };

    ScrollTrigger.batch = function (targets, vars) {
      var result = [],
          varsCopy = {},
          interval = vars.interval || 0.016,
          batchMax = vars.batchMax || 1e9,
          proxyCallback = function proxyCallback(type, callback) {
        var elements = [],
            triggers = [],
            delay = gsap.delayedCall(interval, function () {
          callback(elements, triggers);
          elements = [];
          triggers = [];
        }).pause();
        return function (self) {
          elements.length || delay.restart(true);
          elements.push(self.trigger);
          triggers.push(self);
          batchMax <= elements.length && delay.progress(1);
        };
      },
          p;

      for (p in vars) {
        varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
      }

      if (_isFunction(batchMax)) {
        batchMax = batchMax();

        _addListener(ScrollTrigger, "refresh", function () {
          return batchMax = vars.batchMax();
        });
      }

      _toArray(targets).forEach(function (target) {
        var config = {};

        for (p in varsCopy) {
          config[p] = varsCopy[p];
        }

        config.trigger = target;
        result.push(ScrollTrigger.create(config));
      });

      return result;
    }; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


    var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
      current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
      return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
    },
        _allowNativePanning = function _allowNativePanning(target, direction) {
      if (direction === true) {
        target.style.removeProperty("touch-action");
      } else {
        target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
      }

      target === _docEl && _allowNativePanning(_body, direction);
    },
        _overflow = {
      auto: 1,
      scroll: 1
    },
        _nestedScroll = function _nestedScroll(_ref5) {
      var event = _ref5.event,
          target = _ref5.target,
          axis = _ref5.axis;

      var node = (event.changedTouches ? event.changedTouches[0] : event).target,
          cache = node._gsap || gsap.core.getCache(node),
          time = _getTime(),
          cs;

      if (!cache._isScrollT || time - cache._isScrollT > 2000) {
        // cache for 2 seconds to improve performance.
        while (node && node.scrollHeight <= node.clientHeight) {
          node = node.parentNode;
        }

        cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
        cache._isScrollT = time;
      }

      (cache._isScroll || axis === "x") && (event._gsapAllow = true);
    },
        // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
    _inputObserver = function _inputObserver(target, type, inputs, nested) {
      return Observer.create({
        target: target,
        capture: true,
        debounce: false,
        lockAxis: true,
        type: type,
        onWheel: nested = nested && _nestedScroll,
        onPress: nested,
        onDrag: nested,
        onScroll: nested,
        onEnable: function onEnable() {
          return inputs && _addListener(_doc, Observer.eventTypes[0], _captureInputs, false, true);
        },
        onDisable: function onDisable() {
          return _removeListener(_doc, Observer.eventTypes[0], _captureInputs, true);
        }
      });
    },
        _inputExp = /(input|label|select|textarea)/i,
        _inputIsFocused,
        _captureInputs = function _captureInputs(e) {
      var isInput = _inputExp.test(e.target.tagName);

      if (isInput || _inputIsFocused) {
        e._gsapAllow = true;
        _inputIsFocused = isInput;
      }
    },
        _getScrollNormalizer = function _getScrollNormalizer(vars) {
      _isObject(vars) || (vars = {});
      vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
      vars.type || (vars.type = "wheel,touch");
      vars.debounce = !!vars.debounce;
      vars.id = vars.id || "normalizer";

      var _vars2 = vars,
          normalizeScrollX = _vars2.normalizeScrollX,
          momentum = _vars2.momentum,
          allowNestedScroll = _vars2.allowNestedScroll,
          self,
          maxY,
          target = _getTarget(vars.target) || _docEl,
          smoother = gsap.core.globals().ScrollSmoother,
          content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smoother && smoother.get() && smoother.get().content()),
          scrollFuncY = _getScrollFunc(target, _vertical),
          scrollFuncX = _getScrollFunc(target, _horizontal),
          scale = 1,
          initialScale = (Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
          wheelRefresh = 0,
          resolveMomentumDuration = _isFunction(momentum) ? function () {
        return momentum(self);
      } : function () {
        return momentum || 2.8;
      },
          skipTouchMove,
          lastRefreshID,
          inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
          resumeTouchMove = function resumeTouchMove() {
        return skipTouchMove = false;
      },
          scrollClampX = _passThrough,
          scrollClampY = _passThrough,
          updateClamps = function updateClamps() {
        maxY = _maxScroll(target, _vertical);
        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _horizontal)));
        lastRefreshID = _refreshID;
      },
          ignoreDrag = function ignoreDrag() {
        if (skipTouchMove) {
          requestAnimationFrame(resumeTouchMove); // we MUST wait for a requestAnimationFrame, otherwise iOS will misreport the value.

          var offset = _round(self.deltaY / 2),
              scroll = scrollClampY(scrollFuncY.v - offset);

          if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
            scrollFuncY.offset = scroll - scrollFuncY.v;
            content.style.transform = "translateY(" + -scrollFuncY.offset + "px)";
            content._gsap && (content._gsap.y = -scrollFuncY.offset + "px");
            scrollFuncY.cacheID = _scrollers.cache;

            _updateAll();
          }

          return true;
        }

        if (content) {
          content.style.transform = "translateY(0px)";
          scrollFuncY.offset = scrollFuncY.cacheID = 0;
          content._gsap && (content._gsap.y = "0px");
        }

        skipTouchMove = true;
      },
          tween,
          startScrollX,
          startScrollY,
          onStopDelayedCall,
          onResize = function onResize() {
        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
        updateClamps();

        if (tween.isActive() && tween.vars.scrollY > maxY) {
          scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
        }
      };

      vars.ignoreCheck = function (e) {
        return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
      };

      vars.onPress = function () {
        var prevScale = scale;
        scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
        tween.pause();
        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
        skipTouchMove = false;
        startScrollX = scrollFuncX();
        startScrollY = scrollFuncY();
        updateClamps();
        lastRefreshID = _refreshID;
      };

      vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
        if (content) {
          content.style.transform = "translateY(0px)";
          scrollFuncY.offset = scrollFuncY.cacheID = 0;
          content._gsap && (content._gsap.y = "0px");
        }

        if (!wasDragging) {
          onStopDelayedCall.restart(true);
        } else {
          _scrollers.cache++; // make sure we're pulling the non-cached value
          // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

          var dur = resolveMomentumDuration(),
              currentScroll,
              endScroll;

          if (normalizeScrollX) {
            currentScroll = scrollFuncX();
            endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
            tween.vars.scrollX = scrollClampX(endScroll);
          }

          currentScroll = scrollFuncY();
          endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
          tween.vars.scrollY = scrollClampY(endScroll);
          tween.invalidate().duration(dur).play(0.01);

          if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
            // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
            gsap.to({}, {
              onUpdate: onResize,
              duration: dur
            });
          }
        }
      };

      vars.onWheel = function () {
        tween._ts && tween.pause();

        if (_getTime() - wheelRefresh > 1000) {
          // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
          lastRefreshID = 0;
          wheelRefresh = _getTime();
        }
      };

      vars.onChange = function (self, dx, dy, xArray, yArray) {
        _refreshID !== lastRefreshID && updateClamps();
        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

        dy && scrollFuncY(scrollClampY(yArray[2] === dy ? startScrollY + (self.startY - self.y) : scrollFuncY() + dy - yArray[1]));

        _updateAll();
      };

      vars.onEnable = function () {
        _allowNativePanning(target, normalizeScrollX ? false : "x");

        _addListener(_win, "resize", onResize);

        inputObserver.enable();
      };

      vars.onDisable = function () {
        _allowNativePanning(target, true);

        _removeListener(_win, "resize", onResize);

        inputObserver.kill();
      };

      self = new Observer(vars);
      self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

      _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

      onStopDelayedCall = self._dc;
      tween = gsap.to(self, {
        ease: "power4",
        paused: true,
        scrollX: normalizeScrollX ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        onComplete: onStopDelayedCall.vars.onComplete
      });
      return self;
    };

    ScrollTrigger.sort = function (func) {
      return _triggers.sort(func || function (a, b) {
        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
      });
    };

    ScrollTrigger.observe = function (vars) {
      return new Observer(vars);
    };

    ScrollTrigger.normalizeScroll = function (vars) {
      if (typeof vars === "undefined") {
        return _normalizer;
      }

      if (vars === true && _normalizer) {
        return _normalizer.enable();
      }

      if (vars === false) {
        return _normalizer && _normalizer.kill();
      }

      var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
      _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
      _isViewport(normalizer.target) && (_normalizer = normalizer);
      return normalizer;
    };

    ScrollTrigger.core = {
      // smaller file size way to leverage in ScrollSmoother and Observer
      _getVelocityProp: _getVelocityProp,
      _inputObserver: _inputObserver,
      _scrollers: _scrollers,
      _proxies: _proxies,
      bridge: {
        // when normalizeScroll sets the scroll position (ss = setScroll)
        ss: function ss() {
          _lastScrollTime || _dispatch("scrollStart");
          _lastScrollTime = _getTime();
        },
        // a way to get the _refreshing value in Observer
        ref: function ref() {
          return _refreshing;
        }
      }
    };
    _getGSAP() && gsap.registerPlugin(ScrollTrigger);

    var gsapWithCSS = gsap$2.registerPlugin(CSSPlugin) || gsap$2; // to protect from tree shaking
    	gsapWithCSS.core.Tween;

    //BONUS EXPORTS
    //export * from "./DrawSVGPlugin.js";
    //export * from "./Physics2DPlugin.js";
    //export * from "./PhysicsPropsPlugin.js";
    //export * from "./ScrambleTextPlugin.js";
    //export * from "./CustomBounce.js";
    //export * from "./CustomWiggle.js";
    //export * from "./GSDevTools.js";
    //export * from "./InertiaPlugin.js";
    //export * from "./MorphSVGPlugin.js";
    //export * from "./MotionPathHelper.js";
    //export * from "./ScrollSmoother.js";
    //export * from "./SplitText.js";

    /* src/components/byPage/actions/vis/Legend.svelte generated by Svelte v3.48.0 */
    const file$c = "src/components/byPage/actions/vis/Legend.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (24:16) {#each  $data.schema.hazards.data as obj, i}
    function create_each_block_1$2(ctx) {
    	let g;
    	let circle;
    	let path;
    	let path_d_value;
    	let text_1;
    	let raw_value = /*obj*/ ctx[8].Alias + "";
    	let g_class_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			circle = svg_element("circle");
    			path = svg_element("path");
    			text_1 = svg_element("text");
    			attr_dev(circle, "r", /*iconRadius*/ ctx[3]);
    			attr_dev(circle, "class", "hazard-circle  svelte-1ks9sl9");
    			add_location(circle, file$c, 25, 20, 1286);
    			attr_dev(path, "class", "hazard-icon svelte-1ks9sl9");
    			attr_dev(path, "d", path_d_value = icons[slugify(/*obj*/ ctx[8].Hazard)]);
    			add_location(path, file$c, 26, 20, 1358);
    			attr_dev(text_1, "class", "hazard-label svelte-1ks9sl9");
    			set_style(text_1, "transform", "translate(0px, " + (/*iconRadius*/ ctx[3] + 25) + "px)");
    			add_location(text_1, file$c, 27, 20, 1447);
    			attr_dev(g, "class", g_class_value = "" + (null_to_empty(slugify(/*obj*/ ctx[8].Hazard)) + " svelte-1ks9sl9"));
    			set_style(g, "transform", "translate(" + /*i*/ ctx[7] * /*iconRadius*/ ctx[3] * 3.25 + "px, " + 0 + "px)");
    			add_location(g, file$c, 24, 16, 1169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, circle);
    			append_dev(g, path);
    			append_dev(g, text_1);
    			text_1.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 4 && path_d_value !== (path_d_value = icons[slugify(/*obj*/ ctx[8].Hazard)])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*$data*/ 4 && raw_value !== (raw_value = /*obj*/ ctx[8].Alias + "")) text_1.innerHTML = raw_value;
    			if (dirty & /*$data*/ 4 && g_class_value !== (g_class_value = "" + (null_to_empty(slugify(/*obj*/ ctx[8].Hazard)) + " svelte-1ks9sl9"))) {
    				attr_dev(g, "class", g_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(24:16) {#each  $data.schema.hazards.data as obj, i}",
    		ctx
    	});

    	return block;
    }

    // (65:16) {#each  $data.schema.actionScale.data.map(d => d.Scale) as scale, i}
    function create_each_block$6(ctx) {
    	let g;
    	let circle0;
    	let circle0_r_value;
    	let circle1;
    	let circle1_r_value;
    	let text_1;
    	let raw_value = /*scale*/ ctx[5] + "";
    	let g_class_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			text_1 = svg_element("text");
    			attr_dev(circle0, "r", circle0_r_value = /*$ui*/ ctx[1].vis.nodes.scales.radiusScale(/*scale*/ ctx[5]));
    			attr_dev(circle0, "class", "scale-circle  svelte-1ks9sl9");
    			add_location(circle0, file$c, 66, 20, 4047);
    			attr_dev(circle1, "r", circle1_r_value = /*dims*/ ctx[0].nodeRadius + 2.5);
    			attr_dev(circle1, "class", "scale-node svelte-1ks9sl9");
    			add_location(circle1, file$c, 67, 20, 4147);
    			attr_dev(text_1, "class", "scale-label svelte-1ks9sl9");
    			set_style(text_1, "transform", "translate(0px, " + (/*iconRadius*/ ctx[3] + 25) + "px)");
    			add_location(text_1, file$c, 68, 20, 4226);
    			attr_dev(g, "class", g_class_value = "" + (null_to_empty(slugify(/*scale*/ ctx[5])) + " svelte-1ks9sl9"));
    			set_style(g, "transform", "translate(" + /*i*/ ctx[7] * /*iconRadius*/ ctx[3] * 3.35 + "px, " + 0 + "px)");
    			add_location(g, file$c, 65, 16, 3935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, circle0);
    			append_dev(g, circle1);
    			append_dev(g, text_1);
    			text_1.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$ui, $data*/ 6 && circle0_r_value !== (circle0_r_value = /*$ui*/ ctx[1].vis.nodes.scales.radiusScale(/*scale*/ ctx[5]))) {
    				attr_dev(circle0, "r", circle0_r_value);
    			}

    			if (dirty & /*dims*/ 1 && circle1_r_value !== (circle1_r_value = /*dims*/ ctx[0].nodeRadius + 2.5)) {
    				attr_dev(circle1, "r", circle1_r_value);
    			}

    			if (dirty & /*$data*/ 4 && raw_value !== (raw_value = /*scale*/ ctx[5] + "")) text_1.innerHTML = raw_value;
    			if (dirty & /*$data*/ 4 && g_class_value !== (g_class_value = "" + (null_to_empty(slugify(/*scale*/ ctx[5])) + " svelte-1ks9sl9"))) {
    				attr_dev(g, "class", g_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(65:16) {#each  $data.schema.actionScale.data.map(d => d.Scale) as scale, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let g10;
    	let g9;
    	let g1;
    	let text0;
    	let t0;
    	let g0;
    	let g6;
    	let text1;
    	let t1;
    	let g5;
    	let g2;
    	let path0;
    	let text2;
    	let tspan0;
    	let t2;
    	let t3;
    	let tspan1;
    	let t4;
    	let t5;
    	let g3;
    	let path1;
    	let text3;
    	let tspan2;
    	let t6;
    	let tspan3;
    	let t7;
    	let t8;
    	let g4;
    	let path2;
    	let path3;
    	let text4;
    	let tspan4;
    	let t9;
    	let tspan5;
    	let t10;
    	let t11;
    	let g8;
    	let text5;
    	let t12;
    	let g7;
    	let g10_transition;
    	let current;
    	let each_value_1 = /*$data*/ ctx[2].schema.hazards.data;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let each_value = /*$data*/ ctx[2].schema.actionScale.data.map(func$1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g10 = svg_element("g");
    			g9 = svg_element("g");
    			g1 = svg_element("g");
    			text0 = svg_element("text");
    			t0 = text$1("Hazards addressed");
    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g6 = svg_element("g");
    			text1 = svg_element("text");
    			t1 = text$1("Adaptation approach");
    			g5 = svg_element("g");
    			g2 = svg_element("g");
    			path0 = svg_element("path");
    			text2 = svg_element("text");
    			tspan0 = svg_element("tspan");
    			t2 = text$1("Reduce");
    			t3 = space();
    			tspan1 = svg_element("tspan");
    			t4 = text$1("risk");
    			t5 = space();
    			g3 = svg_element("g");
    			path1 = svg_element("path");
    			text3 = svg_element("text");
    			tspan2 = svg_element("tspan");
    			t6 = text$1("Reduce");
    			tspan3 = svg_element("tspan");
    			t7 = text$1("risk");
    			t8 = space();
    			g4 = svg_element("g");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			text4 = svg_element("text");
    			tspan4 = svg_element("tspan");
    			t9 = text$1("Improve risk");
    			tspan5 = svg_element("tspan");
    			t10 = text$1("and resilience");
    			t11 = space();
    			g8 = svg_element("g");
    			text5 = svg_element("text");
    			t12 = text$1("Action scale ");
    			g7 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(text0, "class", "legend-title svelte-1ks9sl9");
    			set_style(text0, "transform", "translate(0px, " + (-/*iconRadius*/ ctx[3] - 20) + "px)");
    			add_location(text0, file$c, 21, 12, 861);
    			set_style(g0, "transform", "translate(" + -(/*$data*/ ctx[2].schema.hazards.data.length - 1) * 3.25 * 0.5 * /*iconRadius*/ ctx[3] + "px, 0px)");
    			add_location(g0, file$c, 22, 12, 983);
    			attr_dev(g1, "class", "legend-group svelte-1ks9sl9");
    			set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.hazards + "px, 0px)");
    			toggle_class(g1, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.hazards);
    			add_location(g1, file$c, 20, 8, 682);
    			attr_dev(text1, "class", "legend-title center svelte-1ks9sl9");
    			set_style(text1, "transform", "translate(0px, " + (-/*iconRadius*/ ctx[3] - 20) + "px)");
    			add_location(text1, file$c, 35, 12, 1859);
    			attr_dev(path0, "class", "approach-group risk svelte-1ks9sl9");
    			attr_dev(path0, "d", triangle$1(/*iconRadius*/ ctx[3], 'down'));
    			add_location(path0, file$c, 38, 20, 2097);
    			add_location(tspan0, file$c, 40, 24, 2302);
    			attr_dev(tspan1, "dy", "20");
    			attr_dev(tspan1, "x", "0");
    			add_location(tspan1, file$c, 41, 24, 2348);
    			attr_dev(text2, "class", "approach-label risk svelte-1ks9sl9");
    			set_style(text2, "transform", "translate(0px, " + (/*iconRadius*/ ctx[3] + 10) + "px)");
    			add_location(text2, file$c, 39, 20, 2186);
    			set_style(g2, "transform", "translate(" + -/*iconRadius*/ ctx[3] * 3.5 + "px, " + 0 + "px)");
    			add_location(g2, file$c, 37, 16, 2011);
    			attr_dev(path1, "class", "approach-group resilience svelte-1ks9sl9");
    			attr_dev(path1, "d", triangle$1(/*iconRadius*/ ctx[3], 'up'));
    			set_style(path1, "transform", "translate(0px, " + 0 + "px)");
    			add_location(path1, file$c, 45, 20, 2531);
    			add_location(tspan2, file$c, 47, 24, 2784);
    			attr_dev(tspan3, "dy", "20");
    			attr_dev(tspan3, "x", "0");
    			add_location(tspan3, file$c, 47, 45, 2805);
    			attr_dev(text3, "class", "approach-label risk svelte-1ks9sl9");
    			set_style(text3, "transform", "translate(0px, " + (/*iconRadius*/ ctx[3] + 10) + "px)");
    			add_location(text3, file$c, 46, 20, 2668);
    			set_style(g3, "transform", "translate(" + /*iconRadius*/ ctx[3] * 3.5 + "px, " + 0 + "px)");
    			add_location(g3, file$c, 44, 16, 2447);
    			attr_dev(path2, "class", "approach-group risk svelte-1ks9sl9");
    			attr_dev(path2, "d", triangle$1(/*iconRadius*/ ctx[3], 'down'));
    			add_location(path2, file$c, 51, 20, 2928);
    			attr_dev(path3, "class", "approach-group resilience svelte-1ks9sl9");
    			attr_dev(path3, "d", triangle$1(/*iconRadius*/ ctx[3], 'up'));
    			add_location(path3, file$c, 52, 20, 3019);
    			add_location(tspan4, file$c, 54, 24, 3242);
    			attr_dev(tspan5, "dy", "20");
    			attr_dev(tspan5, "x", "0");
    			add_location(tspan5, file$c, 54, 51, 3269);
    			attr_dev(text4, "class", "approach-label risk resilience svelte-1ks9sl9");
    			set_style(text4, "transform", "translate(" + 0 + "px, " + (/*iconRadius*/ ctx[3] + 10) + "px)");
    			add_location(text4, file$c, 53, 20, 3113);
    			add_location(g4, file$c, 50, 16, 2904);
    			add_location(g5, file$c, 36, 12, 1991);
    			attr_dev(g6, "class", "legend-group svelte-1ks9sl9");
    			set_style(g6, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.approach + "px, 0px)");
    			toggle_class(g6, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.approach);
    			add_location(g6, file$c, 34, 8, 1678);
    			attr_dev(text5, "class", "legend-title svelte-1ks9sl9");
    			set_style(text5, "transform", "translate(0px, " + (-/*iconRadius*/ ctx[3] - 20) + "px)");
    			add_location(text5, file$c, 62, 12, 3607);
    			set_style(g7, "transform", "translate(" + -(/*$data*/ ctx[2].schema.hazards.data.length - 1) * 3.35 * 0.5 * /*iconRadius*/ ctx[3] + "px, 0px)");
    			add_location(g7, file$c, 63, 12, 3725);
    			attr_dev(g8, "class", "legend-group svelte-1ks9sl9");
    			set_style(g8, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.scale + "px , 0px)");
    			toggle_class(g8, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.scale);
    			add_location(g8, file$c, 61, 8, 3431);
    			set_style(g9, "transform", "translate( 0px, " + (/*dims*/ ctx[0].height - 70) + "px)");
    			add_location(g9, file$c, 18, 4, 578);
    			attr_dev(g10, "id", "legend-container");
    			attr_dev(g10, "class", "svelte-1ks9sl9");
    			add_location(g10, file$c, 16, 0, 529);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g10, anchor);
    			append_dev(g10, g9);
    			append_dev(g9, g1);
    			append_dev(g1, text0);
    			append_dev(text0, t0);
    			append_dev(g1, g0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g0, null);
    			}

    			append_dev(g9, g6);
    			append_dev(g6, text1);
    			append_dev(text1, t1);
    			append_dev(g6, g5);
    			append_dev(g5, g2);
    			append_dev(g2, path0);
    			append_dev(g2, text2);
    			append_dev(text2, tspan0);
    			append_dev(tspan0, t2);
    			append_dev(text2, t3);
    			append_dev(text2, tspan1);
    			append_dev(tspan1, t4);
    			append_dev(text2, t5);
    			append_dev(g5, g3);
    			append_dev(g3, path1);
    			append_dev(g3, text3);
    			append_dev(text3, tspan2);
    			append_dev(tspan2, t6);
    			append_dev(text3, tspan3);
    			append_dev(tspan3, t7);
    			append_dev(text3, t8);
    			append_dev(g5, g4);
    			append_dev(g4, path2);
    			append_dev(g4, path3);
    			append_dev(g4, text4);
    			append_dev(text4, tspan4);
    			append_dev(tspan4, t9);
    			append_dev(text4, tspan5);
    			append_dev(tspan5, t10);
    			append_dev(text4, t11);
    			append_dev(g9, g8);
    			append_dev(g8, text5);
    			append_dev(text5, t12);
    			append_dev(g8, g7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g7, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*slugify, $data, iconRadius, icons*/ 12) {
    				each_value_1 = /*$data*/ ctx[2].schema.hazards.data;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (!current || dirty & /*$data*/ 4) {
    				set_style(g0, "transform", "translate(" + -(/*$data*/ ctx[2].schema.hazards.data.length - 1) * 3.25 * 0.5 * /*iconRadius*/ ctx[3] + "px, 0px)");
    			}

    			if (!current || dirty & /*dims, $ui*/ 3) {
    				set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.hazards + "px, 0px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g1, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.hazards);
    			}

    			if (!current || dirty & /*dims, $ui*/ 3) {
    				set_style(g6, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.approach + "px, 0px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g6, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.approach);
    			}

    			if (dirty & /*slugify, $data, iconRadius, dims, $ui*/ 15) {
    				each_value = /*$data*/ ctx[2].schema.actionScale.data.map(func$1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*$data*/ 4) {
    				set_style(g7, "transform", "translate(" + -(/*$data*/ ctx[2].schema.hazards.data.length - 1) * 3.35 * 0.5 * /*iconRadius*/ ctx[3] + "px, 0px)");
    			}

    			if (!current || dirty & /*dims, $ui*/ 3) {
    				set_style(g8, "transform", "translate(" + /*dims*/ ctx[0].width * /*$ui*/ ctx[1].state.actionVis.legend.scale + "px , 0px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g8, "hidden", !/*$ui*/ ctx[1].state.actionVis.legend.scale);
    			}

    			if (!current || dirty & /*dims*/ 1) {
    				set_style(g9, "transform", "translate( 0px, " + (/*dims*/ ctx[0].height - 70) + "px)");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!g10_transition) g10_transition = create_bidirectional_transition(g10, fade, {}, true);
    				g10_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!g10_transition) g10_transition = create_bidirectional_transition(g10, fade, {}, false);
    			g10_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g10);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (detaching && g10_transition) g10_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = d => d.Scale;

    function instance$c($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(1, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(2, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Legend', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions
    	const iconRadius = dims.nodeRadius * 1.5;

    	// Action node shape
    	const arc$1 = arc();

    	const writable_props = ['dims'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Legend> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		icons,
    		triangle: triangle$1,
    		textWrap,
    		slugify,
    		dims,
    		iconRadius,
    		arc: arc$1,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $ui, $data, iconRadius];
    }

    class Legend extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$c, create_fragment$c, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Legend",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get dims() {
    		throw new Error("<Legend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Legend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Force.svelte generated by Svelte v3.48.0 */
    const file$b = "src/components/byPage/actions/vis/Force.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (115:16) {#if $ui.state.actionVis.nodes.shadow}
    function create_if_block_6$1(ctx) {
    	let circle;
    	let circle_class_value;
    	let circle_r_value;

    	function func(...args) {
    		return /*func*/ ctx[12](/*node*/ ctx[17], ...args);
    	}

    	function func_1(...args) {
    		return /*func_1*/ ctx[13](/*node*/ ctx[17], ...args);
    	}

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", circle_class_value = "node-shadow " + slugify(/*$data*/ ctx[2].schema.actionScale.data.filter(func)[0].Scale) + " svelte-ky4swr");
    			attr_dev(circle, "r", circle_r_value = /*$ui*/ ctx[3].vis.nodes.scales.radiusScale(/*$data*/ ctx[2].schema.actionScale.data.filter(func_1)[0].Scale));
    			add_location(circle, file$b, 115, 16, 3919);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$data, renderedNodes*/ 6 && circle_class_value !== (circle_class_value = "node-shadow " + slugify(/*$data*/ ctx[2].schema.actionScale.data.filter(func)[0].Scale) + " svelte-ky4swr")) {
    				attr_dev(circle, "class", circle_class_value);
    			}

    			if (dirty & /*$ui, $data, renderedNodes*/ 14 && circle_r_value !== (circle_r_value = /*$ui*/ ctx[3].vis.nodes.scales.radiusScale(/*$data*/ ctx[2].schema.actionScale.data.filter(func_1)[0].Scale))) {
    				attr_dev(circle, "r", circle_r_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(115:16) {#if $ui.state.actionVis.nodes.shadow}",
    		ctx
    	});

    	return block;
    }

    // (126:16) {#if $ui.state.actionVis.nodes.arcs}
    function create_if_block_5$1(ctx) {
    	let g;
    	let each_value_1 = /*node*/ ctx[17]["Hazard"];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "node-arcs");
    			add_location(g, file$b, 126, 16, 4532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*slugify, hazardSchema, renderedNodes, arc, dims, Math*/ 147) {
    				each_value_1 = /*node*/ ctx[17]["Hazard"];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(126:16) {#if $ui.state.actionVis.nodes.arcs}",
    		ctx
    	});

    	return block;
    }

    // (128:20) {#each node["Hazard"] as hazard, i }
    function create_each_block_1$1(ctx) {
    	let path;
    	let path_class_value;
    	let path_d_value;

    	function func_2(...args) {
    		return /*func_2*/ ctx[14](/*hazard*/ ctx[20], ...args);
    	}

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", path_class_value = "" + (null_to_empty(slugify(/*hazardSchema*/ ctx[4].filter(func_2)[0].Hazard)) + " svelte-ky4swr"));

    			attr_dev(path, "d", path_d_value = /*arc*/ ctx[7]({
    				innerRadius: /*dims*/ ctx[0].nodeRadius,
    				outerRadius: /*dims*/ ctx[0].nodeArcRadius,
    				startAngle: /*i*/ ctx[19] * (2 * Math.PI / /*node*/ ctx[17]["Hazard"].length),
    				endAngle: /*i*/ ctx[19] * (2 * Math.PI / /*node*/ ctx[17]["Hazard"].length) + 2 * Math.PI / /*node*/ ctx[17]["Hazard"].length
    			}));

    			add_location(path, file$b, 128, 24, 4637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*renderedNodes*/ 2 && path_class_value !== (path_class_value = "" + (null_to_empty(slugify(/*hazardSchema*/ ctx[4].filter(func_2)[0].Hazard)) + " svelte-ky4swr"))) {
    				attr_dev(path, "class", path_class_value);
    			}

    			if (dirty & /*dims, renderedNodes*/ 3 && path_d_value !== (path_d_value = /*arc*/ ctx[7]({
    				innerRadius: /*dims*/ ctx[0].nodeRadius,
    				outerRadius: /*dims*/ ctx[0].nodeArcRadius,
    				startAngle: /*i*/ ctx[19] * (2 * Math.PI / /*node*/ ctx[17]["Hazard"].length),
    				endAngle: /*i*/ ctx[19] * (2 * Math.PI / /*node*/ ctx[17]["Hazard"].length) + 2 * Math.PI / /*node*/ ctx[17]["Hazard"].length
    			}))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(128:20) {#each node[\\\"Hazard\\\"] as hazard, i }",
    		ctx
    	});

    	return block;
    }

    // (141:16) {#if $ui.state.actionVis.nodes.shapes}
    function create_if_block_1$3(ctx) {
    	let g;
    	let if_block = /*node*/ ctx[17]["Linked approach theme"] && create_if_block_2$3(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (if_block) if_block.c();
    			attr_dev(g, "class", "approach-triangles");
    			add_location(g, file$b, 141, 16, 5299);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			if (if_block) if_block.m(g, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*node*/ ctx[17]["Linked approach theme"]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$3(ctx);
    					if_block.c();
    					if_block.m(g, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(141:16) {#if $ui.state.actionVis.nodes.shapes}",
    		ctx
    	});

    	return block;
    }

    // (143:20) {#if node["Linked approach theme"]}
    function create_if_block_2$3(ctx) {
    	let show_if_1 = /*node*/ ctx[17]["Linked approach theme"].includes('Increase resilience');
    	let if_block0_anchor;
    	let show_if = /*node*/ ctx[17]["Linked approach theme"].includes('Reduce risk');
    	let if_block1_anchor;
    	let if_block0 = show_if_1 && create_if_block_4$1(ctx);
    	let if_block1 = show_if && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, if_block0_anchor, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderedNodes*/ 2) show_if_1 = /*node*/ ctx[17]["Linked approach theme"].includes('Increase resilience');

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*renderedNodes*/ 2) show_if = /*node*/ ctx[17]["Linked approach theme"].includes('Reduce risk');

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(if_block0_anchor);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(143:20) {#if node[\\\"Linked approach theme\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (144:24) {#if node["Linked approach theme"].includes('Increase resilience') }
    function create_if_block_4$1(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "approach-triangle resilience svelte-ky4swr");
    			attr_dev(path, "d", path_d_value = triangle$1(/*dims*/ ctx[0].nodeRadius, 'up'));
    			add_location(path, file$b, 144, 24, 5505);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path_d_value !== (path_d_value = triangle$1(/*dims*/ ctx[0].nodeRadius, 'up'))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(144:24) {#if node[\\\"Linked approach theme\\\"].includes('Increase resilience') }",
    		ctx
    	});

    	return block;
    }

    // (147:24) {#if node["Linked approach theme"].includes('Reduce risk') }
    function create_if_block_3$1(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "approach-triangle risk svelte-ky4swr");
    			attr_dev(path, "d", path_d_value = triangle$1(/*dims*/ ctx[0].nodeRadius, 'down'));
    			add_location(path, file$b, 147, 24, 5726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path_d_value !== (path_d_value = triangle$1(/*dims*/ ctx[0].nodeRadius, 'down'))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(147:24) {#if node[\\\"Linked approach theme\\\"].includes('Reduce risk') }",
    		ctx
    	});

    	return block;
    }

    // (155:16) {#if $ui.state.actionVis.nodes.symbols}
    function create_if_block$4(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "symbol svelte-ky4swr");

    			attr_dev(path, "d", path_d_value = /*arc*/ ctx[7]({
    				innerRadius: /*dims*/ ctx[0].nodeRadius * 0 + 0,
    				outerRadius: /*dims*/ ctx[0].nodeArcRadius * 0 + 8,
    				startAngle: 0,
    				endAngle: 2 * Math.PI
    			}));

    			add_location(path, file$b, 156, 16, 6040);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path_d_value !== (path_d_value = /*arc*/ ctx[7]({
    				innerRadius: /*dims*/ ctx[0].nodeRadius * 0 + 0,
    				outerRadius: /*dims*/ ctx[0].nodeArcRadius * 0 + 8,
    				startAngle: 0,
    				endAngle: 2 * Math.PI
    			}))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(155:16) {#if $ui.state.actionVis.nodes.symbols}",
    		ctx
    	});

    	return block;
    }

    // (107:4) {#each renderedNodes as node, i}
    function create_each_block$5(ctx) {
    	let g3;
    	let g2;
    	let g0;
    	let circle;
    	let circle_r_value;
    	let if_block1_anchor;
    	let if_block2_anchor;
    	let g1;
    	let text_1;
    	let raw_value = /*node*/ ctx[17].Name + "";
    	let g3_style_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$ui*/ ctx[3].state.actionVis.nodes.shadow && create_if_block_6$1(ctx);
    	let if_block1 = /*$ui*/ ctx[3].state.actionVis.nodes.arcs && create_if_block_5$1(ctx);
    	let if_block2 = /*$ui*/ ctx[3].state.actionVis.nodes.shapes && create_if_block_1$3(ctx);
    	let if_block3 = /*$ui*/ ctx[3].state.actionVis.nodes.symbols && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			g3 = svg_element("g");
    			g2 = svg_element("g");
    			g0 = svg_element("g");
    			if (if_block0) if_block0.c();
    			circle = svg_element("circle");
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$3();
    			if (if_block3) if_block3.c();
    			g1 = svg_element("g");
    			text_1 = svg_element("text");
    			attr_dev(circle, "class", "node-base svelte-ky4swr");
    			attr_dev(circle, "r", circle_r_value = /*dims*/ ctx[0].nodeRadius);
    			toggle_class(circle, "node-color", !/*$ui*/ ctx[3].state.actionVis.nodes.base);
    			add_location(circle, file$b, 121, 16, 4292);
    			attr_dev(g0, "class", "node-scale-wrapper");
    			set_style(g0, "transform", "scale(1)");
    			add_location(g0, file$b, 112, 12, 3744);
    			attr_dev(text_1, "class", "label-text svelte-ky4swr");
    			add_location(text_1, file$b, 169, 16, 6457);
    			attr_dev(g1, "class", "label svelte-ky4swr");
    			add_location(g1, file$b, 168, 12, 6421);
    			attr_dev(g2, "class", "node-wrapper svelte-ky4swr");
    			add_location(g2, file$b, 110, 8, 3704);
    			attr_dev(g3, "class", "node-group svelte-ky4swr");
    			attr_dev(g3, "index", /*i*/ ctx[19]);
    			attr_dev(g3, "style", g3_style_value = /*move*/ ctx[6](/*node*/ ctx[17].x, /*node*/ ctx[17].y));
    			add_location(g3, file$b, 107, 4, 3516);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g3, anchor);
    			append_dev(g3, g2);
    			append_dev(g2, g0);
    			if (if_block0) if_block0.m(g0, null);
    			append_dev(g0, circle);
    			if (if_block1) if_block1.m(g0, null);
    			append_dev(g0, if_block1_anchor);
    			if (if_block2) if_block2.m(g0, null);
    			append_dev(g0, if_block2_anchor);
    			if (if_block3) if_block3.m(g0, null);
    			append_dev(g2, g1);
    			append_dev(g1, text_1);
    			text_1.innerHTML = raw_value;

    			if (!mounted) {
    				dispose = [
    					listen_dev(g3, "mouseover", /*highlightNode*/ ctx[5], false, false, false),
    					listen_dev(g3, "focus", /*highlightNode*/ ctx[5], false, false, false),
    					listen_dev(g3, "mouseout", muteNode, false, false, false),
    					listen_dev(g3, "blur", muteNode, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ui*/ ctx[3].state.actionVis.nodes.shadow) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					if_block0.m(g0, circle);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*dims*/ 1 && circle_r_value !== (circle_r_value = /*dims*/ ctx[0].nodeRadius)) {
    				attr_dev(circle, "r", circle_r_value);
    			}

    			if (dirty & /*$ui*/ 8) {
    				toggle_class(circle, "node-color", !/*$ui*/ ctx[3].state.actionVis.nodes.base);
    			}

    			if (/*$ui*/ ctx[3].state.actionVis.nodes.arcs) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_5$1(ctx);
    					if_block1.c();
    					if_block1.m(g0, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*$ui*/ ctx[3].state.actionVis.nodes.shapes) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$3(ctx);
    					if_block2.c();
    					if_block2.m(g0, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*$ui*/ ctx[3].state.actionVis.nodes.symbols) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$4(ctx);
    					if_block3.c();
    					if_block3.m(g0, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty & /*renderedNodes*/ 2 && raw_value !== (raw_value = /*node*/ ctx[17].Name + "")) text_1.innerHTML = raw_value;
    			if (dirty & /*renderedNodes*/ 2 && g3_style_value !== (g3_style_value = /*move*/ ctx[6](/*node*/ ctx[17].x, /*node*/ ctx[17].y))) {
    				attr_dev(g3, "style", g3_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(107:4) {#each renderedNodes as node, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let g;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let stop2;
    	let stop3;
    	let stop4;
    	let stop5;
    	let g_transition;
    	let current;
    	let each_value = /*renderedNodes*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			stop2 = svg_element("stop");
    			stop3 = svg_element("stop");
    			stop4 = svg_element("stop");
    			stop5 = svg_element("stop");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(stop0, "offset", "0%");
    			set_style(stop0, "stop-color", "var(--heat)");
    			set_style(stop0, "stop-opacity", "1");
    			add_location(stop0, file$b, 97, 8, 2968);
    			attr_dev(stop1, "offset", "33%");
    			set_style(stop1, "stop-color", "var(--heat)");
    			set_style(stop1, "stop-opacity", "1");
    			add_location(stop1, file$b, 98, 8, 3043);
    			attr_dev(stop2, "offset", "33%");
    			set_style(stop2, "stop-color", "var(--flood)");
    			set_style(stop2, "stop-opacity", "1");
    			add_location(stop2, file$b, 99, 8, 3119);
    			attr_dev(stop3, "offset", "67%");
    			set_style(stop3, "stop-color", "var(--flood)");
    			set_style(stop3, "stop-opacity", "1");
    			add_location(stop3, file$b, 100, 8, 3196);
    			attr_dev(stop4, "offset", "67%");
    			set_style(stop4, "stop-color", "var(--drought)");
    			set_style(stop4, "stop-opacity", "1");
    			add_location(stop4, file$b, 101, 8, 3273);
    			attr_dev(stop5, "offset", "100%");
    			set_style(stop5, "stop-color", "var(--drought)");
    			set_style(stop5, "stop-opacity", "1");
    			add_location(stop5, file$b, 102, 8, 3352);
    			attr_dev(linearGradient, "id", "solids");
    			attr_dev(linearGradient, "x1", "0%");
    			attr_dev(linearGradient, "y1", "0%");
    			attr_dev(linearGradient, "x2", "100%");
    			attr_dev(linearGradient, "y2", "0%");
    			add_location(linearGradient, file$b, 96, 8, 2897);
    			add_location(defs, file$b, 95, 4, 2882);
    			attr_dev(g, "id", "force-vis-container");
    			add_location(g, file$b, 94, 0, 2832);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(linearGradient, stop2);
    			append_dev(linearGradient, stop3);
    			append_dev(linearGradient, stop4);
    			append_dev(linearGradient, stop5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*move, renderedNodes, highlightNode, muteNode, arc, dims, Math, $ui, triangle, slugify, hazardSchema, $data*/ 255) {
    				each_value = /*renderedNodes*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!g_transition) g_transition = create_bidirectional_transition(g, fade, {}, true);
    				g_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!g_transition) g_transition = create_bidirectional_transition(g, fade, {}, false);
    			g_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    			if (detaching && g_transition) g_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function muteNode() {
    	this.classList.remove('selected');
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let simulation$1;
    	let drag$1;
    	let $data;
    	let $ui;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(2, $data = $$value));
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(3, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Force', slots, []);
    	const hazardSchema = $data.schema.hazards.data;

    	// Node interaction
    	function highlightNode() {
    		select(this).raise();
    		this.classList.add('selected');
    	}

    	// Utility function for translating elements
    	const move = (x, y) => `transform: translate(${x}px, ${y}px`;

    	let { dims = {} } = $$props; // SVG dimensions
    	let { nodes = [] } = $$props; // an array of our particles
    	let { forces = [] } = $$props; // an array of [name, force] pairs
    	let appliedForceNames = [];
    	let renderedNodes = [];

    	// Simulation tick function
    	function tick() {
    		$$invalidate(1, renderedNodes = [...nodes]); // update the renderedDots reference to trigger an update
    	}

    	// Action node shape
    	const arc$1 = arc().cornerRadius(10);

    	const writable_props = ['dims', 'nodes', 'forces'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Force> was created with unknown prop '${key}'`);
    	});

    	const func = (node, d) => d.recordID === node.Scale[0];
    	const func_1 = (node, d) => d.recordID === node.Scale[0];
    	const func_2 = (hazard, d) => d.recordID === hazard;

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('nodes' in $$props) $$invalidate(8, nodes = $$props.nodes);
    		if ('forces' in $$props) $$invalidate(9, forces = $$props.forces);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		ui,
    		data,
    		slugify,
    		mapIcons,
    		triangle: triangle$1,
    		hazardSchema,
    		highlightNode,
    		muteNode,
    		move,
    		dims,
    		nodes,
    		forces,
    		appliedForceNames,
    		renderedNodes,
    		tick,
    		arc: arc$1,
    		drag: drag$1,
    		simulation: simulation$1,
    		$data,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('nodes' in $$props) $$invalidate(8, nodes = $$props.nodes);
    		if ('forces' in $$props) $$invalidate(9, forces = $$props.forces);
    		if ('appliedForceNames' in $$props) $$invalidate(10, appliedForceNames = $$props.appliedForceNames);
    		if ('renderedNodes' in $$props) $$invalidate(1, renderedNodes = $$props.renderedNodes);
    		if ('drag' in $$props) drag$1 = $$props.drag;
    		if ('simulation' in $$props) $$invalidate(11, simulation$1 = $$props.simulation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*nodes*/ 256) {
    			// Reactive variables for canvas dimensions and force simulation
    			$$invalidate(11, simulation$1 = simulation().nodes(nodes).velocityDecay(0.4).on("tick", tick));
    		}

    		if ($$self.$$.dirty & /*forces, simulation, appliedForceNames*/ 3584) {
    			{
    				// Re-initialize forces when they change
    				forces.forEach(([name, force]) => {
    					simulation$1.force(name, force);
    				});

    				// Remove old forces
    				const newForceNames = forces.map(([name]) => name);

    				const oldForceNames = appliedForceNames.filter(force => !newForceNames.includes(force));
    				oldForceNames.forEach(name => simulation$1.force(name, null));

    				// Update the applied forces
    				$$invalidate(10, appliedForceNames = newForceNames);

    				// Kick off simulation
    				simulation$1.alpha(1);

    				simulation$1.restart();
    			}
    		}
    	};

    	drag$1 = simulation => {
    		function dragstarted(event, d) {
    			if (!event.active) {
    				simulation.alphaTarget(0.3).restart();
    			}
    			event.subject.fx = event.subject.x;
    			event.subject.fy = event.subject.y;
    		}

    		function dragged(event, d) {
    			event.subject.fx = event.x;
    			event.subject.fy = event.y;
    		}

    		function dragended(event, d) {
    			if (!event.active) simulation.alphaTarget(0.01);
    			event.subject.fx = null;
    			event.subject.fy = null;
    		}

    		return drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    	};

    	return [
    		dims,
    		renderedNodes,
    		$data,
    		$ui,
    		hazardSchema,
    		highlightNode,
    		move,
    		arc$1,
    		nodes,
    		forces,
    		appliedForceNames,
    		simulation$1,
    		func,
    		func_1,
    		func_2
    	];
    }

    class Force extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, { dims: 0, nodes: 8, forces: 9 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Force",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get dims() {
    		throw new Error("<Force>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Force>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nodes() {
    		throw new Error("<Force>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nodes(value) {
    		throw new Error("<Force>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get forces() {
    		throw new Error("<Force>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set forces(value) {
    		throw new Error("<Force>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Intro.svelte generated by Svelte v3.48.0 */
    const file$a = "src/components/byPage/actions/vis/Intro.svelte";

    function create_fragment$a(ctx) {
    	let g1;
    	let g0;
    	let text0;
    	let raw_value = /*$data*/ ctx[2].stats.actions.total + "";
    	let text1;
    	let t0;
    	let text2;
    	let t1;
    	let g1_intro;

    	const block = {
    		c: function create() {
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			text0 = svg_element("text");
    			text1 = svg_element("text");
    			t0 = text$1("adaptation");
    			text2 = svg_element("text");
    			t1 = text$1("actions");
    			attr_dev(text0, "class", "number svelte-1txt3xe");
    			add_location(text0, file$a, 18, 8, 609);
    			attr_dev(text1, "y", "100");
    			attr_dev(text1, "class", "svelte-1txt3xe");
    			add_location(text1, file$a, 21, 8, 703);
    			attr_dev(text2, "y", "200");
    			attr_dev(text2, "class", "svelte-1txt3xe");
    			add_location(text2, file$a, 22, 8, 744);
    			attr_dev(g0, "class", "container svelte-1txt3xe");
    			set_style(g0, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.5 + "px)");
    			toggle_class(g0, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 0);
    			add_location(g0, file$a, 15, 4, 440);
    			attr_dev(g1, "id", "intro-vis-container");
    			add_location(g1, file$a, 14, 0, 398);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g1, anchor);
    			append_dev(g1, g0);
    			append_dev(g0, text0);
    			text0.innerHTML = raw_value;
    			append_dev(g0, text1);
    			append_dev(text1, t0);
    			append_dev(g0, text2);
    			append_dev(text2, t1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$data*/ 4 && raw_value !== (raw_value = /*$data*/ ctx[2].stats.actions.total + "")) text0.innerHTML = raw_value;
    			if (dirty & /*dims*/ 1) {
    				set_style(g0, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.5 + "px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g0, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 0);
    			}
    		},
    		i: function intro(local) {
    			if (!g1_intro) {
    				add_render_callback(() => {
    					g1_intro = create_in_transition(g1, fade, {});
    					g1_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(1, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(2, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Intro', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions
    	const writable_props = ['dims'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Intro> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		textWrap,
    		icons,
    		dims,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $ui, $data];
    }

    class Intro extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Intro",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get dims() {
    		throw new Error("<Intro>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Intro>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Hazard.svelte generated by Svelte v3.48.0 */
    const file$9 = "src/components/byPage/actions/vis/Hazard.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (26:12) {#each hazards as hazard, i }
    function create_each_block$4(ctx) {
    	let path0;
    	let path0_d_value;
    	let path1;
    	let path2;
    	let path2_d_value;
    	let text0;
    	let textPath0;
    	let raw0_value = /*hazard*/ ctx[6].Hazard + "";
    	let path3;
    	let path3_d_value;
    	let text1;
    	let textPath1;
    	let raw1_value = /*hazard*/ ctx[6]["Linked hazard events"].map(/*func*/ ctx[5]).join(" | ") + "";
    	let path4;
    	let path4_d_value;
    	let text2;
    	let textPath2;
    	let html_tag;
    	let raw2_value = /*hazard*/ ctx[6]["Linked adaptation actions"].length + "";
    	let t;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			text0 = svg_element("text");
    			textPath0 = svg_element("textPath");
    			path3 = svg_element("path");
    			text1 = svg_element("text");
    			textPath1 = svg_element("textPath");
    			path4 = svg_element("path");
    			text2 = svg_element("text");
    			textPath2 = svg_element("textPath");
    			html_tag = new HtmlTag(true);
    			t = text$1(" actions\n                    ");
    			attr_dev(path0, "class", "hazard-arc " + slugify(/*hazard*/ ctx[6].Hazard) + " svelte-19c4ts1");

    			attr_dev(path0, "d", path0_d_value = /*arc*/ ctx[4]({
    				innerRadius: /*dims*/ ctx[0].width * 0.3,
    				outerRadius: /*dims*/ ctx[0].width * 0.3 + arcWidth,
    				startAngle: /*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length),
    				endAngle: /*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) + 2 * Math.PI / /*hazards*/ ctx[3].length
    			}));

    			add_location(path0, file$9, 26, 16, 935);
    			attr_dev(path1, "class", "hazard-icon " + slugify(/*hazard*/ ctx[6].Hazard) + " svelte-19c4ts1");
    			attr_dev(path1, "d", icons[slugify(/*hazard*/ ctx[6].Hazard)]);
    			set_style(path1, "transform", "translate( " + (/*dims*/ ctx[0].width * 0.3 + 200) * Math.cos(/*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) - Math.PI / 4) + "px, " + (/*dims*/ ctx[0].width * 0.3 + 200) * Math.sin(/*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) - Math.PI / 4) + "px ) scale(2.5) rotate(" + (45 * /*i*/ ctx[8] * 2 + 45) + "deg)");
    			add_location(path1, file$9, 34, 16, 1337);
    			attr_dev(path2, "id", "" + (slugify(/*hazard*/ ctx[6].Hazard) + "-labelPath"));
    			attr_dev(path2, "class", "label-path svelte-19c4ts1");
    			attr_dev(path2, "d", path2_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 + 60));
    			set_style(path2, "transform", "rotate(" + (/*i*/ ctx[8] * 360 / /*hazards*/ ctx[3].length + 135) + "deg)");
    			add_location(path2, file$9, 41, 16, 1849);
    			attr_dev(textPath0, "class", "hazard-label " + slugify(/*hazard*/ ctx[6].Hazard) + " svelte-19c4ts1");
    			attr_dev(textPath0, "href", "#" + slugify(/*hazard*/ ctx[6].Hazard) + "-labelPath");
    			attr_dev(textPath0, "startOffset", "50%");
    			add_location(textPath0, file$9, 43, 20, 2081);
    			attr_dev(text0, "class", "svelte-19c4ts1");
    			add_location(text0, file$9, 42, 16, 2054);
    			attr_dev(path3, "id", "" + (slugify(/*hazard*/ ctx[6].Hazard) + "-event-labelPath"));
    			attr_dev(path3, "class", "label-path svelte-19c4ts1");
    			attr_dev(path3, "d", path3_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 - 27.5));
    			set_style(path3, "transform", "rotate(" + (/*i*/ ctx[8] * 360 / /*hazards*/ ctx[3].length + 135) + "deg)");
    			add_location(path3, file$9, 46, 16, 2312);
    			attr_dev(textPath1, "class", "event-label " + slugify(/*hazard*/ ctx[6].Hazard) + " svelte-19c4ts1");
    			attr_dev(textPath1, "href", "#" + slugify(/*hazard*/ ctx[6].Hazard) + "-event-labelPath");
    			attr_dev(textPath1, "startOffset", "50%");
    			add_location(textPath1, file$9, 48, 20, 2552);
    			attr_dev(text1, "class", "svelte-19c4ts1");
    			add_location(text1, file$9, 47, 16, 2525);
    			attr_dev(path4, "id", "" + (slugify(/*hazard*/ ctx[6].Hazard) + "-actionCount-labelPath"));
    			attr_dev(path4, "class", "label-path svelte-19c4ts1");
    			attr_dev(path4, "d", path4_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 + arcWidth * 0.5 - 10));
    			set_style(path4, "transform", "rotate(" + (/*i*/ ctx[8] * 360 / /*hazards*/ ctx[3].length + 135) + "deg)");
    			add_location(path4, file$9, 54, 16, 2962);
    			html_tag.a = t;
    			attr_dev(textPath2, "class", "actionCount-label svelte-19c4ts1");
    			attr_dev(textPath2, "href", "#" + slugify(/*hazard*/ ctx[6].Hazard) + "-actionCount-labelPath");
    			attr_dev(textPath2, "startOffset", "50%");
    			add_location(textPath2, file$9, 56, 20, 3272);
    			attr_dev(text2, "class", "svelte-19c4ts1");
    			toggle_class(text2, "hidden", /*$ui*/ ctx[2].state.actionVis.scene === 0);
    			add_location(text2, file$9, 55, 16, 3196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			insert_dev(target, path2, anchor);
    			insert_dev(target, text0, anchor);
    			append_dev(text0, textPath0);
    			textPath0.innerHTML = raw0_value;
    			insert_dev(target, path3, anchor);
    			insert_dev(target, text1, anchor);
    			append_dev(text1, textPath1);
    			textPath1.innerHTML = raw1_value;
    			insert_dev(target, path4, anchor);
    			insert_dev(target, text2, anchor);
    			append_dev(text2, textPath2);
    			html_tag.m(raw2_value, textPath2);
    			append_dev(textPath2, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dims*/ 1 && path0_d_value !== (path0_d_value = /*arc*/ ctx[4]({
    				innerRadius: /*dims*/ ctx[0].width * 0.3,
    				outerRadius: /*dims*/ ctx[0].width * 0.3 + arcWidth,
    				startAngle: /*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length),
    				endAngle: /*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) + 2 * Math.PI / /*hazards*/ ctx[3].length
    			}))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(path1, "transform", "translate( " + (/*dims*/ ctx[0].width * 0.3 + 200) * Math.cos(/*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) - Math.PI / 4) + "px, " + (/*dims*/ ctx[0].width * 0.3 + 200) * Math.sin(/*i*/ ctx[8] * (2 * Math.PI / /*hazards*/ ctx[3].length) - Math.PI / 4) + "px ) scale(2.5) rotate(" + (45 * /*i*/ ctx[8] * 2 + 45) + "deg)");
    			}

    			if (dirty & /*dims*/ 1 && path2_d_value !== (path2_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 + 60))) {
    				attr_dev(path2, "d", path2_d_value);
    			}

    			if (dirty & /*dims*/ 1 && path3_d_value !== (path3_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 - 27.5))) {
    				attr_dev(path3, "d", path3_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw1_value !== (raw1_value = /*hazard*/ ctx[6]["Linked hazard events"].map(/*func*/ ctx[5]).join(" | ") + "")) textPath1.innerHTML = raw1_value;
    			if (dirty & /*dims*/ 1 && path4_d_value !== (path4_d_value = circleClockwise({ x: 0, y: 0 }, /*dims*/ ctx[0].width * 0.3 + arcWidth * 0.5 - 10))) {
    				attr_dev(path4, "d", path4_d_value);
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(text2, "hidden", /*$ui*/ ctx[2].state.actionVis.scene === 0);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    			if (detaching) detach_dev(path2);
    			if (detaching) detach_dev(text0);
    			if (detaching) detach_dev(path3);
    			if (detaching) detach_dev(text1);
    			if (detaching) detach_dev(path4);
    			if (detaching) detach_dev(text2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(26:12) {#each hazards as hazard, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let g2;
    	let g1;
    	let g0;
    	let g2_intro;
    	let each_value = /*hazards*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g0, "class", "node-arcs-wrapper svelte-19c4ts1");
    			toggle_class(g0, "rotate", /*$ui*/ ctx[2].state.actionVis.scene > 1);
    			add_location(g0, file$9, 24, 8, 797);
    			attr_dev(g1, "class", "node-arcs svelte-19c4ts1");
    			set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.5 + "px)");
    			toggle_class(g1, "coloured", /*$ui*/ ctx[2].state.actionVis.scene > 1);
    			add_location(g1, file$9, 21, 4, 622);
    			attr_dev(g2, "id", "hazard-vis-container");
    			add_location(g2, file$9, 19, 0, 555);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g2, anchor);
    			append_dev(g2, g1);
    			append_dev(g1, g0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g0, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$ui, slugify, hazards, circleClockwise, dims, arcWidth, $data, icons, Math, arc*/ 31) {
    				each_value = /*hazards*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g0, "rotate", /*$ui*/ ctx[2].state.actionVis.scene > 1);
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.5 + "px)");
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g1, "coloured", /*$ui*/ ctx[2].state.actionVis.scene > 1);
    			}
    		},
    		i: function intro(local) {
    			if (!g2_intro) {
    				add_render_callback(() => {
    					g2_intro = create_in_transition(g2, fade, {});
    					g2_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const arcWidth = 50;

    function instance$9($$self, $$props, $$invalidate) {
    	let $data;
    	let $ui;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(2, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hazard', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions
    	const hazards = $data.schema.hazards.data;
    	const arc$1 = arc().cornerRadius(20);
    	const writable_props = ['dims'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hazard> was created with unknown prop '${key}'`);
    	});

    	const func = d => $data.schema.hazardEvents.data.filter(e => e.recordID === d)[0]["Hazard event"];

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		textWrap,
    		slugify,
    		icons,
    		circleClockwise,
    		dims,
    		hazards,
    		arcWidth,
    		arc: arc$1,
    		$data,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $data, $ui, hazards, arc$1, func];
    }

    class Hazard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hazard",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get dims() {
    		throw new Error("<Hazard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Hazard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Map shape objects for scale levels
    const mapShapes =  {
        "Local": {
            shape:  {"type":"FeatureCollection", "features": [
                        {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[144.37927806,-37.4387886],[144.34733483,-37.43215086],[144.34695232,-37.42859804],[144.34236997,-37.42806648],[144.34110807,-37.42603313],[144.34571666,-37.41792987],[144.34433148,-37.41594258],[144.33589169,-37.41083262],[144.33429063,-37.40874962],[144.3273705,-37.41002534],[144.32557054,-37.40598258],[144.32114795,-37.40610924],[144.31909929,-37.40290648],[144.31592555,-37.40545516],[144.31549715,-37.40858802],[144.31178741,-37.415608],[144.30717602,-37.42031798],[144.30047077,-37.42519557],[144.29993093,-37.42804914],[144.2951021,-37.42898368],[144.29779251,-37.43594515],[144.29125375,-37.43695079],[144.28688554,-37.43462846],[144.27303368,-37.43017858],[144.26869859,-37.42759117],[144.26335328,-37.42708106],[144.25075275,-37.42869759],[144.24316752,-37.42293333],[144.23709706,-37.4171678],[144.22702897,-37.41611349],[144.22561407,-37.42346759],[144.19810426,-37.42012938],[144.1995671,-37.41277254],[144.19444186,-37.41023562],[144.18150349,-37.41558131],[144.17265359,-37.41796],[144.17020188,-37.41992526],[144.1613128,-37.41831744],[144.15662297,-37.42123309],[144.14863575,-37.42079239],[144.14506481,-37.42268712],[144.14197817,-37.42217233],[144.13863536,-37.42715413],[144.13435444,-37.42823715],[144.1328413,-37.43017505],[144.12585735,-37.4308908],[144.10735313,-37.42877314],[144.11148799,-37.43395515],[144.10663974,-37.43736459],[144.10720517,-37.43972641],[144.1028435,-37.44188805],[144.10036613,-37.44597494],[144.09154107,-37.44467356],[144.08743559,-37.44641946],[144.08673615,-37.45135166],[144.08358256,-37.45236745],[144.08197889,-37.45792225],[144.07855953,-37.46269467],[144.07193216,-37.46352099],[144.07058546,-37.46540572],[144.06361496,-37.46864396],[144.05908272,-37.4659993],[144.05524252,-37.47009015],[144.04240224,-37.46383458],[144.03856466,-37.48613449],[144.02138495,-37.48645741],[144.02357013,-37.48388036],[144.0065071,-37.48196728],[144.0018699,-37.48073938],[143.99003762,-37.47942023],[143.98669959,-37.47975545],[143.93797024,-37.47421298],[143.93775092,-37.47543651],[143.92391413,-37.47370667],[143.92212407,-37.47439202],[143.85679548,-37.46847295],[143.84961558,-37.46687233],[143.85285378,-37.46275483],[143.85201947,-37.46101553],[143.85771096,-37.43297345],[143.84322645,-37.43112051],[143.84919085,-37.40078326],[143.85879867,-37.40203356],[143.86291113,-37.38008739],[143.86444522,-37.37355658],[143.8685737,-37.34835914],[143.84162198,-37.3452764],[143.84088138,-37.34264592],[143.82688255,-37.3408978],[143.82702548,-37.34018373],[143.79324803,-37.34371695],[143.79400703,-37.33920381],[143.78825043,-37.33942384],[143.73892224,-37.33308299],[143.7388635,-37.33337902],[143.64805686,-37.32169533],[143.66254726,-37.24868724],[143.66512868,-37.23665574],[143.67044298,-37.23493885],[143.67180671,-37.23324172],[143.67658865,-37.23428266],[143.67914049,-37.23259562],[143.68340054,-37.23305765],[143.68508735,-37.23030558],[143.68837409,-37.22893059],[143.69192525,-37.23229154],[143.69671302,-37.23049849],[143.70776685,-37.22937397],[143.70952336,-37.23092171],[143.7143374,-37.22995225],[143.71623945,-37.22509744],[143.72032922,-37.22154746],[143.7244075,-37.22094631],[143.72271114,-37.21752171],[143.72525555,-37.21427837],[143.72892683,-37.21599113],[143.73265332,-37.21445471],[143.7344885,-37.21604234],[143.74506192,-37.22150321],[143.75330457,-37.23095066],[143.75963311,-37.23197679],[143.76628409,-37.22823395],[143.82019115,-37.2352203],[143.82206151,-37.22594539],[143.8350632,-37.22727985],[143.83701424,-37.23288963],[143.85843597,-37.23537389],[143.86028596,-37.23435324],[143.86733257,-37.19509897],[143.87529175,-37.1863452],[143.90602351,-37.18996545],[143.90614138,-37.1892951],[143.93596015,-37.19285659],[143.93937132,-37.1976597],[143.94151972,-37.19450151],[143.94906313,-37.19784176],[143.94884018,-37.20010587],[143.95204524,-37.20347194],[143.95173518,-37.20550457],[143.95628775,-37.21373679],[143.95573129,-37.21594943],[143.95856719,-37.22025247],[143.96364478,-37.22230147],[143.97072672,-37.2281696],[143.97426476,-37.22769225],[143.97688261,-37.22993209],[143.98105659,-37.22905299],[143.98411961,-37.23340741],[143.98669588,-37.23190033],[143.99208308,-37.23328232],[143.9938651,-37.23678746],[144.00033961,-37.23999434],[143.99817748,-37.24402518],[143.99505281,-37.24375216],[144.00141845,-37.25228736],[144.00005197,-37.25532461],[144.00731828,-37.25911875],[144.00983061,-37.25831324],[144.01376474,-37.26186741],[144.01889812,-37.26326933],[144.02743079,-37.26194415],[144.03801695,-37.26420116],[144.04166834,-37.2564734],[144.04832718,-37.25207446],[144.0528238,-37.25012911],[144.06244708,-37.25207203],[144.06430587,-37.24457936],[144.06037391,-37.23821472],[144.06202949,-37.23265909],[144.0659366,-37.22499044],[144.06487731,-37.21718811],[144.06740744,-37.21051446],[144.06005484,-37.20787541],[144.06119567,-37.20198332],[144.06412122,-37.20236357],[144.06600836,-37.19287505],[144.06604142,-37.18876619],[144.06769858,-37.17520511],[144.06998857,-37.16299392],[144.07179509,-37.1600727],[144.07427334,-37.14759587],[144.1021022,-37.15105356],[144.12249041,-37.15322303],[144.12155626,-37.15875512],[144.14623158,-37.16156755],[144.15618078,-37.16130975],[144.15663764,-37.16286037],[144.16425946,-37.1630129],[144.17330989,-37.16406681],[144.18048454,-37.16654296],[144.18517759,-37.16724066],[144.19041416,-37.16627639],[144.18514812,-37.19535732],[144.27549825,-37.20556706],[144.27609056,-37.20834787],[144.28426566,-37.20793431],[144.29217584,-37.16343695],[144.32764352,-37.16708193],[144.33115477,-37.16913847],[144.337996,-37.16541868],[144.34615389,-37.16984069],[144.37441282,-37.17307285],[144.37837263,-37.17767109],[144.37553744,-37.18088281],[144.36311641,-37.17961961],[144.36033249,-37.19404757],[144.37534977,-37.19581865],[144.37458496,-37.19769214],[144.37612248,-37.20224161],[144.36836046,-37.20673917],[144.36137255,-37.20814051],[144.35742799,-37.21129582],[144.35675921,-37.21464462],[144.34787719,-37.22373776],[144.34398635,-37.22622579],[144.34117004,-37.23640756],[144.33774111,-37.24251405],[144.33790435,-37.24546669],[144.33297388,-37.25377398],[144.33347523,-37.25686164],[144.32796745,-37.25537699],[144.32379497,-37.25995003],[144.32306553,-37.26515046],[144.32080681,-37.26782215],[144.31968378,-37.2731587],[144.32139893,-37.27718434],[144.31779331,-37.28239984],[144.3153126,-37.28256479],[144.31421572,-37.28723214],[144.31221819,-37.2883584],[144.31039968,-37.29278591],[144.31613118,-37.29820494],[144.3302447,-37.30226077],[144.34033538,-37.30966755],[144.36040879,-37.31838322],[144.36909236,-37.32009045],[144.3736064,-37.32606916],[144.38025959,-37.32975086],[144.3949572,-37.33210516],[144.39162346,-37.35029945],[144.39276451,-37.35814901],[144.40360372,-37.35937549],[144.40575158,-37.35897247],[144.41903119,-37.36050752],[144.41510473,-37.38234813],[144.41742858,-37.38994629],[144.41644193,-37.39546446],[144.41381555,-37.39708922],[144.38196684,-37.39332726],[144.37780121,-37.41591736],[144.38258648,-37.4237246],[144.37927806,-37.4387886]]]},"properties":{"lg_ply_pid":"643","dt_create":"2018-09-25Z","dt_retire":null,"lga_pid":"VIC94","vic_lga_sh":"2018-09-25Z","vic_lga__1":null,"vic_lga__2":"HEPBURN SHIRE","vic_lga__3":"HEPBURN","vic_lga__4":null,"vic_lga__5":"2"},"id":"ckan_bdf92691_c6fe_42b9_a0e2_a4cd716fa811.30"}
                    ]},
            path:   index$2().projection(
                        mercator()
                        .scale(25000)
                        .center([145.1, -37.8])
                    )
        },
        "Regional": {
            shape:  {"type":"GeometryCollection", "geometries": [
            {"type":"MultiPolygon","coordinates":[[[[141.77616611,-37.17697408],[141.7809526,-37.17421602],[141.77916239,-37.17133284],[141.78646365,-37.16878966],[141.7863056,-37.17419969],[141.79204912,-37.17267559],[141.79652778,-37.17323602],[141.80505206,-37.16938847],[141.80595843,-37.17408662],[141.80951339,-37.1772431],[141.81454806,-37.1746882],[141.81583079,-37.17000583],[141.82200425,-37.17389003],[141.825181,-37.16936525],[141.83275457,-37.17204404],[141.83644523,-37.17069493],[141.84229174,-37.16633492],[141.83987113,-37.16438879],[141.83878942,-37.1605765],[141.83540038,-37.16021633],[141.83467668,-37.15742582],[141.84053797,-37.15251129],[141.84429286,-37.15224982],[141.85320344,-37.14773577],[141.85718366,-37.14914817],[141.8604771,-37.1458165],[141.86288343,-37.14874982],[141.87421122,-37.14653268],[141.87600343,-37.14711698],[141.88492686,-37.14448978],[141.88685424,-37.14067674],[141.89323741,-37.13735714],[141.89877713,-37.13644758],[141.90093003,-37.13443924],[141.90441128,-37.13590655],[141.90887499,-37.13484804],[141.90975835,-37.13296329],[141.90629634,-37.12863633],[141.90786978,-37.12653291],[141.9035248,-37.12409061],[141.90498307,-37.11903524],[141.90815949,-37.11711645],[141.90940778,-37.1136786],[141.91587173,-37.11520916],[141.92009652,-37.12008016],[141.92335214,-37.12125119],[141.92547439,-37.12514552],[141.92603562,-37.12966535],[141.92400483,-37.13626],[141.92527195,-37.14198712],[141.92832381,-37.1453137],[141.92482966,-37.14981179],[141.92841333,-37.16190985],[141.93329781,-37.16500529],[141.92982589,-37.16675118],[141.92819616,-37.16968583],[141.93443383,-37.16996881],[141.92984527,-37.17648079],[141.93004313,-37.1795736],[141.92062223,-37.18208725],[141.91989594,-37.18595553],[141.9117038,-37.18983884],[141.91043476,-37.19296432],[141.91050232,-37.19849139],[141.91345173,-37.20243504],[141.92055527,-37.20321022],[141.92127671,-37.19830203],[141.93826731,-37.20007983],[141.93722115,-37.2066838],[141.94248365,-37.20763771],[141.94470529,-37.2105626],[141.9534518,-37.20874529],[141.9611378,-37.21020253],[141.96584799,-37.21013888],[141.98924555,-37.21241946],[141.9911303,-37.21323323],[141.99577382,-37.22262051],[141.99803407,-37.2240217],[142.00339335,-37.22445516],[142.01827347,-37.22323087],[142.02555963,-37.22400042],[142.03312052,-37.22296178],[142.038164,-37.22398577],[142.04891257,-37.22194073],[142.05250065,-37.22282653],[142.05694611,-37.22056277],[142.06542001,-37.2186405],[142.07937839,-37.22364657],[142.08392513,-37.21959894],[142.08556221,-37.2149905],[142.08858221,-37.21309215],[142.08834455,-37.20964061],[142.08463225,-37.20485043],[142.08756711,-37.19852485],[142.0867445,-37.19103017],[142.08981592,-37.18439926],[142.09239299,-37.1706477],[142.09810466,-37.16675148],[142.1053003,-37.16529449],[142.1088553,-37.16348078],[142.10957303,-37.15843642],[142.1079806,-37.15411355],[142.10730745,-37.14554585],[142.11016187,-37.14118562],[142.10822877,-37.1358644],[142.10808371,-37.12946142],[142.11129195,-37.11913831],[142.11394746,-37.11609843],[142.11448771,-37.1120541],[142.11777179,-37.11187594],[142.12181152,-37.10977532],[142.13337224,-37.10945381],[142.1417624,-37.11173005],[142.15266957,-37.10723797],[142.164157,-37.1058923],[142.17194295,-37.10859928],[142.17788002,-37.10778813],[142.1813471,-37.11077152],[142.19141573,-37.10855324],[142.19342324,-37.10362371],[142.19891623,-37.09915764],[142.20196177,-37.09502703],[142.20189708,-37.08888776],[142.20625465,-37.08729557],[142.21189331,-37.09082616],[142.21611528,-37.10071818],[142.21663692,-37.10705998],[142.21570431,-37.11140244],[142.22177898,-37.11577648],[142.22247436,-37.12057498],[142.22749605,-37.1212355],[142.23284117,-37.12339503],[142.23504674,-37.12794385],[142.23599858,-37.13252915],[142.23525469,-37.13925618],[142.24068349,-37.14250188],[142.23974224,-37.14767414],[142.24782397,-37.15199589],[142.25501138,-37.15673141],[142.2591511,-37.15721939],[142.2652514,-37.16270575],[142.27530932,-37.16981462],[142.30192508,-37.18525378],[142.30938583,-37.1888724],[142.31665467,-37.19471324],[142.32875702,-37.19920425],[142.3344164,-37.20543214],[142.34238244,-37.21126355],[142.35031004,-37.21487422],[142.3557079,-37.21925355],[142.35882701,-37.22550921],[142.3690662,-37.22890697],[142.37927272,-37.23045388],[142.3920204,-37.23178507],[142.40345972,-37.23738631],[142.41669317,-37.25221696],[142.42308916,-37.26009695],[142.45512806,-37.26544368],[142.46343401,-37.27607353],[142.46562427,-37.28159756],[142.49031986,-37.28754416],[142.5014023,-37.29256078],[142.50398421,-37.29160701],[142.51250892,-37.29386578],[142.51635098,-37.29322678],[142.51391227,-37.29860593],[142.51400166,-37.30602413],[142.51105295,-37.30857308],[142.50851576,-37.31435506],[142.5051481,-37.31629004],[142.50504967,-37.31844674],[142.50048257,-37.3200005],[142.49985268,-37.33120311],[142.49709909,-37.33792666],[142.49727409,-37.34381809],[142.49569047,-37.34748552],[142.4961661,-37.35486322],[142.49351385,-37.36087187],[142.49502639,-37.36498366],[142.49199575,-37.37477897],[142.48719651,-37.37881947],[142.48676453,-37.38136971],[142.48386236,-37.38369902],[142.48166112,-37.39084385],[142.48199334,-37.3928122],[142.47506317,-37.4055441],[142.46728637,-37.41224862],[142.46585067,-37.416301],[142.45929267,-37.42087127],[142.45709975,-37.42701222],[142.45230443,-37.43340119],[142.44693982,-37.43371217],[142.43787708,-37.44045593],[142.43390045,-37.44518053],[142.43612971,-37.44882403],[142.42915296,-37.45379399],[142.42589066,-37.46230777],[142.42746652,-37.46458412],[142.42654184,-37.46810477],[142.41930955,-37.4703943],[142.41902957,-37.47498461],[142.41119462,-37.48271707],[142.40719352,-37.48897575],[142.40291318,-37.49099734],[142.39415505,-37.49270727],[142.39212556,-37.49544519],[142.38742435,-37.498455],[142.37689216,-37.51518323],[142.37531199,-37.52363888],[142.37240219,-37.52512993],[142.37098894,-37.53233743],[142.36567727,-37.54289911],[142.36432633,-37.54432637],[142.36693201,-37.55683478],[142.36614337,-37.5599975],[142.36908961,-37.56380265],[142.36749787,-37.5651851],[142.36718772,-37.56999041],[142.36286012,-37.57535834],[142.35878886,-37.58200807],[142.35768865,-37.5854226],[142.35493659,-37.58813419],[142.35607507,-37.59416153],[142.35348009,-37.59798406],[142.36448394,-37.59888123],[142.39595121,-37.60299292],[142.47740606,-37.61326863],[142.48350454,-37.61262876],[142.48493851,-37.61422006],[142.49992084,-37.61600295],[142.58711436,-37.62697331],[142.58723782,-37.63580313],[142.61482332,-37.64448667],[142.61877029,-37.64684823],[142.61906563,-37.674049],[142.61565931,-37.68937191],[142.60175913,-37.69957337],[142.59886771,-37.71329669],[142.59477124,-37.71879721],[142.59400296,-37.72772183],[142.59650728,-37.73358365],[142.59615334,-37.74077207],[142.5942989,-37.74820206],[142.5939547,-37.75406017],[142.59016076,-37.76511754],[142.59211871,-37.76923536],[142.59329424,-37.77588477],[142.59745835,-37.78069639],[142.60829846,-37.78531037],[142.61261295,-37.79164654],[142.6142537,-37.80004037],[142.61471384,-37.81031767],[142.61649006,-37.80931435],[142.63576428,-37.81167501],[142.64302808,-37.8133314],[142.65222815,-37.81331372],[142.65732058,-37.81455355],[142.66106378,-37.81730035],[142.66268833,-37.81524744],[142.67323948,-37.81656067],[142.66478018,-37.83000074],[142.70140116,-37.83477574],[142.75025029,-37.81918255],[142.75761072,-37.81276252],[142.83968579,-37.82213888],[142.84222316,-37.80786463],[142.86079241,-37.80993264],[142.86140523,-37.80645215],[142.87946648,-37.80844486],[142.87527244,-37.83193096],[142.87921243,-37.83646821],[142.90211701,-37.81671378],[142.91635097,-37.81088125],[142.92336896,-37.80717236],[142.92684043,-37.80129332],[142.92974643,-37.80071454],[142.93457591,-37.80285258],[142.93843224,-37.80162092],[142.94373821,-37.79766746],[142.94592093,-37.79365054],[142.95130761,-37.78953078],[142.95578832,-37.7893235],[142.96239526,-37.78718705],[142.96683366,-37.78377259],[142.97800458,-37.77790819],[142.97998742,-37.77541367],[142.98482598,-37.77284721],[142.98760729,-37.77282844],[143.00347225,-37.76736851],[143.0072402,-37.76555194],[143.01665291,-37.76670015],[143.01306451,-37.78690918],[143.02511587,-37.78890422],[143.03525849,-37.79277531],[143.03137707,-37.81452562],[143.04494071,-37.81609986],[143.04760391,-37.81990617],[143.04705929,-37.82321799],[143.06207616,-37.82491363],[143.06398833,-37.81424698],[143.07622524,-37.8156589],[143.09257282,-37.82842042],[143.10582279,-37.83349989],[143.09957873,-37.82247156],[143.09597209,-37.82162324],[143.09546157,-37.81820384],[143.09706862,-37.81523239],[143.10072002,-37.81499287],[143.09926438,-37.80896186],[143.10422766,-37.80291163],[143.10822124,-37.80109312],[143.10849945,-37.7946176],[143.10603378,-37.79175499],[143.10757986,-37.78551155],[143.10673387,-37.78194864],[143.10835052,-37.77854203],[143.11625641,-37.77408199],[143.11968506,-37.77481807],[143.12066617,-37.77713717],[143.12602276,-37.77969672],[143.13163177,-37.77910515],[143.13628522,-37.77551879],[143.13423657,-37.77405199],[143.13704489,-37.77078646],[143.13980357,-37.77097179],[143.14506277,-37.76884599],[143.14602055,-37.76512319],[143.14901436,-37.76181438],[143.15712324,-37.76150803],[143.16557172,-37.76319828],[143.16434509,-37.75866349],[143.16552804,-37.75398541],[143.17046726,-37.75026448],[143.16942357,-37.74614548],[143.17434137,-37.74303106],[143.17887731,-37.73553331],[143.18022344,-37.73147066],[143.18550652,-37.73091083],[143.18752883,-37.7338092],[143.19579948,-37.73382808],[143.19670458,-37.73539713],[143.20625818,-37.73465452],[143.21329917,-37.73511735],[143.21625005,-37.73693769],[143.22455796,-37.73666507],[143.22527527,-37.74181991],[143.22935519,-37.7455549],[143.23423781,-37.74398325],[143.2370574,-37.74165433],[143.24401233,-37.74495392],[143.24575032,-37.74248392],[143.2496923,-37.74250445],[143.25262266,-37.73575134],[143.25545769,-37.73551753],[143.25639695,-37.73234985],[143.2656938,-37.73570612],[143.26378626,-37.73913816],[143.26664991,-37.74018482],[143.26708338,-37.74323403],[143.27094804,-37.74593388],[143.26939262,-37.74930753],[143.27263603,-37.7498633],[143.27712543,-37.75610618],[143.28156115,-37.75502849],[143.28462961,-37.75748443],[143.29051731,-37.75509896],[143.29699848,-37.75648967],[143.29870118,-37.75468366],[143.3032817,-37.75658114],[143.30530136,-37.75481453],[143.30510417,-37.75131784],[143.30819772,-37.74975522],[143.31505211,-37.74828823],[143.31552534,-37.74508787],[143.322408,-37.74363186],[143.32237824,-37.74095906],[143.31737127,-37.73839921],[143.32115342,-37.73613663],[143.32012692,-37.73014617],[143.3228731,-37.72842934],[143.32684635,-37.72297249],[143.32721592,-37.71905686],[143.32549295,-37.7137833],[143.32617385,-37.71040505],[143.33004745,-37.71258347],[143.33273601,-37.70886332],[143.33672325,-37.71052616],[143.34191162,-37.70732704],[143.34190006,-37.7038014],[143.33931381,-37.70335483],[143.34164653,-37.698937],[143.34046849,-37.69493663],[143.34906551,-37.6920678],[143.35016338,-37.6933971],[143.35478358,-37.67027824],[143.37120448,-37.67228466],[143.37956601,-37.66820691],[143.38503658,-37.67002076],[143.38899326,-37.668593],[143.39535528,-37.66957958],[143.39878015,-37.66790726],[143.41324372,-37.67274246],[143.41417284,-37.67071444],[143.41876226,-37.66964604],[143.42357131,-37.67016539],[143.42586578,-37.66795023],[143.42862761,-37.66972984],[143.43430843,-37.67044426],[143.44120082,-37.67004793],[143.44906513,-37.6655654],[143.45056805,-37.66250548],[143.45629289,-37.6598872],[143.46194356,-37.66088188],[143.46474384,-37.65892913],[143.46514777,-37.65499716],[143.46717608,-37.65373714],[143.47322142,-37.65361417],[143.47744804,-37.65173275],[143.47688117,-37.64878076],[143.48293366,-37.64597617],[143.48972118,-37.64681084],[143.48790698,-37.65512891],[143.49986922,-37.65679639],[143.49482632,-37.66087853],[143.52961097,-37.66566956],[143.53338641,-37.66408286],[143.53653799,-37.64831163],[143.58663647,-37.65372446],[143.58734879,-37.65008293],[143.59604487,-37.64633913],[143.595303,-37.64430821],[143.64196455,-37.65030343],[143.64221239,-37.64622875],[143.6516425,-37.64703241],[143.65272588,-37.6306379],[143.6526295,-37.62418816],[143.66218827,-37.57240737],[143.67153892,-37.56842114],[143.67998935,-37.56239349],[143.6859293,-37.56013038],[143.69367412,-37.5582221],[143.70723841,-37.55787812],[143.70984815,-37.56197483],[143.71000484,-37.56693799],[143.72113466,-37.57298626],[143.72837588,-37.57953006],[143.74526294,-37.58720113],[143.75043699,-37.59117521],[143.75695594,-37.59446873],[143.7762245,-37.59849221],[143.79591203,-37.60507121],[143.80305369,-37.60945334],[143.8095203,-37.61253462],[143.81231102,-37.61186961],[143.83196034,-37.61873034],[143.83454192,-37.6221985],[143.83010375,-37.6298806],[143.8316472,-37.63149383],[143.8303106,-37.63653432],[143.83407715,-37.64064876],[143.83237345,-37.64403534],[143.83796205,-37.65172204],[143.83467244,-37.65258473],[143.83335374,-37.65538631],[143.83578843,-37.65971467],[143.83462798,-37.66521649],[143.84071262,-37.67214724],[143.84362007,-37.66994162],[143.84887467,-37.67208052],[143.8488943,-37.67491586],[143.85553321,-37.68536481],[143.85744415,-37.68662959],[143.85430055,-37.69146233],[143.86410755,-37.68973171],[143.86650441,-37.69247629],[143.87084367,-37.69320969],[143.87032915,-37.69753715],[143.87100473,-37.70382454],[143.8798873,-37.70861281],[143.87979583,-37.71253551],[143.88267439,-37.71421897],[143.8892064,-37.7148753],[143.8900566,-37.71746185],[143.89804124,-37.72478496],[143.89246846,-37.72507521],[143.8921649,-37.73298127],[143.89545152,-37.73300704],[143.89443479,-37.7372775],[143.89538304,-37.74418718],[143.90261009,-37.74922864],[143.90177326,-37.7531503],[143.89693509,-37.75151587],[143.8979546,-37.75718318],[143.89736099,-37.77023567],[143.89354163,-37.77484238],[143.8877967,-37.77307978],[143.88303684,-37.77441852],[143.88374419,-37.77845341],[143.89026901,-37.78147164],[143.89257285,-37.78729491],[143.89540877,-37.7885747],[143.89859448,-37.7858511],[143.90674531,-37.78761504],[143.91636409,-37.79694867],[143.91367938,-37.79995792],[143.91945633,-37.80354445],[143.92068633,-37.80679679],[143.92019226,-37.81210633],[143.92554179,-37.81297564],[143.92974273,-37.81534249],[143.939207,-37.81538572],[143.9391747,-37.82366767],[143.95785804,-37.82382611],[143.95806154,-37.82745129],[143.97929399,-37.82762645],[143.98932887,-37.82273979],[144.01761371,-37.82267802],[144.04905327,-37.82633582],[144.0545905,-37.83229542],[144.06021412,-37.79577509],[144.12232506,-37.80300568],[144.12269423,-37.79881503],[144.12938814,-37.79753515],[144.17638981,-37.8028795],[144.21827285,-37.80700532],[144.21690307,-37.80958109],[144.22236747,-37.81018888],[144.23265961,-37.81125808],[144.23343959,-37.80853769],[144.23857104,-37.80915665],[144.23817378,-37.8113739],[144.24706888,-37.81250738],[144.24810333,-37.80966352],[144.26361043,-37.81165881],[144.265157,-37.815967],[144.274473,-37.817521],[144.29101914,-37.81939961],[144.29601586,-37.81956474],[144.29424867,-37.82892806],[144.29984307,-37.8309815],[144.30521035,-37.83657051],[144.31484301,-37.8370558],[144.31739422,-37.8404916],[144.32138857,-37.84176028],[144.32211953,-37.84411427],[144.32682016,-37.84382052],[144.332293,-37.845918],[144.337487,-37.843278],[144.345422,-37.844882],[144.347398,-37.842083],[144.354999,-37.843017],[144.357736,-37.828139],[144.35866,-37.826352],[144.361678,-37.8108],[144.39912,-37.815232],[144.403365,-37.804891],[144.40783377,-37.80919079],[144.41601244,-37.80961719],[144.41682566,-37.81475388],[144.41479649,-37.81642471],[144.4169468,-37.81922377],[144.42053224,-37.81980413],[144.41988577,-37.83213367],[144.42300035,-37.83390395],[144.42188631,-37.83689602],[144.42164576,-37.84621774],[144.428014,-37.851949],[144.428913,-37.856092],[144.431382,-37.857529],[144.43477277,-37.85522756],[144.441879,-37.860515],[144.44417684,-37.86401471],[144.44897021,-37.83714155],[144.46696278,-37.83919986],[144.47774273,-37.78137311],[144.47767801,-37.78101273],[144.49058277,-37.705698],[144.49422196,-37.70428309],[144.49893796,-37.70793263],[144.50206563,-37.70852118],[144.51514093,-37.70787765],[144.51905482,-37.70673372],[144.51928553,-37.70407133],[144.51729782,-37.69943631],[144.51478057,-37.69824094],[144.51789829,-37.69224659],[144.516021,-37.68732091],[144.51436821,-37.68653797],[144.51352751,-37.67944741],[144.51207516,-37.67571611],[144.51860544,-37.67028907],[144.51528125,-37.66826881],[144.51917993,-37.66622182],[144.51874097,-37.66259451],[144.51887291,-37.64764608],[144.51637918,-37.64584407],[144.51950904,-37.64019897],[144.51909782,-37.63558499],[144.52020367,-37.63324484],[144.51929772,-37.62791859],[144.52728823,-37.61833074],[144.52754088,-37.61606767],[144.52398729,-37.60962295],[144.52323319,-37.60306855],[144.52688646,-37.60185944],[144.52756232,-37.59844933],[144.53174252,-37.59506309],[144.53522621,-37.59035915],[144.53665789,-37.58554972],[144.53862018,-37.58359972],[144.53817263,-37.57573065],[144.54227961,-37.57392175],[144.54766813,-37.56715146],[144.55087711,-37.56177417],[144.55622531,-37.55890031],[144.48390824,-37.55084647],[144.48420926,-37.54930096],[144.45928337,-37.54639696],[144.45794699,-37.54254438],[144.46210042,-37.53854493],[144.46558704,-37.53699822],[144.46302621,-37.53320015],[144.4645124,-37.52854344],[144.46842151,-37.52404181],[144.46822691,-37.5167534],[144.46950872,-37.51438016],[144.46978117,-37.50746269],[144.45931484,-37.49710101],[144.46966685,-37.43911998],[144.47155268,-37.43110877],[144.47046761,-37.42879574],[144.46522455,-37.42906821],[144.46437201,-37.43638882],[144.46174339,-37.43606936],[144.45742031,-37.43906262],[144.45125371,-37.4481913],[144.44500622,-37.44791727],[144.43971198,-37.44997707],[144.43321696,-37.45017713],[144.42870572,-37.45812534],[144.4267718,-37.45973836],[144.42247601,-37.45527938],[144.4171291,-37.45529417],[144.41846793,-37.44872431],[144.41749484,-37.44675011],[144.37927806,-37.4387886],[144.38258648,-37.4237246],[144.37780121,-37.41591736],[144.38196684,-37.39332726],[144.41381555,-37.39708922],[144.41644193,-37.39546446],[144.41742858,-37.38994629],[144.41510473,-37.38234813],[144.41903119,-37.36050752],[144.40575158,-37.35897247],[144.40360372,-37.35937549],[144.39276451,-37.35814901],[144.39162346,-37.35029945],[144.3949572,-37.33210516],[144.38025959,-37.32975086],[144.3736064,-37.32606916],[144.36909236,-37.32009045],[144.36040879,-37.31838322],[144.34033538,-37.30966755],[144.3302447,-37.30226077],[144.31613118,-37.29820494],[144.31039968,-37.29278591],[144.31221819,-37.2883584],[144.31421572,-37.28723214],[144.3153126,-37.28256479],[144.31779331,-37.28239984],[144.32139893,-37.27718434],[144.31968378,-37.2731587],[144.32080681,-37.26782215],[144.32306553,-37.26515046],[144.32379497,-37.25995003],[144.32796745,-37.25537699],[144.33347523,-37.25686164],[144.33297388,-37.25377398],[144.33790435,-37.24546669],[144.33774111,-37.24251405],[144.34117004,-37.23640756],[144.34398635,-37.22622579],[144.34787719,-37.22373776],[144.35675921,-37.21464462],[144.35742799,-37.21129582],[144.36137255,-37.20814051],[144.36836046,-37.20673917],[144.37612248,-37.20224161],[144.37458496,-37.19769214],[144.37534977,-37.19581865],[144.36033249,-37.19404757],[144.36311641,-37.17961961],[144.37553744,-37.18088281],[144.37837263,-37.17767109],[144.37441282,-37.17307285],[144.34615389,-37.16984069],[144.337996,-37.16541868],[144.33115477,-37.16913847],[144.32764352,-37.16708193],[144.29217584,-37.16343695],[144.28426566,-37.20793431],[144.27609056,-37.20834787],[144.27549825,-37.20556706],[144.18514812,-37.19535732],[144.19041416,-37.16627639],[144.18517759,-37.16724066],[144.18048454,-37.16654296],[144.17330989,-37.16406681],[144.16425946,-37.1630129],[144.15663764,-37.16286037],[144.15618078,-37.16130975],[144.14623158,-37.16156755],[144.12155626,-37.15875512],[144.12249041,-37.15322303],[144.1021022,-37.15105356],[144.07427334,-37.14759587],[144.07179509,-37.1600727],[144.06998857,-37.16299392],[144.06769858,-37.17520511],[144.06604142,-37.18876619],[144.06600836,-37.19287505],[144.06412122,-37.20236357],[144.06119567,-37.20198332],[144.06005484,-37.20787541],[144.06740744,-37.21051446],[144.06487731,-37.21718811],[144.0659366,-37.22499044],[144.06202949,-37.23265909],[144.06037391,-37.23821472],[144.06430587,-37.24457936],[144.06244708,-37.25207203],[144.0528238,-37.25012911],[144.04832718,-37.25207446],[144.04166834,-37.2564734],[144.03801695,-37.26420116],[144.02743079,-37.26194415],[144.01889812,-37.26326933],[144.01376474,-37.26186741],[144.00983061,-37.25831324],[144.00731828,-37.25911875],[144.00005197,-37.25532461],[144.00141845,-37.25228736],[143.99505281,-37.24375216],[143.99817748,-37.24402518],[144.00033961,-37.23999434],[143.9938651,-37.23678746],[143.99208308,-37.23328232],[143.98669588,-37.23190033],[143.98411961,-37.23340741],[143.98105659,-37.22905299],[143.97688261,-37.22993209],[143.97426476,-37.22769225],[143.97072672,-37.2281696],[143.96364478,-37.22230147],[143.95856719,-37.22025247],[143.95573129,-37.21594943],[143.95628775,-37.21373679],[143.95173518,-37.20550457],[143.95204524,-37.20347194],[143.94884018,-37.20010587],[143.94906313,-37.19784176],[143.94878419,-37.19497871],[143.95150044,-37.19385756],[143.95159254,-37.19093403],[143.955057,-37.18810116],[143.95687721,-37.18319299],[143.95997718,-37.18130092],[143.96251111,-37.17674289],[143.96178903,-37.17341783],[143.95893009,-37.17191488],[143.96067306,-37.16952085],[143.95884702,-37.16743587],[143.96089997,-37.16437889],[143.96359187,-37.16348382],[143.96294865,-37.14872674],[143.95867564,-37.14455585],[143.95682353,-37.14097993],[143.96275812,-37.12880907],[143.96112176,-37.12352256],[143.96266545,-37.1181322],[143.96178727,-37.11615175],[143.96528818,-37.11068727],[143.96371503,-37.10833201],[143.96580939,-37.10437664],[143.9645743,-37.10119532],[143.96999816,-37.09681851],[143.96993286,-37.09264198],[143.97447791,-37.09298387],[143.97836878,-37.09937577],[143.98193211,-37.09626698],[143.98120583,-37.0930865],[143.98544321,-37.08737664],[143.98880534,-37.08569331],[143.99401269,-37.08496468],[143.99929892,-37.0788883],[144.00881972,-37.07725716],[144.01654589,-37.06997902],[144.01582784,-37.06524205],[144.00988315,-37.05812555],[143.99694685,-37.05661133],[143.99158168,-37.05405621],[143.99037309,-37.04891379],[143.98279722,-37.04132063],[143.98164633,-37.03731843],[143.97625882,-37.033231],[143.97509008,-37.02957536],[143.95877469,-37.02787271],[143.89953035,-37.02110899],[143.89571253,-37.02349085],[143.89946906,-37.00051864],[143.89112526,-37.00029188],[143.88229325,-36.99852541],[143.88418919,-36.9864579],[143.83383423,-36.9806136],[143.83599053,-36.97866683],[143.8340661,-36.9734113],[143.83715064,-36.97173571],[143.8351568,-36.96610047],[143.83712733,-36.96295216],[143.8413803,-36.96187698],[143.84545944,-36.96298823],[143.84660096,-36.95763999],[143.85211701,-36.95716282],[143.8569492,-36.95285877],[143.85990484,-36.94899158],[143.85601974,-36.94762179],[143.85527488,-36.94311185],[143.85189544,-36.93676676],[143.84853574,-36.93420882],[143.84995653,-36.93127183],[143.84679432,-36.92845974],[143.85407831,-36.9223588],[143.85667605,-36.91703054],[143.86310068,-36.91526052],[143.86318106,-36.90986563],[143.86711052,-36.90642634],[143.86543425,-36.90401738],[143.86647194,-36.90126372],[143.85588335,-36.89997998],[143.85854195,-36.88578075],[143.84898948,-36.88435142],[143.84593029,-36.88042476],[143.81694925,-36.87676907],[143.80188293,-36.87400896],[143.79113196,-36.87505714],[143.76803223,-36.86894269],[143.75684583,-36.86775703],[143.75424659,-36.86088002],[143.75732451,-36.84645167],[143.75885077,-36.84294644],[143.71781558,-36.83759035],[143.71713194,-36.835902],[143.70151857,-36.82321784],[143.68514416,-36.81912142],[143.68012271,-36.8165696],[143.67698075,-36.81160653],[143.6802668,-36.7992754],[143.67822261,-36.78703889],[143.67733207,-36.78455735],[143.67490883,-36.76893683],[143.66730271,-36.75637455],[143.67176998,-36.75695434],[143.67440163,-36.74228333],[143.66501448,-36.74112232],[143.66962811,-36.7236975],[143.65131868,-36.72309902],[143.63208464,-36.72107542],[143.63316071,-36.72347056],[143.63280855,-36.72846122],[143.62898231,-36.73296866],[143.62838291,-36.73583203],[143.57378395,-36.72902075],[143.5685221,-36.74180434],[143.55034562,-36.73975455],[143.54821715,-36.74258005],[143.54541381,-36.74121668],[143.53943349,-36.74045514],[143.49558217,-36.74086416],[143.49564877,-36.75552381],[143.46346869,-36.75549139],[143.46396847,-36.75322036],[143.45974632,-36.74493707],[143.46436077,-36.73997422],[143.46424092,-36.73618969],[143.46083145,-36.73227816],[143.4631474,-36.72855215],[143.46590605,-36.72794644],[143.46801159,-36.72426524],[143.47061669,-36.7232651],[143.46952961,-36.72027936],[143.47390106,-36.71733213],[143.47473248,-36.71134842],[143.47826404,-36.71037502],[143.48777521,-36.70395101],[143.48694232,-36.69901724],[143.48960501,-36.69592164],[143.49207727,-36.68848964],[143.49670961,-36.68738903],[143.49631248,-36.68051827],[143.50129812,-36.67086533],[143.50001019,-36.66800209],[143.50293027,-36.66371864],[143.49828468,-36.65811728],[143.49737989,-36.65470394],[143.49897685,-36.65253123],[143.49207693,-36.64620767],[143.49179038,-36.64090249],[143.4882256,-36.64040424],[143.486261,-36.62567027],[143.47879544,-36.62596826],[143.47302439,-36.62434126],[143.46441066,-36.61814767],[143.45974405,-36.61841523],[143.45614803,-36.62095129],[143.44860009,-36.62254423],[143.44773506,-36.61838141],[143.44338546,-36.61818436],[143.44304271,-36.61451381],[143.43885851,-36.61258053],[143.44110333,-36.6105156],[143.43918182,-36.60543568],[143.43589655,-36.60537793],[143.43614796,-36.60093742],[143.43947581,-36.59667995],[143.43680758,-36.59385803],[143.43969982,-36.59231851],[143.43496436,-36.58367392],[143.43083953,-36.5819089],[143.42854607,-36.57723671],[143.43076271,-36.5737301],[143.42998687,-36.56996084],[143.42633913,-36.56766411],[143.4249371,-36.56233459],[143.41926303,-36.56099355],[143.42166086,-36.55792751],[143.41678415,-36.55580723],[143.41121717,-36.55588717],[143.40987732,-36.55332328],[143.40543175,-36.55161953],[143.4018197,-36.55205191],[143.39666341,-36.54733276],[143.39263406,-36.54492595],[143.39114896,-36.54245828],[143.38666549,-36.54211082],[143.38673576,-36.53734475],[143.38371358,-36.53696792],[143.37901315,-36.53841258],[143.37711464,-36.53400649],[143.37335935,-36.53333709],[143.37181237,-36.53127729],[143.36483231,-36.52661968],[143.35972265,-36.52509432],[143.35578987,-36.52068901],[143.34930169,-36.51786409],[143.35215869,-36.51556078],[143.35094247,-36.51369739],[143.34205193,-36.51405158],[143.33509272,-36.51326776],[143.32799432,-36.50382009],[143.32839288,-36.49955903],[143.32498637,-36.49949873],[143.32556526,-36.49235207],[143.32229552,-36.4901898],[143.32175623,-36.48717588],[143.31671792,-36.48359411],[143.31812062,-36.47909889],[143.31519363,-36.47694371],[143.31380913,-36.47362918],[143.31078703,-36.47114324],[143.3113337,-36.46464939],[143.30960561,-36.46018054],[143.30904535,-36.45531642],[143.3058155,-36.45512671],[143.30347421,-36.44981367],[143.30380717,-36.44524748],[143.30158111,-36.44381954],[143.30176731,-36.44016666],[143.3002574,-36.4368478],[143.29481256,-36.43468324],[143.2938254,-36.43117206],[143.29115454,-36.43050892],[143.29062046,-36.42560217],[143.29266419,-36.4217386],[143.29111451,-36.41853238],[143.29196034,-36.41193909],[143.28561449,-36.40668788],[143.25277297,-36.40689722],[143.24797894,-36.4053626],[143.23836087,-36.4053954],[143.23836871,-36.40947733],[143.14738758,-36.40974861],[143.13907947,-36.41302231],[143.13311871,-36.44941527],[143.07261343,-36.44292976],[143.06365508,-36.44524794],[143.04489028,-36.44317697],[143.05278899,-36.45346039],[143.05964375,-36.46161399],[143.055741,-36.4640121],[143.05737581,-36.46817338],[143.05299834,-36.46813115],[143.05144548,-36.47733285],[143.02121643,-36.47400123],[143.01983682,-36.48273755],[142.94319918,-36.47489348],[142.86351953,-36.46679905],[142.82297515,-36.46250086],[142.81683254,-36.4595964],[142.81677387,-36.4375103],[142.79861371,-36.43755707],[142.79854289,-36.40805301],[142.76214838,-36.40810119],[142.76215001,-36.405206],[142.7318183,-36.40523759],[142.73180212,-36.39746388],[142.74295207,-36.39306272],[142.73495496,-36.37603162],[142.73155153,-36.3757304],[142.73155488,-36.29851348],[142.71923742,-36.30721161],[142.7218585,-36.29113441],[142.72558945,-36.29153289],[142.72724088,-36.28139006],[142.74012577,-36.28276513],[142.74306855,-36.26476914],[142.72209513,-36.26248106],[142.72210484,-36.23943863],[142.72804103,-36.23944011],[142.72804636,-36.22445652],[142.72519781,-36.22445579],[142.72515649,-36.20969014],[142.73213825,-36.20969346],[142.73209832,-36.18313057],[142.73566432,-36.18299985],[142.7369382,-36.17581523],[142.73560369,-36.17116619],[142.73659117,-36.1655964],[142.74168355,-36.16618984],[142.74217649,-36.16331712],[142.74601334,-36.1637641],[142.74783588,-36.15335393],[142.74252171,-36.15273478],[142.74339037,-36.14779733],[142.7289465,-36.14714539],[142.72895742,-36.12071402],[142.73201609,-36.10335349],[142.70364852,-36.10004387],[142.6808918,-36.10003434],[142.68089333,-36.09625453],[142.63159585,-36.12545495],[142.63160092,-36.12046279],[142.60424041,-36.12044146],[142.60441425,-35.997833],[142.6007714,-35.99783142],[142.60124494,-35.88342236],[142.60077226,-35.86787252],[142.60107139,-35.77262178],[142.60100258,-35.7364354],[142.72153651,-35.73603589],[142.72168254,-35.67980605],[142.72216822,-35.60800156],[142.72216279,-35.56245933],[142.72235701,-35.47553449],[142.72246718,-35.47528457],[142.58770485,-35.47568811],[142.5434795,-35.47587803],[142.54376827,-35.42976711],[142.54385591,-35.38683606],[142.53532037,-35.38671878],[142.53577464,-35.30269014],[142.52809044,-35.3019995],[142.52522329,-35.30315556],[142.47092778,-35.30303194],[142.46720456,-35.30418723],[142.46288096,-35.30317959],[142.41787177,-35.30299651],[142.41168871,-35.30385347],[142.40330074,-35.30294351],[142.40334731,-35.2953941],[142.3786351,-35.29528936],[142.3741561,-35.29699941],[142.36858206,-35.29530829],[142.3638225,-35.29215087],[142.351982,-35.29516015],[142.32269755,-35.29499592],[142.31438491,-35.29737284],[142.31056915,-35.29494835],[142.30123515,-35.29358569],[142.29131325,-35.29550424],[142.28941832,-35.29086401],[142.25721941,-35.29984909],[142.25269844,-35.30465155],[142.24490772,-35.30746096],[142.24392868,-35.31095769],[142.22241388,-35.31094818],[142.21794748,-35.31251363],[142.20072376,-35.31506597],[142.19509566,-35.3131543],[142.18894463,-35.32258057],[142.18125743,-35.32224946],[142.18373261,-35.32948916],[142.18128377,-35.33185698],[142.18197995,-35.33435032],[142.19219479,-35.34267628],[142.19706628,-35.3516302],[142.19676683,-35.35412403],[142.17908403,-35.35400789],[142.17774091,-35.36017624],[142.17417405,-35.36240767],[142.1821471,-35.36694893],[142.17363965,-35.37587526],[142.18344085,-35.39808743],[142.18249308,-35.39837787],[142.19177434,-35.41859526],[142.19256363,-35.41893418],[142.20683157,-35.45008913],[142.16850667,-35.44986406],[142.16709088,-35.4562671],[142.16685025,-35.47844364],[142.16156599,-35.47849736],[142.1515138,-35.47656661],[142.14845534,-35.478589],[142.14221288,-35.48014499],[142.13136034,-35.4783055],[142.12676745,-35.47293227],[142.11546458,-35.46982723],[142.10560952,-35.46843861],[142.10063645,-35.46637073],[142.09620932,-35.46938855],[142.09133344,-35.46935149],[142.08142755,-35.46459025],[142.04218199,-35.46427235],[141.9974765,-35.46350263],[141.99748082,-35.49843568],[141.75295884,-35.49840265],[141.53824949,-35.49852931],[141.49945892,-35.49851159],[141.49956906,-35.62533026],[141.49975764,-35.74858282],[141.37776317,-35.74851455],[141.33290639,-35.74852945],[141.25132657,-35.74851613],[141.1263264,-35.74851854],[141.00132664,-35.7485205],[140.96310342,-35.74853455],[140.96349255,-35.85979104],[140.96385298,-35.96259464],[140.96388933,-35.99606634],[140.96549822,-36.15960392],[140.96646217,-36.25717493],[140.96735229,-36.37396373],[140.96762844,-36.38150252],[140.96775749,-36.44936671],[140.96753829,-36.44992018],[140.96777589,-36.50490481],[140.96853372,-36.55133627],[140.96890742,-36.66499751],[140.96858111,-36.73424898],[140.96876018,-36.73424852],[140.96900754,-36.79316079],[140.96929713,-36.82443126],[140.96986651,-36.84889391],[140.97042088,-36.90507585],[140.97059534,-36.9111255],[140.97116787,-36.97031649],[140.97142415,-37.00626513],[140.97188454,-37.03608224],[140.971983,-37.06654828],[140.97164283,-37.16148736],[140.97127537,-37.22880266],[140.9710464,-37.22930634],[140.97173548,-37.25843575],[140.97330999,-37.31041198],[140.97328311,-37.35832573],[140.99224952,-37.37415342],[141.00363039,-37.37760405],[141.0237847,-37.39137032],[141.04640777,-37.40186008],[141.09529617,-37.44561223],[141.09759973,-37.44983896],[141.16823737,-37.41988028],[141.1890734,-37.42211285],[141.23083138,-37.42624005],[141.26103662,-37.42967482],[141.25870937,-37.42656578],[141.26058411,-37.42083289],[141.26377549,-37.42298476],[141.2686346,-37.42203818],[141.2710255,-37.41738605],[141.27139468,-37.41337014],[141.27394541,-37.40694159],[141.27148238,-37.40298925],[141.27618835,-37.39717619],[141.2804319,-37.39557314],[141.27911837,-37.39309351],[141.27175011,-37.3915484],[141.27435426,-37.38577234],[141.27019733,-37.38288625],[141.26544868,-37.3819163],[141.26185806,-37.37712757],[141.25366671,-37.37595364],[141.25025609,-37.37372922],[141.24847256,-37.36924277],[141.24313771,-37.36928377],[141.24175729,-37.36660977],[141.23735596,-37.36575284],[141.23267871,-37.36740794],[141.22088085,-37.36457413],[141.2206633,-37.36158639],[141.21723185,-37.35541299],[141.22100384,-37.34870529],[141.24720697,-37.35157687],[141.3452107,-37.36272557],[141.38867425,-37.36737668],[141.43153017,-37.37230222],[141.43150502,-37.29753651],[141.48214663,-37.29751809],[141.53144401,-37.29764343],[141.52989102,-37.29344843],[141.52476464,-37.28998702],[141.52668438,-37.28524822],[141.52359115,-37.28232433],[141.51858673,-37.28113418],[141.52281918,-37.27859707],[141.52335118,-37.27487942],[141.52098677,-37.27405177],[141.5167443,-37.26680261],[141.5136297,-37.26530276],[141.51087344,-37.26067099],[141.50611648,-37.25996495],[141.50480704,-37.25633101],[141.49932374,-37.25696288],[141.49221748,-37.25094919],[141.48950851,-37.24635919],[141.49012376,-37.24302108],[141.4961835,-37.23934313],[141.49658522,-37.23567179],[141.48980748,-37.23469261],[141.49102562,-37.23069776],[141.49614627,-37.22662216],[141.49477304,-37.22362824],[141.49098074,-37.22321556],[141.49132569,-37.22070715],[141.49445293,-37.21825605],[141.49737132,-37.21911412],[141.50613273,-37.21363316],[141.5110586,-37.21156924],[141.51494486,-37.21120606],[141.51983651,-37.20824975],[141.52890095,-37.2042628],[141.53341926,-37.20349976],[141.53948657,-37.20102431],[141.5426067,-37.20216498],[141.5523327,-37.1977865],[141.55714804,-37.19444563],[141.56274286,-37.19214603],[141.57617848,-37.18812203],[141.57982628,-37.18534723],[141.57907129,-37.18281158],[141.58363725,-37.17851642],[141.58657361,-37.17335847],[141.59259645,-37.17051022],[141.59587379,-37.16550997],[141.59502802,-37.16255763],[141.5990068,-37.16109439],[141.6061443,-37.16290781],[141.6124389,-37.16588509],[141.61861745,-37.16372562],[141.62062285,-37.16595944],[141.62412365,-37.16539262],[141.62937683,-37.15733598],[141.63256664,-37.155454],[141.63410286,-37.1641883],[141.63984835,-37.16542225],[141.64340544,-37.16041862],[141.65060333,-37.15799466],[141.65590883,-37.15778955],[141.65822854,-37.15629493],[141.66838297,-37.15518794],[141.67068739,-37.1562345],[141.67162826,-37.16107173],[141.68146063,-37.16246662],[141.68367605,-37.16650691],[141.68991824,-37.16789206],[141.6922992,-37.16490147],[141.69683853,-37.17243258],[141.69988253,-37.17520675],[141.70257138,-37.18106039],[141.7079119,-37.1847334],[141.71376002,-37.18338929],[141.7166142,-37.1857654],[141.71905534,-37.1834733],[141.72456915,-37.18801455],[141.72697209,-37.18707329],[141.72780808,-37.18373722],[141.73124189,-37.18048893],[141.73085604,-37.17815022],[141.74019032,-37.18144251],[141.74361464,-37.17860181],[141.74041821,-37.17526481],[141.74658359,-37.17369812],[141.74924581,-37.17786277],[141.75423323,-37.17381704],[141.76303101,-37.17473501],[141.76776148,-37.17941123],[141.77186596,-37.17928545],[141.7725925,-37.17331849],[141.77540576,-37.17389054],[141.77616611,-37.17697408]]],[[[149.9153975,-37.56891295],[149.91773878,-37.56910297],[149.91704773,-37.56316593],[149.91389292,-37.55532229],[149.90979413,-37.55101932],[149.90633998,-37.55028682],[149.9087752,-37.55560137],[149.90850542,-37.55799142],[149.90432828,-37.5607834],[149.90674157,-37.56776882],[149.91336995,-37.56974743],[149.9153975,-37.56891295]]]]}
        ]},
            path:   index$2().projection(
                        mercator()
                        .scale(5000)
                        .center([148.1, -39.2])
                    )
        },
        "State": {
            shape: {"type":"FeatureCollection", "features": [
                {"type": "Feature", "geometry": {"type": "MultiPolygon", "coordinates": [ [[[145.131889,-38.390694],[145.129935,-38.390452],[145.096149,-38.402507],[145.076384,-38.425446],[145.050185,-38.430022],[145.025135,-38.475332],[145.032399,-38.486451],[145.010999,-38.479662],[144.976631,-38.490335],[144.948813,-38.488548],[144.937410,-38.497082],[144.918641,-38.497017],[144.911152,-38.489253],[144.887256,-38.498852],[144.886653,-38.477217],[144.838574,-38.430328],[144.741749,-38.353947],[144.651908,-38.304077],[144.680224,-38.305219],[144.734143,-38.322480],[144.766733,-38.356385],[144.814684,-38.368549],[144.850929,-38.368747],[144.923174,-38.349256],[144.988387,-38.316711],[144.994327,-38.304469],[144.982830,-38.296413],[145.025610,-38.253352],[145.032420,-38.212673],[145.044952,-38.213405],[145.061688,-38.201202],[145.087550,-38.164238],[145.118468,-38.145695],[145.124504,-38.108031],[145.119793,-38.074099],[145.125612,-38.071656],[145.119588,-38.073219],[145.099517,-38.026878],[145.062214,-37.990841],[145.051408,-37.986726],[145.037916,-37.996447],[145.017945,-37.981804],[144.985526,-37.926238],[144.985912,-37.893195],[144.970308,-37.860787],[144.935592,-37.842548],[144.929856,-37.847323],[144.925849,-37.839845],[144.913404,-37.841967],[144.912499,-37.849458],[144.905739,-37.840155],[144.907213,-37.849526],[144.897148,-37.842552],[144.905593,-37.851732],[144.895277,-37.848421],[144.903624,-37.861466],[144.915524,-37.865543],[144.904253,-37.872525],[144.878621,-37.868083],[144.868582,-37.858712],[144.814390,-37.875144],[144.797950,-37.905305],[144.799170,-37.923170],[144.735586,-37.943135],[144.651639,-38.001638],[144.592488,-38.004581],[144.558663,-38.037541],[144.515692,-38.045604],[144.506846,-38.091508],[144.487431,-38.078280],[144.470912,-38.083542],[144.464016,-38.076715],[144.444841,-38.091800],[144.397943,-38.073816],[144.380690,-38.085264],[144.381575,-38.097352],[144.361606,-38.105136],[144.366582,-38.109905],[144.355617,-38.137201],[144.365166,-38.144831],[144.384800,-38.143255],[144.402640,-38.155458],[144.416599,-38.155329],[144.425598,-38.123813],[144.442823,-38.149522],[144.478136,-38.164482],[144.557972,-38.154858],[144.631382,-38.107385],[144.692223,-38.119967],[144.720200,-38.146631],[144.719630,-38.173256],[144.706371,-38.210220],[144.695743,-38.219760],[144.703393,-38.201527],[144.686582,-38.197462],[144.623171,-38.251465],[144.637022,-38.266100],[144.632984,-38.269788],[144.672246,-38.265268],[144.659776,-38.273912],[144.620173,-38.275913],[144.613879,-38.292253],[144.538709,-38.271631],[144.508432,-38.274791],[144.494878,-38.282627],[144.499893,-38.290490],[144.428618,-38.281629],[144.332286,-38.323258],[144.327444,-38.340177],[144.303480,-38.348258],[144.279510,-38.372347],[144.256633,-38.382747],[144.254013,-38.395472],[144.200022,-38.406675],[144.180587,-38.418909],[144.184016,-38.428699],[144.133818,-38.434529],[144.104758,-38.469255],[144.036497,-38.475775],[143.979728,-38.532276],[143.977136,-38.542552],[143.986836,-38.548451],[143.974348,-38.565237],[143.923066,-38.593108],[143.910271,-38.623094],[143.870284,-38.655271],[143.866226,-38.671668],[143.842147,-38.679003],[143.837008,-38.692793],[143.756722,-38.706707],[143.681545,-38.737487],[143.670413,-38.752384],[143.679941,-38.760838],[143.666695,-38.768315],[143.666012,-38.779379],[143.646427,-38.791286],[143.616031,-38.795509],[143.554064,-38.855695],[143.510919,-38.857580],[143.428687,-38.783354],[143.403133,-38.780987],[143.356589,-38.753950],[143.327535,-38.757208],[143.302169,-38.750179],[143.267387,-38.763093],[143.259696,-38.772964],[143.232964,-38.766436],[143.080833,-38.651018],[143.054990,-38.647870],[143.055030,-38.641398],[143.015378,-38.624500],[142.947884,-38.619768],[142.937026,-38.627336],[142.900650,-38.610166],[142.857631,-38.605289],[142.852333,-38.591827],[142.787658,-38.569124],[142.684028,-38.495133],[142.563319,-38.422004],[142.492181,-38.393871],[142.478862,-38.395027],[142.480598,-38.401392],[142.471653,-38.404310],[142.372518,-38.349483],[142.309371,-38.356322],[142.285960,-38.366494],[142.261528,-38.364586],[142.244323,-38.378032],[142.243958,-38.387985],[142.255037,-38.391190],[142.244905,-38.396468],[142.145800,-38.391487],[142.002670,-38.310335],[141.929505,-38.278215],[141.881510,-38.265811],[141.742014,-38.253109],[141.679524,-38.267864],[141.601621,-38.313185],[141.607931,-38.342272],[141.623594,-38.341701],[141.625059,-38.361992],[141.650257,-38.393048],[141.627968,-38.393458],[141.626417,-38.406344],[141.614846,-38.393020],[141.573078,-38.389705],[141.557894,-38.405684],[141.555861,-38.426270],[141.542787,-38.432968],[141.521271,-38.414710],[141.528466,-38.404854],[141.519235,-38.390029],[141.461020,-38.362096],[141.434371,-38.360306],[141.407068,-38.369077],[141.413232,-38.396287],[141.374319,-38.386757],[141.364091,-38.377011],[141.365531,-38.365317],[141.397693,-38.338554],[141.392104,-38.319729],[141.357610,-38.274759],[141.295280,-38.220641],[141.227776,-38.170649],[141.150129,-38.126841],[141.028512,-38.071588],[140.965735,-38.055989],[140.973872,-37.462093],[140.963103,-35.748535],[140.963616,-33.980648],[140.969273,-33.997216],[140.980575,-33.999996],[140.975320,-34.009321],[140.986747,-34.010237],[140.980453,-34.016013],[140.988431,-34.030777],[140.998139,-34.019698],[141.012311,-34.024655],[141.003776,-34.027604],[141.001870,-34.039103],[141.023262,-34.059699],[141.034336,-34.035735],[141.043439,-34.042704],[141.042463,-34.061101],[141.065601,-34.050062],[141.071951,-34.062910],[141.084910,-34.062288],[141.089218,-34.076696],[141.097587,-34.070035],[141.087257,-34.057173],[141.094238,-34.050656],[141.120338,-34.064866],[141.137307,-34.057561],[141.142973,-34.063534],[141.153111,-34.054521],[141.153443,-34.064189],[141.143847,-34.067799],[141.153180,-34.068915],[141.153670,-34.082118],[141.165854,-34.083212],[141.174668,-34.073334],[141.186230,-34.091977],[141.194437,-34.087608],[141.187449,-34.079294],[141.205907,-34.061723],[141.222119,-34.061677],[141.228468,-34.073651],[141.241808,-34.061315],[141.247217,-34.073209],[141.242543,-34.087341],[141.259566,-34.078134],[141.283701,-34.103874],[141.300790,-34.113718],[141.317451,-34.112413],[141.313530,-34.124860],[141.325922,-34.126866],[141.324937,-34.138782],[141.346407,-34.124348],[141.348504,-34.112311],[141.358972,-34.110723],[141.368758,-34.127115],[141.369693,-34.120204],[141.381587,-34.122143],[141.388118,-34.134730],[141.408248,-34.127856],[141.407404,-34.146400],[141.433901,-34.145904],[141.432802,-34.159940],[141.444539,-34.168015],[141.450643,-34.161004],[141.482801,-34.163425],[141.494967,-34.154611],[141.518744,-34.180910],[141.506669,-34.190619],[141.518577,-34.203159],[141.506149,-34.210498],[141.510071,-34.216479],[141.533863,-34.210697],[141.533546,-34.191434],[141.547738,-34.200841],[141.560468,-34.190900],[141.583921,-34.198816],[141.589743,-34.186893],[141.603285,-34.191228],[141.604947,-34.183933],[141.589383,-34.177353],[141.602959,-34.162254],[141.584484,-34.151403],[141.604580,-34.149115],[141.618538,-34.156287],[141.611817,-34.139023],[141.627982,-34.145417],[141.632653,-34.121484],[141.677450,-34.101225],[141.707415,-34.096068],[141.720288,-34.114589],[141.729935,-34.105442],[141.729691,-34.090896],[141.746343,-34.103403],[141.761836,-34.097537],[141.752623,-34.106242],[141.756947,-34.112097],[141.777897,-34.101774],[141.776886,-34.116878],[141.786445,-34.111685],[141.841383,-34.132452],[141.850694,-34.124307],[141.853257,-34.131233],[141.867763,-34.128652],[141.876627,-34.137418],[141.888789,-34.124415],[141.884744,-34.114984],[141.900686,-34.111198],[141.922592,-34.114570],[141.929784,-34.125790],[141.925629,-34.134605],[141.932990,-34.138238],[141.945003,-34.119477],[141.970437,-34.136107],[141.969742,-34.119898],[141.978235,-34.112616],[142.021240,-34.125258],[142.012927,-34.105246],[142.036848,-34.099306],[142.042265,-34.105298],[142.029400,-34.118211],[142.023852,-34.115054],[142.027564,-34.122981],[142.075638,-34.131418],[142.065345,-34.150611],[142.077538,-34.157346],[142.082770,-34.173545],[142.119613,-34.174909],[142.120343,-34.156705],[142.135161,-34.160738],[142.146367,-34.148972],[142.165577,-34.152124],[142.159255,-34.171482],[142.166529,-34.171395],[142.166148,-34.182923],[142.178309,-34.183743],[142.183613,-34.175672],[142.198580,-34.183496],[142.219102,-34.181064],[142.233130,-34.214407],[142.235645,-34.204042],[142.243720,-34.209870],[142.235334,-34.223748],[142.244030,-34.232457],[142.243579,-34.245768],[142.232290,-34.255036],[142.248993,-34.265054],[142.248845,-34.284983],[142.232465,-34.296749],[142.235894,-34.306973],[142.253057,-34.306139],[142.267332,-34.295284],[142.273673,-34.304021],[142.286132,-34.296536],[142.298886,-34.305703],[142.284023,-34.310760],[142.283873,-34.326567],[142.294386,-34.323450],[142.330924,-34.339378],[142.368436,-34.326913],[142.396798,-34.338095],[142.384459,-34.346915],[142.389752,-34.362799],[142.363530,-34.362158],[142.378269,-34.364750],[142.368057,-34.370650],[142.373927,-34.388151],[142.363897,-34.385680],[142.350969,-34.396629],[142.360695,-34.411768],[142.351836,-34.422288],[142.364539,-34.422704],[142.359897,-34.431933],[142.367936,-34.435415],[142.353334,-34.469582],[142.379267,-34.466704],[142.384163,-34.478091],[142.364268,-34.484715],[142.359576,-34.498779],[142.369722,-34.503819],[142.377726,-34.491397],[142.394681,-34.493484],[142.374942,-34.515284],[142.400571,-34.522747],[142.367695,-34.530446],[142.378183,-34.532145],[142.376705,-34.540985],[142.390211,-34.549119],[142.405558,-34.541508],[142.407693,-34.567972],[142.426062,-34.562348],[142.430178,-34.574793],[142.444922,-34.575490],[142.451622,-34.584265],[142.458747,-34.581498],[142.448847,-34.559483],[142.467968,-34.564295],[142.472705,-34.576695],[142.458363,-34.587575],[142.471264,-34.592677],[142.461307,-34.606565],[142.468257,-34.612934],[142.459160,-34.616289],[142.463988,-34.626677],[142.452390,-34.633650],[142.471077,-34.640135],[142.483148,-34.635824],[142.471654,-34.651796],[142.472932,-34.670098],[142.497078,-34.669376],[142.498646,-34.681025],[142.514170,-34.690931],[142.499060,-34.700026],[142.518864,-34.703671],[142.499673,-34.739364],[142.511671,-34.740888],[142.507428,-34.748839],[142.524612,-34.759584],[142.533406,-34.753025],[142.538793,-34.762876],[142.550140,-34.762660],[142.556744,-34.775373],[142.567176,-34.766928],[142.615780,-34.785261],[142.632212,-34.784136],[142.644440,-34.775338],[142.646391,-34.763394],[142.620498,-34.757128],[142.618316,-34.728751],[142.637334,-34.735043],[142.661412,-34.721707],[142.667412,-34.735908],[142.678954,-34.739202],[142.686657,-34.733929],[142.676553,-34.729046],[142.678646,-34.722345],[142.698961,-34.725138],[142.684489,-34.714057],[142.691089,-34.701397],[142.678929,-34.680153],[142.684960,-34.670774],[142.710436,-34.676748],[142.709066,-34.662674],[142.689172,-34.651925],[142.700788,-34.624516],[142.708902,-34.621788],[142.689383,-34.616640],[142.703692,-34.613953],[142.700852,-34.598276],[142.714821,-34.600442],[142.722756,-34.592360],[142.743966,-34.602960],[142.761766,-34.598485],[142.762411,-34.589287],[142.745699,-34.586273],[142.748291,-34.576759],[142.784068,-34.580393],[142.769991,-34.568882],[142.782512,-34.564933],[142.791428,-34.546389],[142.810104,-34.560855],[142.787687,-34.590178],[142.797919,-34.597628],[142.810259,-34.589093],[142.804997,-34.608401],[142.818507,-34.612357],[142.823118,-34.600251],[142.825038,-34.608780],[142.838240,-34.613044],[142.840679,-34.625752],[142.852466,-34.619195],[142.868177,-34.627306],[142.855209,-34.639522],[142.871867,-34.650292],[142.860551,-34.665162],[142.872151,-34.664119],[142.875881,-34.674859],[142.886457,-34.672085],[142.886815,-34.679808],[142.900176,-34.671464],[142.893269,-34.665679],[142.901526,-34.654958],[142.923844,-34.647856],[142.922267,-34.656482],[142.932606,-34.655515],[142.948867,-34.669674],[142.959264,-34.664982],[142.972708,-34.695207],[142.982428,-34.682740],[142.975282,-34.670861],[142.989313,-34.662579],[142.994573,-34.673872],[143.017281,-34.673660],[143.010179,-34.693658],[143.032502,-34.682928],[143.029424,-34.691851],[143.039468,-34.702611],[143.040422,-34.685888],[143.054822,-34.698855],[143.070763,-34.678380],[143.076222,-34.695958],[143.092828,-34.701273],[143.112525,-34.680819],[143.121272,-34.687401],[143.111605,-34.687127],[143.107243,-34.701466],[143.127791,-34.692661],[143.117841,-34.703076],[143.133463,-34.700577],[143.147400,-34.714757],[143.161689,-34.697916],[143.165360,-34.718136],[143.173197,-34.719709],[143.180987,-34.709482],[143.179282,-34.717329],[143.199179,-34.717034],[143.200006,-34.733418],[143.218847,-34.729471],[143.213847,-34.738496],[143.224384,-34.758733],[143.228775,-34.747789],[143.240660,-34.745460],[143.248933,-34.757853],[143.265285,-34.748558],[143.274016,-34.752685],[143.252130,-34.772803],[143.273005,-34.776412],[143.276736,-34.792260],[143.286873,-34.794985],[143.284327,-34.785245],[143.294285,-34.790822],[143.308844,-34.779939],[143.318269,-34.790842],[143.347876,-34.791635],[143.347559,-34.807302],[143.359559,-34.816899],[143.341191,-34.846309],[143.354957,-34.846039],[143.345210,-34.853463],[143.352563,-34.858235],[143.338404,-34.870312],[143.341732,-34.881120],[143.321389,-34.888460],[143.340526,-34.913740],[143.342789,-34.932533],[143.339492,-34.943632],[143.322014,-34.942339],[143.317704,-34.952598],[143.323717,-34.979085],[143.318825,-34.992943],[143.329708,-34.995744],[143.338117,-35.010891],[143.331864,-35.023804],[143.335987,-35.037375],[143.322081,-35.036727],[143.328679,-35.045900],[143.336543,-35.043219],[143.330492,-35.053880],[143.337264,-35.048645],[143.337663,-35.061294],[143.350838,-35.064702],[143.339058,-35.068191],[143.345520,-35.074056],[143.337446,-35.080418],[143.345023,-35.087020],[143.340858,-35.095714],[143.348103,-35.105440],[143.360762,-35.103032],[143.361967,-35.116900],[143.390647,-35.145107],[143.381936,-35.173120],[143.391820,-35.172567],[143.386969,-35.183462],[143.394677,-35.192377],[143.449486,-35.189112],[143.471482,-35.219293],[143.518322,-35.211620],[143.529155,-35.219921],[143.548335,-35.213790],[143.547023,-35.206173],[143.570828,-35.206905],[143.580984,-35.220036],[143.563717,-35.243545],[143.574076,-35.256505],[143.571690,-35.267959],[143.583507,-35.265005],[143.590860,-35.281659],[143.577937,-35.303197],[143.569019,-35.302447],[143.562074,-35.337244],[143.598448,-35.352111],[143.603015,-35.365407],[143.616037,-35.368884],[143.620416,-35.387682],[143.633019,-35.383467],[143.629381,-35.392368],[143.642338,-35.401037],[143.657140,-35.384999],[143.668081,-35.385735],[143.667922,-35.371554],[143.682627,-35.374091],[143.684521,-35.368446],[143.693148,-35.383917],[143.702284,-35.377882],[143.703349,-35.389408],[143.711685,-35.384690],[143.709175,-35.392538],[143.751004,-35.387835],[143.768823,-35.401809],[143.758802,-35.415427],[143.765962,-35.415858],[143.762852,-35.423066],[143.790117,-35.422477],[143.818018,-35.437545],[143.813021,-35.446265],[143.855435,-35.461838],[143.858784,-35.479978],[143.871380,-35.477828],[143.876584,-35.486166],[143.907733,-35.494162],[143.906183,-35.499958],[143.935045,-35.499288],[143.933355,-35.506610],[143.970101,-35.500078],[143.972536,-35.509249],[143.962441,-35.513980],[143.974476,-35.532309],[143.996841,-35.536250],[143.999221,-35.545367],[143.989865,-35.554663],[144.009646,-35.563307],[144.012702,-35.554073],[144.034082,-35.555971],[144.039215,-35.549257],[144.046800,-35.563141],[144.063958,-35.570545],[144.062285,-35.576768],[144.105015,-35.590780],[144.117546,-35.625926],[144.131488,-35.640761],[144.142927,-35.647253],[144.152629,-35.642678],[144.162351,-35.671526],[144.186788,-35.670431],[144.195139,-35.685858],[144.213483,-35.686671],[144.221647,-35.693952],[144.215952,-35.706477],[144.248150,-35.721034],[144.264496,-35.751403],[144.296060,-35.737091],[144.301278,-35.742986],[144.295276,-35.754379],[144.327832,-35.752646],[144.318651,-35.766574],[144.349111,-35.767142],[144.351546,-35.785069],[144.360283,-35.784811],[144.355338,-35.788479],[144.362329,-35.795834],[144.376850,-35.792979],[144.366709,-35.811253],[144.377484,-35.814346],[144.364806,-35.820937],[144.384118,-35.819565],[144.372189,-35.831950],[144.382044,-35.833175],[144.372936,-35.838150],[144.384314,-35.841922],[144.381433,-35.852423],[144.390318,-35.850553],[144.388885,-35.858480],[144.398635,-35.862667],[144.411388,-35.859003],[144.401926,-35.868020],[144.410936,-35.871189],[144.403628,-35.880666],[144.418183,-35.893220],[144.407927,-35.904013],[144.424381,-35.900194],[144.416979,-35.910472],[144.423428,-35.906005],[144.426505,-35.918744],[144.446974,-35.935531],[144.460553,-35.939596],[144.466553,-35.933602],[144.464123,-35.940942],[144.472233,-35.940725],[144.466691,-35.945927],[144.479415,-35.945275],[144.479758,-35.953295],[144.487583,-35.949511],[144.481230,-35.958609],[144.488638,-35.957123],[144.493963,-35.968592],[144.501900,-35.958039],[144.501128,-35.970606],[144.513047,-35.965202],[144.509950,-35.973945],[144.521099,-35.970266],[144.512009,-35.988895],[144.516140,-35.995438],[144.553661,-36.002984],[144.557655,-36.014107],[144.563385,-36.007806],[144.571127,-36.024079],[144.586445,-36.027182],[144.582515,-36.038135],[144.590991,-36.043318],[144.598917,-36.037411],[144.608761,-36.041808],[144.605957,-36.036542],[144.615473,-36.031593],[144.617551,-36.046904],[144.608432,-36.063641],[144.617670,-36.077192],[144.628221,-36.065259],[144.618300,-36.059708],[144.626288,-36.061800],[144.624999,-36.052081],[144.632744,-36.048097],[144.643921,-36.056664],[144.653191,-36.053240],[144.654966,-36.075349],[144.658022,-36.070380],[144.664631,-36.077042],[144.667856,-36.068596],[144.689004,-36.061417],[144.683907,-36.095138],[144.697522,-36.094047],[144.698886,-36.087259],[144.706461,-36.092948],[144.715385,-36.086214],[144.725675,-36.089438],[144.717445,-36.112113],[144.726379,-36.117781],[144.740569,-36.107576],[144.748239,-36.121746],[144.771896,-36.116132],[144.777064,-36.129837],[144.794782,-36.117285],[144.807870,-36.123628],[144.813362,-36.113912],[144.806398,-36.107457],[144.816340,-36.109865],[144.809893,-36.102428],[144.819903,-36.107947],[144.841922,-36.100576],[144.841901,-36.083098],[144.850851,-36.080645],[144.847176,-36.072881],[144.856474,-36.073553],[144.857534,-36.065171],[144.861373,-36.071838],[144.863460,-36.059112],[144.932614,-36.067049],[144.948290,-36.082904],[144.981909,-36.072316],[144.985932,-36.056509],[144.967808,-36.042078],[144.961831,-36.018216],[144.945499,-36.012186],[144.945759,-36.004312],[144.923606,-35.988768],[144.931005,-35.968470],[144.957378,-35.961005],[144.948917,-35.931602],[144.974954,-35.883845],[144.968187,-35.865528],[144.991436,-35.858984],[144.992263,-35.852338],[145.018998,-35.856647],[145.049713,-35.833671],[145.061056,-35.837309],[145.089998,-35.825457],[145.091922,-35.835957],[145.114092,-35.820548],[145.126435,-35.829671],[145.127683,-35.820716],[145.136636,-35.834270],[145.139579,-35.828538],[145.159170,-35.831077],[145.153456,-35.843045],[145.181014,-35.842026],[145.189806,-35.834267],[145.222760,-35.842440],[145.225029,-35.832184],[145.246178,-35.830321],[145.260717,-35.835426],[145.258317,-35.850588],[145.272698,-35.845203],[145.296542,-35.860566],[145.324453,-35.850686],[145.355400,-35.867067],[145.387150,-35.850142],[145.410625,-35.848613],[145.412575,-35.830601],[145.442293,-35.835642],[145.450658,-35.821418],[145.463440,-35.826274],[145.472128,-35.809230],[145.491977,-35.815076],[145.502556,-35.809449],[145.522510,-35.818486],[145.535398,-35.801983],[145.541889,-35.808905],[145.538763,-35.821813],[145.546741,-35.812894],[145.562836,-35.813449],[145.557997,-35.828230],[145.566840,-35.826497],[145.564011,-35.834190],[145.593230,-35.849077],[145.586792,-35.861245],[145.598028,-35.861458],[145.601134,-35.875008],[145.606474,-35.874998],[145.601748,-35.867857],[145.626347,-35.862758],[145.628320,-35.867775],[145.614857,-35.872570],[145.628134,-35.875409],[145.620321,-35.883884],[145.629570,-35.880105],[145.639730,-35.894239],[145.657449,-35.900686],[145.669121,-35.919586],[145.679053,-35.916829],[145.673992,-35.925924],[145.685852,-35.930615],[145.698181,-35.920977],[145.703269,-35.925702],[145.695763,-35.925792],[145.697327,-35.936501],[145.720274,-35.934449],[145.726300,-35.942312],[145.716766,-35.950594],[145.734238,-35.951348],[145.731027,-35.958734],[145.746109,-35.964239],[145.778211,-35.960243],[145.777006,-35.972559],[145.792732,-35.972801],[145.793445,-35.982817],[145.807980,-35.983762],[145.811662,-35.991769],[145.816680,-35.988200],[145.811353,-35.984102],[145.828252,-35.982982],[145.827548,-35.975438],[145.840021,-35.983244],[145.848589,-35.980899],[145.845548,-35.973460],[145.858624,-35.974814],[145.847975,-35.968689],[145.854042,-35.959927],[145.902693,-35.952496],[145.910314,-35.955962],[145.900756,-35.961529],[145.902934,-35.968856],[145.925821,-35.964563],[145.928000,-35.973947],[145.953701,-35.961500],[145.944304,-35.966495],[145.951071,-35.976626],[145.945744,-35.983809],[145.964818,-35.996770],[145.958336,-36.006973],[145.971314,-36.005651],[145.972070,-36.015747],[146.005866,-36.003569],[146.016143,-36.006962],[146.031488,-35.994714],[146.048421,-36.003158],[146.052346,-35.995465],[146.059295,-36.014548],[146.073550,-36.009637],[146.075639,-36.018177],[146.092199,-36.021266],[146.091470,-36.009477],[146.112378,-36.006811],[146.107678,-36.014369],[146.118718,-36.018014],[146.134761,-36.002547],[146.140650,-36.008954],[146.132045,-36.010095],[146.131357,-36.019413],[146.145863,-36.013776],[146.154680,-36.025159],[146.173104,-36.019293],[146.185976,-36.042071],[146.199244,-36.027453],[146.204747,-36.039158],[146.211581,-36.028559],[146.211155,-36.038860],[146.222171,-36.029921],[146.242980,-36.028784],[146.241433,-36.023524],[146.250889,-36.023130],[146.244593,-36.018340],[146.257183,-36.012053],[146.272859,-36.026631],[146.275030,-36.012441],[146.282895,-36.011048],[146.278803,-36.015850],[146.291125,-36.020163],[146.282181,-36.026188],[146.293104,-36.029503],[146.283023,-36.041488],[146.291396,-36.038952],[146.299009,-36.047859],[146.300963,-36.036590],[146.312986,-36.045568],[146.315875,-36.038453],[146.329072,-36.043144],[146.325022,-36.033543],[146.338890,-36.026395],[146.368684,-36.050862],[146.387557,-36.035639],[146.379594,-36.028127],[146.380606,-36.012895],[146.399134,-36.007199],[146.402962,-35.988780],[146.425169,-35.973027],[146.421673,-35.965831],[146.437159,-35.967015],[146.444738,-35.977991],[146.454595,-35.962247],[146.469966,-35.976201],[146.467407,-35.984240],[146.499726,-35.990870],[146.502134,-35.983188],[146.492480,-35.985012],[146.500674,-35.979244],[146.502585,-35.958235],[146.519681,-35.960604],[146.532293,-35.984299],[146.549581,-35.992457],[146.555958,-35.989182],[146.552029,-35.979592],[146.560301,-35.976391],[146.583967,-35.983864],[146.584147,-35.974987],[146.612520,-35.972858],[146.618716,-35.975937],[146.607820,-35.986372],[146.614299,-35.996480],[146.650868,-36.007735],[146.650178,-36.013796],[146.658574,-36.014488],[146.650336,-36.018411],[146.655996,-36.026252],[146.680199,-36.022376],[146.675365,-36.028599],[146.685812,-36.040576],[146.695002,-36.034315],[146.689603,-36.030446],[146.707141,-36.036122],[146.708878,-36.029435],[146.731645,-36.023725],[146.730065,-36.044724],[146.752929,-36.042113],[146.749851,-36.061277],[146.762315,-36.051665],[146.762818,-36.059519],[146.796181,-36.065138],[146.794570,-36.058545],[146.803936,-36.055194],[146.818380,-36.067834],[146.816301,-36.074377],[146.825542,-36.070847],[146.825026,-36.088724],[146.836700,-36.082073],[146.857158,-36.084918],[146.864530,-36.073084],[146.872952,-36.073681],[146.880556,-36.087524],[146.906910,-36.084946],[146.907763,-36.111284],[146.924058,-36.108315],[146.926804,-36.097178],[146.943705,-36.115989],[146.952498,-36.110788],[146.956824,-36.078061],[146.972589,-36.082113],[146.981298,-36.094876],[147.007444,-36.083732],[147.006396,-36.089115],[147.016319,-36.089798],[147.013473,-36.104721],[147.022777,-36.099895],[147.034141,-36.115239],[147.042344,-36.104305],[147.052963,-36.107881],[147.061812,-36.066155],[147.090400,-36.049226],[147.095444,-36.052710],[147.091582,-36.043861],[147.097003,-36.046784],[147.103712,-36.032854],[147.092140,-36.027650],[147.099095,-36.026194],[147.097671,-36.015823],[147.106364,-36.016455],[147.098074,-36.010246],[147.109228,-36.012549],[147.106820,-36.004825],[147.116280,-36.007635],[147.111931,-36.000922],[147.123357,-35.994498],[147.127391,-36.018047],[147.144361,-36.037765],[147.164456,-36.030798],[147.206299,-36.050136],[147.242378,-36.038482],[147.285177,-36.039439],[147.319949,-36.060987],[147.352825,-36.031749],[147.345681,-36.018772],[147.355287,-36.009832],[147.358193,-35.991276],[147.383679,-35.972352],[147.392344,-35.973533],[147.390342,-35.949266],[147.404631,-35.943495],[147.450685,-35.960804],[147.464072,-35.944137],[147.478835,-35.942689],[147.481553,-35.949223],[147.494112,-35.943549],[147.511421,-35.962412],[147.525267,-35.963338],[147.514925,-35.976369],[147.521359,-35.986936],[147.551873,-36.004095],[147.584027,-35.984648],[147.558887,-35.972489],[147.547654,-35.978625],[147.549115,-35.964550],[147.591893,-35.969859],[147.601438,-35.979118],[147.637771,-35.962110],[147.646777,-35.946008],[147.680010,-35.944439],[147.708415,-35.928545],[147.718672,-35.945513],[147.741292,-35.956490],[147.773261,-35.958863],[147.766797,-35.964158],[147.776849,-35.968614],[147.806153,-35.965057],[147.817498,-35.979741],[147.873121,-35.991006],[147.882880,-36.001798],[147.897506,-35.999861],[147.895698,-35.993018],[147.912342,-35.995198],[147.908543,-36.001473],[147.917083,-36.011204],[147.911490,-36.026597],[147.931559,-36.035267],[147.923752,-36.035709],[147.923974,-36.042491],[147.934261,-36.047637],[147.958994,-36.040974],[147.964964,-36.046853],[147.974260,-36.038505],[147.973234,-36.046314],[147.981774,-36.040254],[147.991260,-36.052559],[147.999692,-36.046204],[147.989467,-36.068478],[147.992889,-36.081071],[147.982389,-36.077891],[147.980247,-36.086482],[147.999218,-36.098655],[147.991074,-36.111251],[147.998229,-36.115919],[147.990652,-36.121272],[148.000537,-36.124355],[148.002388,-36.140057],[148.037726,-36.140797],[148.035191,-36.152536],[148.022899,-36.153457],[148.034795,-36.162983],[148.021819,-36.176462],[148.040620,-36.206951],[148.026096,-36.223042],[148.034900,-36.234116],[148.028840,-36.247044],[148.038676,-36.259221],[148.032828,-36.265860],[148.033753,-36.282230],[148.040119,-36.284157],[148.035234,-36.292329],[148.043928,-36.299479],[148.035011,-36.310577],[148.058941,-36.320046],[148.051243,-36.324557],[148.055613,-36.334386],[148.048959,-36.355632],[148.037836,-36.366246],[148.045966,-36.367038],[148.037583,-36.390225],[148.058163,-36.400804],[148.059945,-36.415538],[148.080280,-36.422101],[148.087601,-36.451895],[148.124663,-36.464713],[148.119093,-36.481884],[148.126424,-36.485274],[148.117630,-36.495476],[148.139815,-36.525445],[148.124337,-36.550642],[148.133410,-36.566921],[148.150489,-36.558336],[148.160713,-36.579776],[148.169411,-36.573696],[148.190134,-36.576620],[148.190330,-36.584891],[148.205990,-36.586932],[148.217563,-36.598239],[148.202781,-36.611915],[148.214196,-36.610490],[148.219547,-36.619558],[148.211171,-36.650519],[148.170243,-36.712799],[148.130703,-36.734683],[148.136703,-36.738436],[148.132654,-36.750847],[148.120472,-36.756303],[148.126081,-36.759417],[148.097983,-36.787161],[148.108888,-36.800865],[148.120152,-36.806079],[148.126771,-36.796451],[148.156663,-36.790013],[148.179595,-36.796326],[148.182473,-36.804895],[148.194946,-36.796253],[149.976679,-37.505060],[149.964395,-37.517956],[149.924770,-37.526348],[149.906609,-37.542865],[149.819715,-37.544829],[149.775248,-37.557838],[149.760994,-37.566909],[149.765416,-37.573855],[149.738748,-37.585037],[149.706531,-37.643525],[149.682392,-37.664158],[149.677329,-37.685082],[149.616596,-37.700613],[149.600828,-37.712062],[149.595839,-37.726576],[149.566290,-37.724577],[149.525501,-37.737284],[149.516419,-37.749082],[149.496934,-37.753367],[149.495556,-37.768225],[149.484958,-37.775441],[149.461888,-37.769302],[149.431022,-37.777377],[149.340379,-37.776913],[149.292448,-37.787460],[149.275498,-37.803777],[149.265391,-37.798457],[149.265928,-37.789319],[149.246711,-37.780474],[149.124226,-37.777287],[148.926358,-37.781403],[148.884150,-37.789958],[148.808733,-37.786417],[148.749187,-37.797037],[148.727786,-37.815437],[148.717029,-37.804438],[148.691027,-37.801441],[148.626577,-37.808219],[148.448176,-37.801720],[148.289615,-37.810988],[148.179178,-37.831635],[147.951982,-37.894066],[147.788216,-37.955322],[147.642131,-38.036875],[147.476303,-38.151750],[147.067248,-38.475119],[146.883139,-38.634634],[146.887146,-38.620153],[146.925517,-38.594225],[146.898674,-38.612218],[146.886424,-38.614398],[146.882549,-38.604607],[146.844005,-38.604835],[146.842214,-38.615343],[146.851407,-38.612415],[146.880623,-38.616834],[146.878210,-38.626484],[146.815353,-38.648874],[146.793687,-38.644809],[146.791507,-38.633329],[146.785908,-38.646241],[146.766508,-38.650138],[146.776554,-38.654217],[146.753518,-38.652583],[146.742174,-38.664925],[146.712913,-38.647777],[146.716388,-38.660899],[146.696106,-38.669995],[146.697708,-38.675350],[146.657551,-38.671491],[146.670659,-38.662910],[146.653120,-38.642985],[146.645934,-38.650711],[146.652795,-38.658737],[146.641029,-38.668902],[146.584420,-38.677087],[146.593670,-38.684768],[146.582693,-38.698475],[146.580423,-38.679462],[146.576824,-38.692143],[146.572005,-38.677700],[146.572140,-38.683307],[146.562535,-38.678240],[146.546510,-38.684520],[146.563125,-38.683180],[146.566746,-38.691119],[146.562451,-38.698048],[146.552764,-38.689290],[146.551209,-38.703789],[146.539161,-38.698269],[146.541200,-38.685376],[146.514712,-38.694242],[146.494669,-38.679739],[146.492968,-38.696760],[146.463062,-38.702080],[146.437202,-38.694436],[146.439100,-38.699711],[146.410331,-38.711911],[146.411203,-38.721218],[146.387054,-38.720748],[146.380986,-38.685645],[146.350706,-38.672920],[146.331821,-38.681068],[146.338840,-38.690666],[146.291719,-38.695268],[146.260560,-38.687323],[146.252627,-38.697512],[146.243754,-38.695281],[146.243941,-38.682832],[146.227605,-38.689144],[146.231156,-38.695179],[146.212059,-38.692854],[146.229248,-38.701188],[146.202718,-38.713350],[146.213181,-38.719708],[146.199527,-38.716096],[146.192048,-38.726245],[146.200636,-38.733016],[146.210668,-38.728486],[146.204663,-38.735404],[146.210699,-38.737946],[146.195376,-38.735871],[146.192597,-38.728737],[146.185560,-38.743370],[146.218497,-38.771826],[146.233048,-38.809044],[146.272814,-38.806048],[146.263936,-38.823443],[146.270271,-38.860140],[146.292728,-38.876466],[146.287195,-38.894454],[146.292616,-38.904551],[146.323098,-38.903579],[146.352575,-38.868224],[146.393215,-38.850494],[146.414861,-38.852078],[146.420730,-38.803807],[146.435645,-38.795912],[146.437960,-38.778922],[146.467056,-38.780916],[146.478636,-38.791780],[146.467850,-38.871049],[146.484472,-38.883179],[146.480599,-38.891390],[146.487410,-38.894269],[146.489295,-38.910464],[146.474089,-38.916245],[146.450981,-38.947851],[146.436110,-38.981022],[146.445691,-39.003708],[146.431755,-39.010977],[146.437194,-39.021014],[146.475392,-39.025666],[146.464000,-39.028932],[146.470757,-39.035718],[146.460439,-39.036915],[146.477728,-39.043765],[146.474460,-39.054940],[146.483350,-39.061028],[146.479770,-39.066834],[146.455289,-39.054116],[146.431120,-39.065527],[146.425291,-39.083549],[146.441603,-39.089754],[146.434851,-39.107727],[146.426860,-39.108278],[146.431753,-39.114822],[146.424079,-39.114799],[146.426510,-39.129986],[146.416015,-39.125521],[146.389544,-39.133959],[146.387825,-39.125091],[146.374563,-39.136721],[146.345818,-39.125384],[146.342561,-39.110600],[146.321444,-39.087887],[146.321430,-39.077981],[146.340665,-39.076953],[146.342982,-39.060987],[146.352339,-39.058857],[146.316942,-39.052255],[146.326362,-39.041118],[146.316484,-39.033666],[146.304711,-39.039363],[146.303027,-39.023470],[146.283915,-39.024887],[146.291848,-39.013118],[146.274329,-38.996389],[146.248966,-38.996020],[146.267295,-38.991191],[146.269497,-38.972960],[146.233903,-38.918669],[146.189408,-38.873545],[146.133534,-38.837409],[146.083966,-38.815933],[146.033608,-38.813189],[146.009458,-38.825703],[145.997901,-38.846406],[146.006286,-38.877920],[145.979368,-38.895077],[145.940007,-38.896113],[145.921197,-38.909610],[145.910638,-38.892758],[145.914922,-38.872133],[145.869527,-38.776148],[145.818249,-38.712973],[145.765547,-38.666752],[145.729472,-38.644840],[145.714004,-38.645141],[145.688938,-38.651209],[145.672021,-38.671595],[145.656874,-38.676923],[145.638566,-38.672436],[145.606696,-38.678782],[145.560625,-38.651407],[145.537514,-38.611090],[145.483686,-38.556001],[145.423688,-38.536479],[145.372012,-38.536297],[145.363420,-38.520970],[145.419170,-38.513190],[145.434480,-38.493623],[145.432528,-38.480368],[145.417718,-38.471373],[145.428272,-38.460830],[145.433813,-38.434868],[145.416381,-38.406995],[145.453556,-38.412660],[145.481275,-38.407126],[145.489876,-38.415096],[145.515409,-38.415475],[145.548933,-38.371688],[145.552463,-38.352450],[145.545145,-38.339536],[145.515332,-38.337800],[145.522134,-38.298944],[145.497964,-38.274077],[145.488988,-38.233414],[145.459991,-38.228038],[145.438385,-38.214401],[145.410917,-38.228048],[145.347072,-38.213570],[145.341337,-38.229565],[145.324841,-38.242155],[145.298309,-38.248493],[145.274132,-38.244101],[145.278629,-38.234400],[145.271575,-38.222965],[145.254773,-38.223062],[145.253302,-38.235679],[145.261731,-38.242426],[145.225654,-38.272428],[145.223020,-38.306462],[145.206203,-38.303800],[145.199986,-38.293078],[145.192934,-38.296557],[145.199945,-38.310851],[145.192849,-38.324507],[145.218781,-38.347604],[145.213463,-38.365909],[145.221952,-38.377797],[145.210923,-38.378673],[145.196407,-38.366586],[145.183986,-38.374587],[145.215199,-38.383113],[145.234486,-38.409689],[145.131889,-38.390694]],[[146.840680,-38.615832],[146.825352,-38.609723],[146.798097,-38.620209],[146.799439,-38.628656],[146.794402,-38.626652],[146.791910,-38.632399],[146.800977,-38.632991],[146.803176,-38.620368],[146.819121,-38.613196],[146.825275,-38.620739],[146.840680,-38.615832]]],[[[149.918469,-37.568333],[149.906303,-37.567536],[149.904809,-37.548305],[149.918469,-37.568333]]],[[[146.879039,-38.638149],[146.828437,-38.679496],[146.858094,-38.652723],[146.835528,-38.654171],[146.879039,-38.638149]]],[[[146.826421,-38.683449],[146.787947,-38.680680],[146.752869,-38.689586],[146.798672,-38.675767],[146.826421,-38.683449]]],[[[146.815451,-38.659376],[146.786029,-38.669118],[146.794058,-38.656820],[146.815451,-38.659376]]],[[[146.739461,-38.672911],[146.726511,-38.672302],[146.715490,-38.683892],[146.709894,-38.676575],[146.720620,-38.676460],[146.727793,-38.661227],[146.739461,-38.672911]]],[[[146.715739,-38.687077],[146.696231,-38.690865],[146.707733,-38.676730],[146.715739,-38.687077]]],[[[146.685401,-38.677859],[146.676565,-38.684137],[146.683364,-38.689702],[146.668862,-38.684012],[146.685401,-38.677859]]],[[[146.677547,-38.708481],[146.626289,-38.724626],[146.601830,-38.722403],[146.606399,-38.717974],[146.601021,-38.716540],[146.595562,-38.720188],[146.602819,-38.726884],[146.585294,-38.715426],[146.618435,-38.697518],[146.614453,-38.701181],[146.636787,-38.698702],[146.630293,-38.705779],[146.642945,-38.699638],[146.677547,-38.708481]]],[[[146.669254,-38.718406],[146.652636,-38.727206],[146.629740,-38.724665],[146.669254,-38.718406]]],[[[146.620487,-38.757880],[146.597634,-38.759484],[146.545340,-38.790889],[146.494759,-38.774837],[146.464605,-38.739122],[146.471343,-38.728367],[146.495000,-38.729122],[146.509663,-38.718527],[146.503076,-38.726791],[146.515585,-38.730698],[146.508177,-38.737230],[146.541851,-38.728365],[146.508245,-38.752904],[146.523886,-38.752655],[146.500179,-38.762913],[146.547905,-38.757144],[146.541720,-38.756131],[146.576886,-38.735022],[146.591910,-38.742404],[146.584271,-38.747864],[146.602930,-38.744193],[146.601349,-38.752087],[146.620487,-38.757880]]],[[[146.623101,-38.757696],[146.667725,-38.747737],[146.656002,-38.755387],[146.623101,-38.757696]]],[[[146.634077,-38.697163],[146.621698,-38.694456],[146.626852,-38.690059],[146.634077,-38.697163]]],[[[146.501883,-38.716446],[146.493338,-38.725194],[146.468395,-38.717321],[146.438615,-38.727515],[146.451102,-38.710531],[146.501883,-38.716446]]],[[[146.329832,-39.141577],[146.325447,-39.147280],[146.312072,-39.134765],[146.329832,-39.141577]]],[[[146.246238,-39.024357],[146.240787,-39.029639],[146.236406,-39.022245],[146.241110,-39.016688],[146.246238,-39.024357]]],[[[146.241476,-39.089053],[146.235550,-39.097594],[146.222171,-39.071320],[146.241476,-39.089053]]],[[[145.503419,-38.354364],[145.476252,-38.366455],[145.406087,-38.372763],[145.390367,-38.385129],[145.386038,-38.406628],[145.363825,-38.405562],[145.352532,-38.419991],[145.287996,-38.395663],[145.275541,-38.394869],[145.281426,-38.404317],[145.272813,-38.409592],[145.265575,-38.402882],[145.276670,-38.391631],[145.273510,-38.357488],[145.287229,-38.309622],[145.297586,-38.309340],[145.285955,-38.305325],[145.289378,-38.284665],[145.297026,-38.282054],[145.330360,-38.292367],[145.351993,-38.311261],[145.452370,-38.306856],[145.503419,-38.354364]]],[[[145.364351,-38.553403],[145.360927,-38.566071],[145.351273,-38.567099],[145.342160,-38.559018],[145.344009,-38.549380],[145.316751,-38.524459],[145.271133,-38.504866],[145.240044,-38.506828],[145.221203,-38.529953],[145.203572,-38.517309],[145.170660,-38.509575],[145.116156,-38.518351],[145.127384,-38.505541],[145.147128,-38.503198],[145.165431,-38.465358],[145.200057,-38.451025],[145.290603,-38.450182],[145.302496,-38.453855],[145.275161,-38.454122],[145.273250,-38.460288],[145.310365,-38.460544],[145.290741,-38.480490],[145.293145,-38.488543],[145.305573,-38.485438],[145.297319,-38.506446],[145.359160,-38.509312],[145.363649,-38.515623],[145.347089,-38.520963],[145.340937,-38.535771],[145.364351,-38.553403]]],[[[145.346151,-38.508609],[145.332958,-38.499493],[145.336761,-38.493663],[145.346151,-38.508609]]],[[[144.702137,-38.243412],[144.667849,-38.255016],[144.672019,-38.264367],[144.663095,-38.252993],[144.678720,-38.237599],[144.678828,-38.250631],[144.702137,-38.243412]]],[[[142.014239,-38.412576],[141.999012,-38.425446],[141.993481,-38.417372],[142.014239,-38.412576]]] ] } }
            ]},
            path:   index$2().projection(
                        mercator()
                        .scale(2100)
                        .center([158.2, -41.5])
                    )
        },
        "National": {
            shape:  {
                "type":"FeatureCollection",
                "features":[
                    {
                        "type":"Feature",
                        "geometry":{
                            "type":"MultiPolygon",
                            "coordinates":[[[[145.39797814349484,-40.79254851660589],[146.36412072162372,-41.13769540788334],[146.90858361225085,-41.00054615658068],[147.68925947488415,-40.80825815202269],[148.28906782449602,-40.87543751400213],[148.35986453673584,-42.06244516374644],[148.0173014670731,-42.407023614268624],[147.9140519553538,-43.211522312188485],[147.564564243764,-42.93768889747386],[146.87034305235494,-43.634597263362096],[146.66332726459368,-43.58085377377856],[146.04837772032042,-43.54974456153889],[145.43192955951056,-42.69377613705627],[145.2950903668017,-42.03360971452756],[144.71807132383063,-41.162551771815714],[144.74375451067968,-40.70397511165771],[145.39797814349484,-40.79254851660589]]],[[[143.56181115129996,-13.763655694232213],[143.92209923723894,-14.548310642152003],[144.56371382057486,-14.171176039285882],[144.89490807513354,-14.594457696188625],[145.37472374896348,-14.984976495018286],[145.27199100156727,-15.428205254785695],[145.48525963763578,-16.285672295804773],[145.63703331927695,-16.784918308176614],[145.88890425026767,-16.90692636481765],[146.1603088726645,-17.761654554925244],[146.0636739442787,-18.28007252367732],[146.3874784690196,-18.95827402107591],[147.47108157774792,-19.48072275154668],[148.1776017600425,-19.95593922290277],[148.84841352762322,-20.39120981209726],[148.7174654481956,-20.633468926681516],[149.28942020080206,-21.260510756111103],[149.67833703023067,-22.342511895438392],[150.07738244038862,-22.12278370533332],[150.48293908101516,-22.556142266533012],[150.72726525289121,-22.40240488046466],[150.89955447815228,-23.462236830338682],[151.60917524638424,-24.076256198830762],[152.07353966695908,-24.457886651306197],[152.85519738180594,-25.267501316023015],[153.13616214417678,-26.07117319102619],[153.16194868389042,-26.641319268502443],[153.0929089703486,-27.26029957449451],[153.5694690289442,-28.1100668271021],[153.51210818910022,-28.995077406532758],[153.33909549378706,-29.458201592732447],[153.06924116435889,-30.350240166954816],[153.0896016786818,-30.923641859665448],[152.8915775901394,-31.640445651985956],[152.45000247620536,-32.550002536755244],[151.70911746643682,-33.041342054986345],[151.34397179586242,-33.81602345147385],[151.01055545471516,-34.310360202777886],[150.71413943908905,-35.17345997491681],[150.32821984273326,-35.67187916437193],[150.07521203023228,-36.42020558039051],[149.94612430236717,-37.10905242284123],[149.99728397033616,-37.42526051203514],[149.42388227762555,-37.77268116633346],[148.30462243061592,-37.80906137466688],[147.3817330263153,-38.21921721776755],[146.92212283751135,-38.60653207779512],[146.3179219911548,-39.03575652441144],[145.48965213438058,-38.59376799901905],[144.87697635312816,-38.41744801203912],[145.03221235573298,-37.896187839510986],[144.48568240781404,-38.08532358169927],[143.6099735861961,-38.80946542740533],[142.745426873953,-38.538267510737526],[142.178329705982,-38.38003427505984],[141.6065816591047,-38.30851409276788],[140.63857872941324,-38.019332777662555],[139.99215823787435,-37.40293629328511],[139.80658816951407,-36.64360279718828],[139.57414757706525,-36.13836231867067],[139.0828080588341,-35.73275400161178],[138.12074791885632,-35.612296237939404],[138.44946170466503,-35.127261244447894],[138.2075643251067,-34.38472258884593],[137.71917036351616,-35.07682504653103],[136.82940555231474,-35.26053476332862],[137.3523710471085,-34.70733855564409],[137.50388634658836,-34.130267836240776],[137.89011600153768,-33.640478610978334],[137.81032759007914,-32.90000701266811],[136.99683719294038,-33.752771498348636],[136.37206912653167,-34.09476612725619],[135.98904341038437,-34.89011809666049],[135.20821251845413,-34.47867034275261],[135.23921837782916,-33.94795338311498],[134.6134167827746,-33.22277800876314],[134.08590376193914,-32.848072198214766],[134.27390262261704,-32.61723357516696],[132.99077680880984,-32.011224053680195],[132.2880806825049,-31.98264698662277],[131.32633060112093,-31.495803318001048],[129.5357938986397,-31.590422865527483],[128.24093753470223,-31.948488864877856],[127.10286746633831,-32.28226694105105],[126.14871382050116,-32.21596607842061],[125.08862348846561,-32.728751316052836],[124.22164798390494,-32.95948658623607],[124.02894656788854,-33.483847344701715],[123.65966678273072,-33.89017913181273],[122.81103641163364,-33.91446705498984],[122.18306440642286,-34.003402194964224],[121.2991907085026,-33.82103606540613],[120.58026818245814,-33.930176690406626],[119.89369510302824,-33.976065362281815],[119.2988993673488,-34.50936614353397],[119.007340936358,-34.464149265278536],[118.5057178081008,-34.7468193499151],[118.02497195848953,-35.064732761374714],[117.29550744025747,-35.02545867283287],[116.62510908413495,-35.02509693780683],[115.56434695847972,-34.386427911111554],[115.02680870977954,-34.196517022438925],[115.04861616420679,-33.62342538832203],[115.5451233256671,-33.48725798923296],[115.71467370001668,-33.25957162855495],[115.6793786967614,-32.90036874769413],[115.80164513556397,-32.20506235120703],[115.68961063035513,-31.61243702568379],[115.16090905157697,-30.60159433362246],[114.99704308477945,-30.030724786094165],[115.04003787644628,-29.461095472940798],[114.64197431850201,-28.810230808224713],[114.61649783738217,-28.516398614213042],[114.17357913620847,-28.11807667410733],[114.04888390508816,-27.334765313427127],[113.4774975932369,-26.543134047147902],[113.3389530782625,-26.116545098578484],[113.77835778204026,-26.54902516042918],[113.44096235560662,-25.621278171493156],[113.93690107631167,-25.911234633082884],[114.23285200404732,-26.298446140245872],[114.21616051641703,-25.786281019801105],[113.72125532435771,-24.998938897402127],[113.62534386602405,-24.683971042583153],[113.39352339076267,-24.38476449961327],[113.50204389857564,-23.806350192970257],[113.70699262904517,-23.560215345964068],[113.8434184102957,-23.059987481378737],[113.7365515483161,-22.47547535572538],[114.1497563009219,-21.755881036061012],[114.22530724493268,-22.517488295178634],[114.64776207891869,-21.829519952076904],[115.46016727097933,-21.495173435148544],[115.94737267462702,-21.06868783944371],[116.71161543179156,-20.70168181730682],[117.16631635952771,-20.623598728113805],[117.44154503791427,-20.746898695562162],[118.22955895393298,-20.374208265873236],[118.83608523974273,-20.26331064217483],[118.98780724495177,-20.044202569257322],[119.25249393115065,-19.95294198982984],[119.80522505094457,-19.976506442954985],[120.85622033089666,-19.68370777758919],[121.39985639860723,-19.239755547769732],[121.65513797412909,-18.705317885007133],[122.24166548064177,-18.19764861417177],[122.28662397673567,-17.798603204013915],[122.31277225147544,-17.25496713630345],[123.01257449757193,-16.405199883695857],[123.43378909718304,-17.268558037996225],[123.85934451710662,-17.069035332917252],[123.50324222218326,-16.596506036040367],[123.81707319549193,-16.111316013251994],[124.25828657439988,-16.327943617419564],[124.37972619028582,-15.567059828353976],[124.92615278534005,-15.075100192935324],[125.16727501841389,-14.680395603090004],[125.67008670461385,-14.510070082256021],[125.6857963400305,-14.230655612853838],[126.12514936737611,-14.347340996968953],[126.14282270721989,-14.095986830301213],[126.58258914602376,-13.95279143642041],[127.06586714081735,-13.817967624570926],[127.80463341686195,-14.276906019755046],[128.35968997610897,-14.869169610252257],[128.98554324759593,-14.875990899314742],[129.62147342337963,-14.969783623924556],[129.409600050983,-14.420669854391035],[129.88864057832862,-13.618703301653483],[130.33946577364296,-13.357375583553477],[130.183506300986,-13.107520033422304],[130.617795037967,-12.536392103732467],[131.22349450086003,-12.183648776908115],[131.73509118054952,-12.302452894747162],[132.57529829318312,-12.114040622611014],[132.55721154188106,-11.603012383676685],[131.82469811414367,-11.273781833545101],[132.35722374891142,-11.128519382372644],[133.01956058159644,-11.376411228076847],[133.55084598198906,-11.786515394745138],[134.393068475482,-12.042365411022175],[134.67863244032705,-11.9411829565947],[135.29849124566803,-12.248606052299051],[135.88269331272764,-11.962266940969798],[136.25838097548947,-12.04934172938161],[136.49247521377166,-11.857208754120393],[136.95162031468502,-12.351958916882737],[136.68512495335577,-12.887223402562057],[136.30540652887512,-13.291229750219898],[135.96175825413414,-13.324509372615893],[136.07761681533256,-13.724278252825783],[135.78383629775325,-14.223989353088214],[135.42866417861123,-14.7154322241839],[135.50018436090318,-14.99774057379443],[136.29517459528137,-15.550264987859123],[137.0653601421595,-15.870762220933356],[137.58047081924482,-16.215082289294084],[138.303217401279,-16.807604261952658],[138.5851640158634,-16.806622409739177],[139.1085429221155,-17.06267913174537],[139.26057498591823,-17.371600843986187],[140.2152453960783,-17.710804945550066],[140.87546349503927,-17.369068698803943],[141.0711104676963,-16.832047214426723],[141.27409549373883,-16.388870131091608],[141.3982222841038,-15.840531508042588],[141.70218305884467,-15.04492115647693],[141.5633801617087,-14.56133310308951],[141.63552046118812,-14.270394789286284],[141.51986860571898,-13.698078301653808],[141.650920038011,-12.944687595270565],[141.84269127824624,-12.74154753993119],[141.6869901877508,-12.407614434461138],[141.92862918514757,-11.87746591557878],[142.118488397388,-11.32804208745162],[142.14370649634637,-11.042736504768143],[142.51526004452498,-10.668185723516643],[142.79731001197408,-11.157354831591519],[142.8667631369743,-11.784706719614931],[143.1159468934857,-11.905629571177911],[143.1586316265588,-12.325655612846191],[143.5221236512999,-12.834358412327433],[143.5971578309877,-13.400422051652598],[143.56181115129996,-13.763655694232213]]]]
                        }
                    }
                ]
            },
            path:   index$2().projection(
                        mercator()
                        .scale(480)
                        .center([190, -52])
                    )
        },
        "central-highlands": {
            shape: {"type":"GeometryCollection", "geometries": [
                {"type":"Polygon","coordinates":[[[143.85745865,-38.13341298],[143.90068659,-38.13854206],[143.90715819,-38.10499419],[143.98698407,-38.12948468],[144.04433481,-38.11236863],[144.08887377,-38.10964853],[144.10457503,-38.12436514],[144.15359353,-38.12154741],[144.19716848,-38.14657382],[144.26237553,-38.14126927],[144.26814996,-38.09283257],[144.28594903,-38.07796636],[144.26270956,-38.05534987],[144.24073975,-38.00806035],[144.24736079,-37.98693605],[144.2367956,-37.94258251],[144.20261462,-37.93840417],[144.21346383,-37.90142317],[144.24412604,-37.87181883],[144.23253602,-37.86189861],[144.22236747,-37.81018888],[144.29601586,-37.81956474],[144.29424867,-37.82892806],[144.332293,-37.845918],[144.354999,-37.843017],[144.361678,-37.8108],[144.39912,-37.815232],[144.41601244,-37.80961719],[144.42164576,-37.84621774],[144.44417684,-37.86401471],[144.44897021,-37.83714155],[144.46696278,-37.83919986],[144.47767801,-37.78101273],[144.49058277,-37.705698],[144.51905482,-37.70673372],[144.52323319,-37.60306855],[144.55622531,-37.55890031],[144.45928337,-37.54639696],[144.46978117,-37.50746269],[144.45931484,-37.49710101],[144.46966685,-37.43911998],[144.43321696,-37.45017713],[144.37927806,-37.4387886],[144.38196684,-37.39332726],[144.41381555,-37.39708922],[144.41903119,-37.36050752],[144.39276451,-37.35814901],[144.3949572,-37.33210516],[144.31039968,-37.29278591],[144.34398635,-37.22622579],[144.36137255,-37.20814051],[144.36311641,-37.17961961],[144.37441282,-37.17307285],[144.29217584,-37.16343695],[144.28426566,-37.20793431],[144.18514812,-37.19535732],[144.19041416,-37.16627639],[144.12155626,-37.15875512],[144.07427334,-37.14759587],[144.06412122,-37.20236357],[144.0659366,-37.22499044],[144.03801695,-37.26420116],[144.00005197,-37.25532461],[144.00033961,-37.23999434],[143.95856719,-37.22025247],[143.94906313,-37.19784176],[143.87529175,-37.1863452],[143.86028596,-37.23435324],[143.82019115,-37.2352203],[143.76628409,-37.22823395],[143.72525555,-37.21427837],[143.7143374,-37.22995225],[143.66512868,-37.23665574],[143.63639958,-37.23083363],[143.64063941,-37.20831127],[143.58228413,-37.2017335],[143.58541176,-37.18455312],[143.5509531,-37.18048167],[143.55729381,-37.15607658],[143.58060855,-37.13915711],[143.5780732,-37.11509646],[143.55201412,-37.09415177],[143.56252544,-37.03361737],[143.59467216,-36.98887756],[143.57579468,-36.98152972],[143.57710352,-36.94788167],[143.54245354,-36.94923011],[143.47197581,-36.93682859],[143.40977315,-36.92757995],[143.39460846,-36.93394374],[143.35175161,-36.92367852],[143.34446644,-36.91471559],[143.23928624,-36.90182997],[143.18169999,-36.89766376],[143.12561935,-36.89890443],[143.10698562,-36.90439213],[143.0871258,-36.98945235],[143.09901511,-37.00149915],[143.09267941,-37.04642967],[143.10113878,-37.10125622],[143.08615879,-37.12480316],[143.09553025,-37.15557165],[143.06693856,-37.14736848],[143.05909372,-37.18720115],[142.99354327,-37.18307516],[142.96128225,-37.16703805],[142.95397382,-37.20777862],[142.83969336,-37.19186409],[142.82386256,-37.17187279],[142.78374486,-37.16889858],[142.76878473,-37.14294619],[142.71708261,-37.15740418],[142.54277306,-37.15741808],[142.59524366,-37.21759836],[142.59706298,-37.261976],[142.5814716,-37.27000896],[142.60116341,-37.29289736],[142.51635098,-37.29322678],[142.50048257,-37.3200005],[142.49502639,-37.36498366],[142.47506317,-37.4055441],[142.43390045,-37.44518053],[142.42654184,-37.46810477],[142.38742435,-37.498455],[142.36432633,-37.54432637],[142.36908961,-37.56380265],[142.35493659,-37.58813419],[142.36448394,-37.59888123],[142.58711436,-37.62697331],[142.61877029,-37.64684823],[142.61565931,-37.68937191],[142.60175913,-37.69957337],[142.59016076,-37.76511754],[142.61261295,-37.79164654],[142.61471384,-37.81031767],[142.67323948,-37.81656067],[142.70140116,-37.83477574],[142.75761072,-37.81276252],[142.83968579,-37.82213888],[142.84222316,-37.80786463],[142.87946648,-37.80844486],[142.87527244,-37.83193096],[142.93457591,-37.80285258],[142.95130761,-37.78953078],[143.0072402,-37.76555194],[143.01306451,-37.78690918],[143.03525849,-37.79277531],[143.03137707,-37.81452562],[143.06207616,-37.82491363],[143.07622524,-37.8156589],[143.10582279,-37.83349989],[143.09597209,-37.82162324],[143.12602276,-37.77969672],[143.14901436,-37.76181438],[143.16557172,-37.76319828],[143.18022344,-37.73147066],[143.2496923,-37.74250445],[143.27712543,-37.75610618],[143.3032817,-37.75658114],[143.322408,-37.74363186],[143.32549295,-37.7137833],[143.34191162,-37.70732704],[143.35478358,-37.67027824],[143.44120082,-37.67004793],[143.46474384,-37.65892913],[143.44071182,-37.78484952],[143.44779659,-37.82140028],[143.44055328,-37.85943138],[143.45240611,-37.8732731],[143.44651968,-37.90049992],[143.4808255,-37.93087073],[143.47941062,-37.94085002],[143.61226467,-37.95914055],[143.62965131,-37.98121681],[143.64811979,-37.98824524],[143.65542396,-38.01182007],[143.62891312,-38.0234066],[143.67240892,-38.02940019],[143.7356485,-38.02727565],[143.76555055,-38.01950282],[143.82959486,-38.02234313],[143.81858404,-38.08014935],[143.82186043,-38.10434511],[143.80986489,-38.12769939],[143.85745865,-38.13341298]]]}
            ]},
            path:   index$2().projection(
                        mercator()
                        .scale(5000)
                        .center([148.1, -39.2])
                    )

        }
    };

    /* src/components/byPage/actions/vis/Scale.svelte generated by Svelte v3.48.0 */
    const file$8 = "src/components/byPage/actions/vis/Scale.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (28:16) {:else}
    function create_else_block(ctx) {
    	let html_tag;
    	let raw0_value = ` ${/*obj*/ ctx[2]["Linked adaptation actions"].length} ` + "";
    	let html_anchor;
    	let html_tag_1;
    	let raw1_value = `${/*obj*/ ctx[2].Scale} ` + "";
    	let t;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(true);
    			html_anchor = empty$3();
    			html_tag_1 = new HtmlTag(true);
    			t = text$1(" actions");
    			html_tag.a = html_anchor;
    			html_tag_1.a = t;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw0_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    			html_tag_1.m(raw1_value, target, anchor);
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*scaleData*/ 2 && raw0_value !== (raw0_value = ` ${/*obj*/ ctx[2]["Linked adaptation actions"].length} ` + "")) html_tag.p(raw0_value);
    			if (dirty & /*scaleData*/ 2 && raw1_value !== (raw1_value = `${/*obj*/ ctx[2].Scale} ` + "")) html_tag_1.p(raw1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    			if (detaching) html_tag_1.d();
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(28:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:16) {#if obj["Linked adaptation actions"].length === 1}
    function create_if_block$3(ctx) {
    	let t0;
    	let html_tag;
    	let raw_value = ` ${/*obj*/ ctx[2].Scale} ` + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1("1 ");
    			html_tag = new HtmlTag(true);
    			t1 = text$1(" action");
    			html_tag.a = t1;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*scaleData*/ 2 && raw_value !== (raw_value = ` ${/*obj*/ ctx[2].Scale} ` + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) html_tag.d();
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(26:16) {#if obj[\\\"Linked adaptation actions\\\"].length === 1}",
    		ctx
    	});

    	return block;
    }

    // (19:8) {#each scaleData as obj, i}
    function create_each_block$3(ctx) {
    	let g0;
    	let path;
    	let path_d_value;
    	let g1;
    	let text0;
    	let raw_value = /*obj*/ ctx[2].Alias + "";
    	let text0_class_value;
    	let text1;
    	let text1_class_value;

    	function select_block_type(ctx, dirty) {
    		if (/*obj*/ ctx[2]["Linked adaptation actions"].length === 1) return create_if_block$3;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			g0 = svg_element("g");
    			path = svg_element("path");
    			g1 = svg_element("g");
    			text0 = svg_element("text");
    			text1 = svg_element("text");
    			if_block.c();
    			attr_dev(path, "class", "map-layer svelte-rv79ei");
    			attr_dev(path, "d", path_d_value = mapShapes[/*obj*/ ctx[2].Scale].path(mapShapes[/*obj*/ ctx[2].Scale].shape));
    			add_location(path, file$8, 20, 12, 816);
    			set_style(g0, "transform", "translate(" + /*dims*/ ctx[0].width * 0.25 + "px, " + (/*obj*/ ctx[2].yPos * /*dims*/ ctx[0].height + 30) + "px)");
    			add_location(g0, file$8, 19, 8, 713);
    			attr_dev(text0, "class", text0_class_value = "scale-label " + slugify(/*obj*/ ctx[2].Scale) + " svelte-rv79ei");
    			attr_dev(text0, "x", "0");
    			attr_dev(text0, "dy", "-10");
    			add_location(text0, file$8, 23, 12, 1023);
    			attr_dev(text1, "class", text1_class_value = "action-label " + slugify(/*obj*/ ctx[2].Scale) + " svelte-rv79ei");
    			attr_dev(text1, "x", "0");
    			attr_dev(text1, "dy", "20");
    			add_location(text1, file$8, 24, 12, 1129);
    			set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.25 + "px, " + /*dims*/ ctx[0].height * /*obj*/ ctx[2].yPos + "px)");
    			add_location(g1, file$8, 22, 8, 927);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g0, anchor);
    			append_dev(g0, path);
    			insert_dev(target, g1, anchor);
    			append_dev(g1, text0);
    			text0.innerHTML = raw_value;
    			append_dev(g1, text1);
    			if_block.m(text1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*scaleData*/ 2 && path_d_value !== (path_d_value = mapShapes[/*obj*/ ctx[2].Scale].path(mapShapes[/*obj*/ ctx[2].Scale].shape))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*dims, scaleData*/ 3) {
    				set_style(g0, "transform", "translate(" + /*dims*/ ctx[0].width * 0.25 + "px, " + (/*obj*/ ctx[2].yPos * /*dims*/ ctx[0].height + 30) + "px)");
    			}

    			if (dirty & /*scaleData*/ 2 && raw_value !== (raw_value = /*obj*/ ctx[2].Alias + "")) text0.innerHTML = raw_value;
    			if (dirty & /*scaleData*/ 2 && text0_class_value !== (text0_class_value = "scale-label " + slugify(/*obj*/ ctx[2].Scale) + " svelte-rv79ei")) {
    				attr_dev(text0, "class", text0_class_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(text1, null);
    				}
    			}

    			if (dirty & /*scaleData*/ 2 && text1_class_value !== (text1_class_value = "action-label " + slugify(/*obj*/ ctx[2].Scale) + " svelte-rv79ei")) {
    				attr_dev(text1, "class", text1_class_value);
    			}

    			if (dirty & /*dims, scaleData*/ 3) {
    				set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.25 + "px, " + /*dims*/ ctx[0].height * /*obj*/ ctx[2].yPos + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g0);
    			if (detaching) detach_dev(g1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(19:8) {#each scaleData as obj, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let g1;
    	let t;
    	let g0;
    	let g1_intro;
    	let each_value = /*scaleData*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g1 = svg_element("g");
    			t = text$1(">\n    ");
    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g0, "class", "scale-group svelte-rv79ei");
    			add_location(g0, file$8, 17, 4, 645);
    			attr_dev(g1, "id", "scale-vis-container");
    			add_location(g1, file$8, 15, 0, 516);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g1, anchor);
    			append_dev(g1, t);
    			append_dev(g1, g0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g0, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dims, scaleData, slugify, mapShapes*/ 3) {
    				each_value = /*scaleData*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (!g1_intro) {
    				add_render_callback(() => {
    					g1_intro = create_in_transition(g1, fade, {});
    					g1_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Scale', slots, []);
    	let { dims = {} } = $$props;
    	let { scaleData = [] } = $$props;
    	const writable_props = ['dims', 'scaleData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Scale> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('scaleData' in $$props) $$invalidate(1, scaleData = $$props.scaleData);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		ui,
    		data,
    		mapShapes,
    		slugify,
    		dims,
    		scaleData
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('scaleData' in $$props) $$invalidate(1, scaleData = $$props.scaleData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, scaleData];
    }

    class Scale extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { dims: 0, scaleData: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scale",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get dims() {
    		throw new Error("<Scale>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Scale>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleData() {
    		throw new Error("<Scale>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleData(value) {
    		throw new Error("<Scale>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Approach.svelte generated by Svelte v3.48.0 */
    const file$7 = "src/components/byPage/actions/vis/Approach.svelte";

    function create_fragment$7(ctx) {
    	let g6;
    	let g4;
    	let g1;
    	let path0;
    	let path0_d_value;
    	let text0;
    	let t0;
    	let g0;
    	let g3;
    	let path1;
    	let path1_d_value;
    	let text1;
    	let t1;
    	let g2;
    	let g5;
    	let text2;
    	let tspan0;
    	let html_tag;
    	let raw0_value = /*$data*/ ctx[3].stats.actions.byApproachType["Increase resilience"] + "";
    	let t2;
    	let t3;
    	let tspan1;
    	let t4;
    	let t5;
    	let tspan2;
    	let t6;
    	let t7;
    	let text3;
    	let tspan3;
    	let html_tag_1;
    	let raw1_value = /*$data*/ ctx[3].stats.actions.byApproachType["Reduce risk"] + "";
    	let t8;
    	let t9;
    	let tspan4;
    	let t10;
    	let t11;
    	let tspan5;
    	let t12;
    	let t13;
    	let text4;
    	let tspan6;
    	let html_tag_2;
    	let raw2_value = /*$data*/ ctx[3].stats.actions.byApproachType["Improve risk and resilience"] + "";
    	let t14;
    	let t15;
    	let tspan7;
    	let t16;
    	let t17;
    	let tspan8;
    	let t18;
    	let t19;
    	let text5;
    	let tspan9;
    	let html_tag_3;
    	let raw3_value = /*$data*/ ctx[3].stats.actions.byApproachType["None"] + "";
    	let t20;
    	let t21;
    	let tspan10;
    	let t22;
    	let t23;
    	let tspan11;
    	let t24;
    	let g6_intro;

    	const block = {
    		c: function create() {
    			g6 = svg_element("g");
    			g4 = svg_element("g");
    			g1 = svg_element("g");
    			path0 = svg_element("path");
    			text0 = svg_element("text");
    			t0 = text$1("Reduce risks\n            ");
    			g0 = svg_element("g");
    			g3 = svg_element("g");
    			path1 = svg_element("path");
    			text1 = svg_element("text");
    			t1 = text$1("Increase resilience\n            ");
    			g2 = svg_element("g");
    			g5 = svg_element("g");
    			text2 = svg_element("text");
    			tspan0 = svg_element("tspan");
    			html_tag = new HtmlTag(true);
    			t2 = text$1(" actions that");
    			t3 = space();
    			tspan1 = svg_element("tspan");
    			t4 = text$1("increase");
    			t5 = space();
    			tspan2 = svg_element("tspan");
    			t6 = text$1("resilience");
    			t7 = space();
    			text3 = svg_element("text");
    			tspan3 = svg_element("tspan");
    			html_tag_1 = new HtmlTag(true);
    			t8 = text$1(" actions that");
    			t9 = space();
    			tspan4 = svg_element("tspan");
    			t10 = text$1("reduce");
    			t11 = space();
    			tspan5 = svg_element("tspan");
    			t12 = text$1("risk");
    			t13 = space();
    			text4 = svg_element("text");
    			tspan6 = svg_element("tspan");
    			html_tag_2 = new HtmlTag(true);
    			t14 = text$1(" actions that");
    			t15 = space();
    			tspan7 = svg_element("tspan");
    			t16 = text$1("improve risk");
    			t17 = space();
    			tspan8 = svg_element("tspan");
    			t18 = text$1("and resilience");
    			t19 = space();
    			text5 = svg_element("text");
    			tspan9 = svg_element("tspan");
    			html_tag_3 = new HtmlTag(true);
    			t20 = text$1(" actions that are");
    			t21 = space();
    			tspan10 = svg_element("tspan");
    			t22 = text$1("too indirect to be assigned");
    			t23 = space();
    			tspan11 = svg_element("tspan");
    			t24 = text$1("an adaptation approach");
    			attr_dev(path0, "class", "approach-shape risk svelte-16h0c1o");
    			attr_dev(path0, "d", path0_d_value = triangle$1(/*dims*/ ctx[0].width * 0.333, 'down'));
    			set_style(path0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + /*approachData*/ ctx[1][0].standard.y + "px)");
    			add_location(path0, file$7, 44, 12, 1689);
    			attr_dev(text0, "class", "risk label-main svelte-16h0c1o");
    			set_style(text0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y - /*dims*/ ctx[0].height * 0.175 + 40) + "px)");
    			add_location(text0, file$7, 46, 12, 1893);
    			attr_dev(g0, "class", "risk-label-group risk svelte-16h0c1o");
    			set_style(g0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y - /*dims*/ ctx[0].height * 0.175 + 30) + "px)");
    			add_location(g0, file$7, 49, 12, 2109);
    			attr_dev(g1, "class", "approach-group risk-group svelte-16h0c1o");
    			toggle_class(g1, "reset", /*$ui*/ ctx[2].state.actionVis.scene > 0);
    			add_location(g1, file$7, 43, 8, 1590);
    			attr_dev(path1, "class", "approach-shape resilience svelte-16h0c1o");
    			attr_dev(path1, "d", path1_d_value = triangle$1(/*dims*/ ctx[0].width * 0.333, 'up'));
    			set_style(path1, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + /*approachData*/ ctx[1][1].standard.y + "px)");
    			add_location(path1, file$7, 52, 12, 2397);
    			attr_dev(text1, "class", "resilience label-main svelte-16h0c1o");
    			set_style(text1, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + (/*approachData*/ ctx[1][1].standard.y + /*dims*/ ctx[0].height * 0.175 + 20) + "px)");
    			add_location(text1, file$7, 54, 12, 2602);
    			attr_dev(g2, "class", "resilience-label-group resilience svelte-16h0c1o");
    			set_style(g2, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y + /*dims*/ ctx[0].height * 0.175) + "px)");
    			add_location(g2, file$7, 57, 12, 2831);
    			attr_dev(g3, "class", "approach-group resilience-group svelte-16h0c1o");
    			toggle_class(g3, "reset", /*$ui*/ ctx[2].state.actionVis.scene > 0);
    			add_location(g3, file$7, 51, 8, 2292);
    			attr_dev(g4, "class", "svelte-16h0c1o");
    			toggle_class(g4, "hidden", /*$ui*/ ctx[2].state.actionVis.scene === 2);
    			add_location(g4, file$7, 42, 4, 1529);
    			html_tag.a = t2;
    			attr_dev(tspan0, "class", "label-number svelte-16h0c1o");
    			add_location(tspan0, file$7, 63, 12, 3215);
    			attr_dev(tspan1, "class", "label svelte-16h0c1o");
    			attr_dev(tspan1, "x", "0");
    			attr_dev(tspan1, "dy", "60");
    			add_location(tspan1, file$7, 64, 12, 3346);
    			attr_dev(tspan2, "class", "label svelte-16h0c1o");
    			attr_dev(tspan2, "x", "0");
    			attr_dev(tspan2, "dy", "60");
    			add_location(tspan2, file$7, 65, 12, 3413);
    			set_style(text2, "transform", "translate(" + /*approachData*/ ctx[1][1].wide.x + "px, " + (/*approachData*/ ctx[1][1].wide.y + /*dims*/ ctx[0].height * 0.15) + "px)");
    			attr_dev(text2, "class", "svelte-16h0c1o");
    			add_location(text2, file$7, 62, 8, 3087);
    			html_tag_1.a = t8;
    			attr_dev(tspan3, "class", "label-number svelte-16h0c1o");
    			add_location(tspan3, file$7, 68, 12, 3621);
    			attr_dev(tspan4, "class", "label svelte-16h0c1o");
    			attr_dev(tspan4, "x", "0");
    			attr_dev(tspan4, "dy", "60");
    			add_location(tspan4, file$7, 69, 12, 3744);
    			attr_dev(tspan5, "class", "label svelte-16h0c1o");
    			attr_dev(tspan5, "x", "0");
    			attr_dev(tspan5, "dy", "60");
    			add_location(tspan5, file$7, 70, 12, 3808);
    			set_style(text3, "transform", "translate(" + /*approachData*/ ctx[1][0].wide.x + "px, " + (/*approachData*/ ctx[1][0].wide.y + /*dims*/ ctx[0].height * 0.15) + "px)");
    			attr_dev(text3, "class", "svelte-16h0c1o");
    			add_location(text3, file$7, 67, 8, 3494);
    			html_tag_2.a = t14;
    			attr_dev(tspan6, "class", "label-number svelte-16h0c1o");
    			add_location(tspan6, file$7, 73, 12, 4036);
    			attr_dev(tspan7, "class", "label svelte-16h0c1o");
    			attr_dev(tspan7, "x", "0");
    			attr_dev(tspan7, "dy", "60");
    			add_location(tspan7, file$7, 74, 12, 4175);
    			attr_dev(tspan8, "class", "label svelte-16h0c1o");
    			attr_dev(tspan8, "x", "0");
    			attr_dev(tspan8, "dy", "60");
    			add_location(tspan8, file$7, 75, 12, 4245);
    			set_style(text4, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + ((/*approachData*/ ctx[1][0].wide.y + /*approachData*/ ctx[1][1].wide.y) * 0.5 + /*dims*/ ctx[0].height * 0.15) + "px)");
    			attr_dev(text4, "class", "svelte-16h0c1o");
    			add_location(text4, file$7, 72, 8, 3882);
    			html_tag_3.a = t20;
    			attr_dev(tspan9, "class", "label-number svelte-16h0c1o");
    			add_location(tspan9, file$7, 78, 12, 4455);
    			attr_dev(tspan10, "class", "label-small svelte-16h0c1o");
    			attr_dev(tspan10, "x", "0");
    			attr_dev(tspan10, "dy", "30");
    			add_location(tspan10, file$7, 79, 12, 4575);
    			attr_dev(tspan11, "class", "label-small svelte-16h0c1o");
    			attr_dev(tspan11, "x", "0");
    			attr_dev(tspan11, "dy", "30");
    			add_location(tspan11, file$7, 80, 12, 4667);
    			set_style(text5, "transform", "translate(" + /*approachData*/ ctx[1][2].wide.x + "px, " + (/*approachData*/ ctx[1][2].wide.y + /*dims*/ ctx[0].height * 0.1) + "px)");
    			attr_dev(text5, "class", "svelte-16h0c1o");
    			add_location(text5, file$7, 77, 8, 4329);
    			attr_dev(g5, "class", "svelte-16h0c1o");
    			toggle_class(g5, "hidden", /*$ui*/ ctx[2].state.actionVis.scene !== 2);
    			add_location(g5, file$7, 61, 4, 3026);
    			attr_dev(g6, "id", "approach-vis-container");
    			attr_dev(g6, "class", "svelte-16h0c1o");
    			add_location(g6, file$7, 41, 0, 1484);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g6, anchor);
    			append_dev(g6, g4);
    			append_dev(g4, g1);
    			append_dev(g1, path0);
    			append_dev(g1, text0);
    			append_dev(text0, t0);
    			append_dev(g1, g0);
    			append_dev(g4, g3);
    			append_dev(g3, path1);
    			append_dev(g3, text1);
    			append_dev(text1, t1);
    			append_dev(g3, g2);
    			append_dev(g6, g5);
    			append_dev(g5, text2);
    			append_dev(text2, tspan0);
    			html_tag.m(raw0_value, tspan0);
    			append_dev(tspan0, t2);
    			append_dev(text2, t3);
    			append_dev(text2, tspan1);
    			append_dev(tspan1, t4);
    			append_dev(text2, t5);
    			append_dev(text2, tspan2);
    			append_dev(tspan2, t6);
    			append_dev(text2, t7);
    			append_dev(g5, text3);
    			append_dev(text3, tspan3);
    			html_tag_1.m(raw1_value, tspan3);
    			append_dev(tspan3, t8);
    			append_dev(text3, t9);
    			append_dev(text3, tspan4);
    			append_dev(tspan4, t10);
    			append_dev(text3, t11);
    			append_dev(text3, tspan5);
    			append_dev(tspan5, t12);
    			append_dev(text3, t13);
    			append_dev(g5, text4);
    			append_dev(text4, tspan6);
    			html_tag_2.m(raw2_value, tspan6);
    			append_dev(tspan6, t14);
    			append_dev(text4, t15);
    			append_dev(text4, tspan7);
    			append_dev(tspan7, t16);
    			append_dev(text4, t17);
    			append_dev(text4, tspan8);
    			append_dev(tspan8, t18);
    			append_dev(text4, t19);
    			append_dev(g5, text5);
    			append_dev(text5, tspan9);
    			html_tag_3.m(raw3_value, tspan9);
    			append_dev(tspan9, t20);
    			append_dev(text5, t21);
    			append_dev(text5, tspan10);
    			append_dev(tspan10, t22);
    			append_dev(text5, t23);
    			append_dev(text5, tspan11);
    			append_dev(tspan11, t24);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dims*/ 1 && path0_d_value !== (path0_d_value = triangle$1(/*dims*/ ctx[0].width * 0.333, 'down'))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*approachData*/ 2) {
    				set_style(path0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + /*approachData*/ ctx[1][0].standard.y + "px)");
    			}

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(text0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y - /*dims*/ ctx[0].height * 0.175 + 40) + "px)");
    			}

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(g0, "transform", "translate(" + /*approachData*/ ctx[1][0].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y - /*dims*/ ctx[0].height * 0.175 + 30) + "px)");
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g1, "reset", /*$ui*/ ctx[2].state.actionVis.scene > 0);
    			}

    			if (dirty & /*dims*/ 1 && path1_d_value !== (path1_d_value = triangle$1(/*dims*/ ctx[0].width * 0.333, 'up'))) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*approachData*/ 2) {
    				set_style(path1, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + /*approachData*/ ctx[1][1].standard.y + "px)");
    			}

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(text1, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + (/*approachData*/ ctx[1][1].standard.y + /*dims*/ ctx[0].height * 0.175 + 20) + "px)");
    			}

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(g2, "transform", "translate(" + /*approachData*/ ctx[1][1].standard.x + "px, " + (/*approachData*/ ctx[1][0].standard.y + /*dims*/ ctx[0].height * 0.175) + "px)");
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g3, "reset", /*$ui*/ ctx[2].state.actionVis.scene > 0);
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g4, "hidden", /*$ui*/ ctx[2].state.actionVis.scene === 2);
    			}

    			if (dirty & /*$data*/ 8 && raw0_value !== (raw0_value = /*$data*/ ctx[3].stats.actions.byApproachType["Increase resilience"] + "")) html_tag.p(raw0_value);

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(text2, "transform", "translate(" + /*approachData*/ ctx[1][1].wide.x + "px, " + (/*approachData*/ ctx[1][1].wide.y + /*dims*/ ctx[0].height * 0.15) + "px)");
    			}

    			if (dirty & /*$data*/ 8 && raw1_value !== (raw1_value = /*$data*/ ctx[3].stats.actions.byApproachType["Reduce risk"] + "")) html_tag_1.p(raw1_value);

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(text3, "transform", "translate(" + /*approachData*/ ctx[1][0].wide.x + "px, " + (/*approachData*/ ctx[1][0].wide.y + /*dims*/ ctx[0].height * 0.15) + "px)");
    			}

    			if (dirty & /*$data*/ 8 && raw2_value !== (raw2_value = /*$data*/ ctx[3].stats.actions.byApproachType["Improve risk and resilience"] + "")) html_tag_2.p(raw2_value);

    			if (dirty & /*dims, approachData*/ 3) {
    				set_style(text4, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + ((/*approachData*/ ctx[1][0].wide.y + /*approachData*/ ctx[1][1].wide.y) * 0.5 + /*dims*/ ctx[0].height * 0.15) + "px)");
    			}

    			if (dirty & /*$data*/ 8 && raw3_value !== (raw3_value = /*$data*/ ctx[3].stats.actions.byApproachType["None"] + "")) html_tag_3.p(raw3_value);

    			if (dirty & /*approachData, dims*/ 3) {
    				set_style(text5, "transform", "translate(" + /*approachData*/ ctx[1][2].wide.x + "px, " + (/*approachData*/ ctx[1][2].wide.y + /*dims*/ ctx[0].height * 0.1) + "px)");
    			}

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g5, "hidden", /*$ui*/ ctx[2].state.actionVis.scene !== 2);
    			}
    		},
    		i: function intro(local) {
    			if (!g6_intro) {
    				add_render_callback(() => {
    					g6_intro = create_in_transition(g6, fade, {});
    					g6_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(2, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(3, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Approach', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions
    	let { approachData = [] } = $$props;

    	// Attach the approach ;lables
    	onMount(() => {
    		const reduceRisk = ["Reduce exposure", "Reduce vulnerability", "Transfer risk"];

    		const increaseResilience = [
    			"Prepare, respond and recover",
    			"Increase resilience to changing risks",
    			"Transformation"
    		];

    		const riskGroup = select('.risk-label-group');
    		const resilienceGroup = select('.resilience-label-group');
    		riskGroup.selectAll('.approach-label').data(reduceRisk).join('text').classed('risk approach-label', true).attr('x', 0).attr('y', (d, i) => i * -50 - 80).attr('dy', 0).text(d => d);
    		resilienceGroup.selectAll('.approach-label').classed('resilience approach-label', true).data(increaseResilience).join('text').attr('x', 0).attr('y', (d, i) => i * 50 + 80).attr('dy', 0).text(d => d);
    	});

    	const writable_props = ['dims', 'approachData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Approach> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('approachData' in $$props) $$invalidate(1, approachData = $$props.approachData);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		d3,
    		ui,
    		data,
    		textWrap,
    		slugify,
    		triangle: triangle$1,
    		dims,
    		approachData,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    		if ('approachData' in $$props) $$invalidate(1, approachData = $$props.approachData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, approachData, $ui, $data];
    }

    class Approach extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { dims: 0, approachData: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Approach",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get dims() {
    		throw new Error("<Approach>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Approach>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get approachData() {
    		throw new Error("<Approach>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set approachData(value) {
    		throw new Error("<Approach>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/FocusArea.svelte generated by Svelte v3.48.0 */
    const file$6 = "src/components/byPage/actions/vis/FocusArea.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (61:12) {#each  sortedFocus.sort( (a,b) => a.Alias < b.Alias) as obj, i}
    function create_each_block$2(ctx) {
    	let g;
    	let text0;
    	let raw0_value = /*obj*/ ctx[5]["Alias"] + "";
    	let text1;
    	let html_tag;
    	let raw1_value = /*obj*/ ctx[5]["Linked adaptation actions"].length + "";
    	let t;
    	let path;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			text0 = svg_element("text");
    			text1 = svg_element("text");
    			html_tag = new HtmlTag(true);
    			t = text$1(" actions related to");
    			path = svg_element("path");
    			attr_dev(text0, "class", "focus-area-label svelte-1gdaapf");
    			attr_dev(text0, "name", /*obj*/ ctx[5]["Focus area"]);
    			attr_dev(text0, "index", /*i*/ ctx[7]);
    			add_location(text0, file$6, 62, 16, 2994);
    			html_tag.a = t;
    			attr_dev(text1, "class", "focus-area-action-label " + slugify(/*obj*/ ctx[5]["Focus area"]) + " svelte-1gdaapf");
    			attr_dev(text1, "dy", "-80");
    			add_location(text1, file$6, 65, 16, 3173);
    			attr_dev(path, "class", "icon " + slugify(/*obj*/ ctx[5]["Focus area"]) + " svelte-1gdaapf");
    			attr_dev(path, "d", icons[slugify(/*obj*/ ctx[5]["Alias"])]);
    			set_style(path, "transform", "translate(" + 0 + "px, " + -250 + "px) scale(3)");
    			add_location(path, file$6, 66, 16, 3343);
    			set_style(g, "transform", "translate(" + 0 + "px, " + 100 * (/*i*/ ctx[7] - (/*sortedFocus*/ ctx[1].length - 1) * 0.5) + "px)");
    			add_location(g, file$6, 61, 12, 2886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, text0);
    			text0.innerHTML = raw0_value;
    			append_dev(g, text1);
    			html_tag.m(raw1_value, text1);
    			append_dev(text1, t);
    			append_dev(g, path);

    			if (!mounted) {
    				dispose = listen_dev(text0, "click", /*selectFocus*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(61:12) {#each  sortedFocus.sort( (a,b) => a.Alias < b.Alias) as obj, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let g3;
    	let g1;
    	let g0;
    	let text_1;
    	let t;
    	let g2;
    	let g3_intro;
    	let each_value = /*sortedFocus*/ ctx[1].sort(func);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g3 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			text_1 = svg_element("text");
    			t = text$1("Tap on a focus area to view actions");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			g2 = svg_element("g");
    			attr_dev(text_1, "class", "instruction svelte-1gdaapf");
    			attr_dev(text_1, "y", -100 * /*sortedFocus*/ ctx[1].length * 0.5 - 50);
    			add_location(text_1, file$6, 59, 12, 2678);
    			attr_dev(g0, "class", "selector-wrapper svelte-1gdaapf");
    			add_location(g0, file$6, 58, 8, 2635);
    			attr_dev(g1, "class", "selector-container");
    			set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.25 + "px)");
    			add_location(g1, file$6, 57, 4, 2516);
    			attr_dev(g2, "class", "focus-area-description-container");
    			set_style(g2, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.575 + "px)");
    			add_location(g2, file$6, 71, 4, 3551);
    			attr_dev(g3, "id", "focus-area-vis-container");
    			add_location(g3, file$6, 56, 0, 2465);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g3, anchor);
    			append_dev(g3, g1);
    			append_dev(g1, g0);
    			append_dev(g0, text_1);
    			append_dev(text_1, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g0, null);
    			}

    			append_dev(g3, g2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sortedFocus, slugify, icons, selectFocus*/ 6) {
    				each_value = /*sortedFocus*/ ctx[1].sort(func);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.25 + "px)");
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g2, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.575 + "px)");
    			}
    		},
    		i: function intro(local) {
    			if (!g3_intro) {
    				add_render_callback(() => {
    					g3_intro = create_in_transition(g3, fade, {});
    					g3_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g3);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = (a, b) => a.Alias < b.Alias;

    function instance$6($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(3, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(4, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FocusArea', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions

    	const sortedFocus = $data.schema.adaptationFocus.data.sort((x, y) => {
    		if (x.Alias < y.Alias) {
    			return -1;
    		}

    		if (x.Alias > y.Alias) {
    			return 1;
    		}

    		return 0;
    	});

    	function selectFocus(event) {
    		const focus = this.getAttribute('name') === 'null'
    			? null
    			: this.getAttribute('name'),
    			index = this.getAttribute('index') === 'null'
    			? null
    			: this.getAttribute('index');

    		set_store_value(ui, $ui.state.actionVis.nodes.focusArea = focus, $ui);
    		selectAll('.focus-area-label, .focus-area-action-label, .icon').classed('selected', false);
    		selectAll('.focus-area-label').classed('mute', true);
    		select(this).classed('selected', true).classed('mute', false);
    		selectAll(`.focus-area-action-label.${slugify(focus)}, .icon.${slugify(focus)}`).classed('selected', true);
    		select('.instruction').classed('hidden', true);
    		select('.selector-wrapper').style("transform", `translate(0px, ${100 * ((sortedFocus.length - 1) * 0.5 - index)}px)`);
    		selectAll('.focus-area-description').classed('hidden', true);
    		select(`.focus-area-description.${slugify(focus)}`).classed('hidden', false);
    	}

    	// Add text wrapped lables
    	onMount(() => {
    		const container = select('.focus-area-description-container');
    		container.selectAll('.focus-area-description').data(sortedFocus).join('text').attr('class', d => `${slugify(d["Focus area"])} focus-area-description hidden`).attr('x', 0).attr('y', 0).attr('dy', 0).style('transition', 'all 300ms').style('pointer-events', 'none').style('font-size', 25).style('font-weight', 300).style('fill', 'var(--midGrey)').style('text-anchor', 'middle').text(d => d.Description).call(textWrap, dims.width * 0.667, 1.25, true);
    	});

    	const writable_props = ['dims'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FocusArea> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		d3,
    		schema,
    		ui,
    		data,
    		icons,
    		slugify,
    		textWrap,
    		dims,
    		sortedFocus,
    		selectFocus,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, sortedFocus, selectFocus];
    }

    class FocusArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FocusArea",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get dims() {
    		throw new Error("<FocusArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<FocusArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Screening.svelte generated by Svelte v3.48.0 */
    const file$5 = "src/components/byPage/actions/vis/Screening.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (20:8) {#each $data.schema.adaptationScreens.data as lens, i}
    function create_each_block_1(ctx) {
    	let g;
    	let circle;
    	let g_class_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			circle = svg_element("circle");
    			attr_dev(circle, "r", /*radius*/ ctx[3]);
    			attr_dev(circle, "class", "svelte-1mjtdpn");
    			add_location(circle, file$5, 21, 12, 928);
    			attr_dev(g, "class", g_class_value = "" + (null_to_empty(slugify(/*lens*/ ctx[4].Screen)) + " svelte-1mjtdpn"));
    			set_style(g, "transform", "translate(" + /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos + "px, " + /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos + "px)");
    			add_location(g, file$5, 20, 8, 793);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, circle);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && g_class_value !== (g_class_value = "" + (null_to_empty(slugify(/*lens*/ ctx[4].Screen)) + " svelte-1mjtdpn"))) {
    				attr_dev(g, "class", g_class_value);
    			}

    			if (dirty & /*dims, $data*/ 3) {
    				set_style(g, "transform", "translate(" + /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos + "px, " + /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos + "px)");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(20:8) {#each $data.schema.adaptationScreens.data as lens, i}",
    		ctx
    	});

    	return block;
    }

    // (47:47) 
    function create_if_block_2$2(ctx) {
    	let path0;
    	let path0_id_value;
    	let path0_d_value;
    	let path1;
    	let path1_id_value;
    	let path1_d_value;
    	let text0;
    	let textPath0;
    	let raw0_value = /*lens*/ ctx[4].Description + "";
    	let textPath0_class_value;
    	let textPath0_href_value;
    	let text1;
    	let textPath1;
    	let raw1_value = /*lens*/ ctx[4].Screen + "";
    	let textPath1_class_value;
    	let textPath1_href_value;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			text0 = svg_element("text");
    			textPath0 = svg_element("textPath");
    			text1 = svg_element("text");
    			textPath1 = svg_element("textPath");
    			attr_dev(path0, "id", path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path0, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path0, "d", path0_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 95
    			));

    			add_location(path0, file$5, 47, 16, 2838);
    			attr_dev(path1, "id", path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"));
    			attr_dev(path1, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path1, "d", path1_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 25
    			));

    			add_location(path1, file$5, 48, 16, 3023);
    			attr_dev(textPath0, "class", textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath0, "href", textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath");
    			attr_dev(textPath0, "startOffset", "12.5%");
    			add_location(textPath0, file$5, 50, 20, 3238);
    			add_location(text0, file$5, 49, 16, 3211);
    			attr_dev(textPath1, "class", textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath1, "href", textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath1, "startOffset", "12.5%");
    			add_location(textPath1, file$5, 53, 20, 3473);
    			add_location(text1, file$5, 52, 16, 3446);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			insert_dev(target, text0, anchor);
    			append_dev(text0, textPath0);
    			textPath0.innerHTML = raw0_value;
    			insert_dev(target, text1, anchor);
    			append_dev(text1, textPath1);
    			textPath1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path0_id_value !== (path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path0, "id", path0_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path0_d_value !== (path0_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 95
    			))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*$data*/ 2 && path1_id_value !== (path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"))) {
    				attr_dev(path1, "id", path1_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path1_d_value !== (path1_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 25
    			))) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw0_value !== (raw0_value = /*lens*/ ctx[4].Description + "")) textPath0.innerHTML = raw0_value;
    			if (dirty & /*$data*/ 2 && textPath0_class_value !== (textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath0, "class", textPath0_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath0_href_value !== (textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath")) {
    				attr_dev(textPath0, "href", textPath0_href_value);
    			}

    			if (dirty & /*$data*/ 2 && raw1_value !== (raw1_value = /*lens*/ ctx[4].Screen + "")) textPath1.innerHTML = raw1_value;
    			if (dirty & /*$data*/ 2 && textPath1_class_value !== (textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath1, "class", textPath1_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath1_href_value !== (textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath1, "href", textPath1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    			if (detaching) detach_dev(text0);
    			if (detaching) detach_dev(text1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(47:47) ",
    		ctx
    	});

    	return block;
    }

    // (37:46) 
    function create_if_block_1$2(ctx) {
    	let path0;
    	let path0_id_value;
    	let path0_d_value;
    	let path1;
    	let path1_id_value;
    	let path1_d_value;
    	let text0;
    	let textPath0;
    	let raw0_value = /*lens*/ ctx[4].Description + "";
    	let textPath0_class_value;
    	let textPath0_href_value;
    	let text1;
    	let textPath1;
    	let raw1_value = /*lens*/ ctx[4].Screen + "";
    	let textPath1_class_value;
    	let textPath1_href_value;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			text0 = svg_element("text");
    			textPath0 = svg_element("textPath");
    			text1 = svg_element("text");
    			textPath1 = svg_element("textPath");
    			attr_dev(path0, "id", path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path0, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path0, "d", path0_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 95
    			));

    			add_location(path0, file$5, 37, 16, 1963);
    			attr_dev(path1, "id", path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"));
    			attr_dev(path1, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path1, "d", path1_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 25
    			));

    			add_location(path1, file$5, 38, 16, 2148);
    			attr_dev(textPath0, "class", textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath0, "href", textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath");
    			attr_dev(textPath0, "startOffset", "32.5%");
    			add_location(textPath0, file$5, 40, 20, 2363);
    			add_location(text0, file$5, 39, 16, 2336);
    			attr_dev(textPath1, "class", textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath1, "href", textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath1, "startOffset", "32.5%");
    			add_location(textPath1, file$5, 44, 20, 2599);
    			add_location(text1, file$5, 43, 16, 2572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			insert_dev(target, text0, anchor);
    			append_dev(text0, textPath0);
    			textPath0.innerHTML = raw0_value;
    			insert_dev(target, text1, anchor);
    			append_dev(text1, textPath1);
    			textPath1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path0_id_value !== (path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path0, "id", path0_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path0_d_value !== (path0_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 95
    			))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*$data*/ 2 && path1_id_value !== (path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"))) {
    				attr_dev(path1, "id", path1_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path1_d_value !== (path1_d_value = circleAntiClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 25
    			))) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw0_value !== (raw0_value = /*lens*/ ctx[4].Description + "")) textPath0.innerHTML = raw0_value;
    			if (dirty & /*$data*/ 2 && textPath0_class_value !== (textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath0, "class", textPath0_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath0_href_value !== (textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath")) {
    				attr_dev(textPath0, "href", textPath0_href_value);
    			}

    			if (dirty & /*$data*/ 2 && raw1_value !== (raw1_value = /*lens*/ ctx[4].Screen + "")) textPath1.innerHTML = raw1_value;
    			if (dirty & /*$data*/ 2 && textPath1_class_value !== (textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath1, "class", textPath1_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath1_href_value !== (textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath1, "href", textPath1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    			if (detaching) detach_dev(text0);
    			if (detaching) detach_dev(text1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(37:46) ",
    		ctx
    	});

    	return block;
    }

    // (27:12) {#if lens.lensPos === "top"}
    function create_if_block$2(ctx) {
    	let path0;
    	let path0_id_value;
    	let path0_d_value;
    	let path1;
    	let path1_id_value;
    	let path1_d_value;
    	let text0;
    	let textPath0;
    	let raw0_value = /*lens*/ ctx[4].Description + "";
    	let textPath0_class_value;
    	let textPath0_href_value;
    	let text1;
    	let textPath1;
    	let raw1_value = /*lens*/ ctx[4].Screen + "";
    	let textPath1_class_value;
    	let textPath1_href_value;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			text0 = svg_element("text");
    			textPath0 = svg_element("textPath");
    			text1 = svg_element("text");
    			textPath1 = svg_element("textPath");
    			attr_dev(path0, "id", path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"));
    			attr_dev(path0, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path0, "d", path0_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 45
    			));

    			add_location(path0, file$5, 27, 16, 1101);
    			attr_dev(path1, "id", path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"));
    			attr_dev(path1, "class", "label-path svelte-1mjtdpn");

    			attr_dev(path1, "d", path1_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 15
    			));

    			add_location(path1, file$5, 28, 16, 1282);
    			attr_dev(textPath0, "class", textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath0, "href", textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath");
    			attr_dev(textPath0, "startOffset", "75%");
    			add_location(textPath0, file$5, 30, 20, 1493);
    			add_location(text0, file$5, 29, 16, 1466);
    			attr_dev(textPath1, "class", textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn");
    			attr_dev(textPath1, "href", textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath");
    			attr_dev(textPath1, "startOffset", "75%");
    			add_location(textPath1, file$5, 33, 20, 1726);
    			add_location(text1, file$5, 32, 16, 1699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			insert_dev(target, text0, anchor);
    			append_dev(text0, textPath0);
    			textPath0.innerHTML = raw0_value;
    			insert_dev(target, text1, anchor);
    			append_dev(text1, textPath1);
    			textPath1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$data*/ 2 && path0_id_value !== (path0_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath"))) {
    				attr_dev(path0, "id", path0_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path0_d_value !== (path0_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 45
    			))) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*$data*/ 2 && path1_id_value !== (path1_id_value = "" + (slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath"))) {
    				attr_dev(path1, "id", path1_id_value);
    			}

    			if (dirty & /*dims, $data*/ 3 && path1_d_value !== (path1_d_value = circleClockwise(
    				{
    					x: /*dims*/ ctx[0].width * /*lens*/ ctx[4].xPos,
    					y: /*dims*/ ctx[0].height * /*lens*/ ctx[4].yPos
    				},
    				/*radius*/ ctx[3] + 15
    			))) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*$data*/ 2 && raw0_value !== (raw0_value = /*lens*/ ctx[4].Description + "")) textPath0.innerHTML = raw0_value;
    			if (dirty & /*$data*/ 2 && textPath0_class_value !== (textPath0_class_value = "lens-question-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath0, "class", textPath0_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath0_href_value !== (textPath0_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensQuestionPath")) {
    				attr_dev(textPath0, "href", textPath0_href_value);
    			}

    			if (dirty & /*$data*/ 2 && raw1_value !== (raw1_value = /*lens*/ ctx[4].Screen + "")) textPath1.innerHTML = raw1_value;
    			if (dirty & /*$data*/ 2 && textPath1_class_value !== (textPath1_class_value = "lens-label " + slugify(/*lens*/ ctx[4].Screen) + " svelte-1mjtdpn")) {
    				attr_dev(textPath1, "class", textPath1_class_value);
    			}

    			if (dirty & /*$data*/ 2 && textPath1_href_value !== (textPath1_href_value = "#" + slugify(/*lens*/ ctx[4].Screen) + "-lensLabelPath")) {
    				attr_dev(textPath1, "href", textPath1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    			if (detaching) detach_dev(text0);
    			if (detaching) detach_dev(text1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(27:12) {#if lens.lensPos === \\\"top\\\"}",
    		ctx
    	});

    	return block;
    }

    // (26:8) {#each $data.schema.adaptationScreens.data as lens, i}
    function create_each_block$1(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*lens*/ ctx[4].lensPos === "top") return create_if_block$2;
    		if (/*lens*/ ctx[4].lensPos === "left") return create_if_block_1$2;
    		if (/*lens*/ ctx[4].lensPos === "right") return create_if_block_2$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(26:8) {#each $data.schema.adaptationScreens.data as lens, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let g2;
    	let g1;
    	let each0_anchor;
    	let g0;
    	let path;
    	let text0;
    	let t0;
    	let text1;
    	let t1_value = /*$data*/ ctx[1].stats.actions.noRegrets + "";
    	let t1;
    	let t2;
    	let text2;
    	let t3;
    	let g2_intro;
    	let each_value_1 = /*$data*/ ctx[1].schema.adaptationScreens.data;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = /*$data*/ ctx[1].schema.adaptationScreens.data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g2 = svg_element("g");
    			g1 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			g0 = svg_element("g");
    			path = svg_element("path");
    			text0 = svg_element("text");
    			t0 = text$1("No regrets actions");
    			text1 = svg_element("text");
    			t1 = text$1(t1_value);
    			t2 = text$1(" actions expected to be");
    			text2 = svg_element("text");
    			t3 = text$1("robust, viable and flexible");
    			attr_dev(path, "d", "M0,0 v" + -/*radius*/ ctx[3] * 0.33 + " q" + 0 + ", " + -/*radius*/ ctx[3] * 0.5 + " " + /*radius*/ ctx[3] * 0.5 + ", " + -/*radius*/ ctx[3] * 0.5 + " h" + /*radius*/ ctx[3] * 0.5);
    			attr_dev(path, "class", "svelte-1mjtdpn");
    			add_location(path, file$5, 59, 12, 3783);
    			attr_dev(text0, "class", "no-regrets-label svelte-1mjtdpn");
    			attr_dev(text0, "x", /*radius*/ ctx[3] + 10);
    			attr_dev(text0, "y", -0.833 * /*radius*/ ctx[3]);
    			add_location(text0, file$5, 60, 12, 3902);
    			attr_dev(text1, "class", "no-regrets-number svelte-1mjtdpn");
    			attr_dev(text1, "x", /*radius*/ ctx[3] + 10);
    			attr_dev(text1, "y", -0.833 * /*radius*/ ctx[3] + 35);
    			add_location(text1, file$5, 61, 12, 4014);
    			attr_dev(text2, "class", "no-regrets-number svelte-1mjtdpn");
    			attr_dev(text2, "x", /*radius*/ ctx[3] + 10);
    			attr_dev(text2, "y", -0.833 * /*radius*/ ctx[3] + 65);
    			add_location(text2, file$5, 62, 12, 4167);
    			attr_dev(g0, "class", "no-regrets-group svelte-1mjtdpn");
    			toggle_class(g0, "hidden", /*$ui*/ ctx[2].state.actionVis.scene !== 2);
    			add_location(g0, file$5, 58, 8, 3691);
    			set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.425 + "px)");
    			add_location(g1, file$5, 18, 4, 640);
    			attr_dev(g2, "id", "screening-vis-container");
    			add_location(g2, file$5, 17, 0, 594);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g2, anchor);
    			append_dev(g2, g1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g1, null);
    			}

    			append_dev(g1, each0_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g1, null);
    			}

    			append_dev(g1, g0);
    			append_dev(g0, path);
    			append_dev(g0, text0);
    			append_dev(text0, t0);
    			append_dev(g0, text1);
    			append_dev(text1, t1);
    			append_dev(text1, t2);
    			append_dev(g0, text2);
    			append_dev(text2, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*slugify, $data, dims, radius*/ 11) {
    				each_value_1 = /*$data*/ ctx[1].schema.adaptationScreens.data;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g1, each0_anchor);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*slugify, $data, circleClockwise, dims, radius, circleAntiClockwise*/ 11) {
    				each_value = /*$data*/ ctx[1].schema.adaptationScreens.data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g1, g0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$data*/ 2 && t1_value !== (t1_value = /*$data*/ ctx[1].stats.actions.noRegrets + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$ui*/ 4) {
    				toggle_class(g0, "hidden", /*$ui*/ ctx[2].state.actionVis.scene !== 2);
    			}

    			if (dirty & /*dims*/ 1) {
    				set_style(g1, "transform", "translate(" + /*dims*/ ctx[0].width * 0.5 + "px, " + /*dims*/ ctx[0].height * 0.425 + "px)");
    			}
    		},
    		i: function intro(local) {
    			if (!g2_intro) {
    				add_render_callback(() => {
    					g2_intro = create_in_transition(g2, fade, {});
    					g2_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g2);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $data;
    	let $ui;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(2, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Screening', slots, []);

    	let { dims = {
    		// SVG dimensions
    		width: 1600,
    		height: 1600
    	} } = $$props;

    	const radius = dims.width * 0.25;
    	const writable_props = ['dims'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Screening> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		slugify,
    		schema,
    		circleClockwise,
    		circleAntiClockwise,
    		dims,
    		radius,
    		$data,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(0, dims = $$props.dims);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dims, $data, $ui, radius];
    }

    class Screening extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { dims: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Screening",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get dims() {
    		throw new Error("<Screening>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Screening>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/vis/Rating.svelte generated by Svelte v3.48.0 */
    const file$4 = "src/components/byPage/actions/vis/Rating.svelte";

    function create_fragment$4(ctx) {
    	let g11;
    	let g10;
    	let g3;
    	let g0;
    	let path0;
    	let text0;
    	let raw0_value = /*ratingData*/ ctx[0].noRegrets.name + "";
    	let g1;
    	let path1;
    	let text1;
    	let raw1_value = /*ratingData*/ ctx[0].forRating.name + "";
    	let g2;
    	let path2;
    	let text2;
    	let raw2_value = /*ratingData*/ ctx[0].discard.name + "";
    	let g9;
    	let g4;
    	let path3;
    	let text3;
    	let raw3_value = /*ratingData*/ ctx[0].noRegrets.name + "";
    	let g5;
    	let path4;
    	let text4;
    	let raw4_value = /*ratingData*/ ctx[0].twoCriteria.name + "";
    	let g6;
    	let path5;
    	let text5;
    	let raw5_value = /*ratingData*/ ctx[0].oneCriteria.name + "";
    	let g7;
    	let path6;
    	let text6;
    	let raw6_value = /*ratingData*/ ctx[0].zeroCriteria.name + "";
    	let g8;
    	let path7;
    	let text7;
    	let raw7_value = /*ratingData*/ ctx[0].discard.name + "";
    	let g11_intro;

    	const block = {
    		c: function create() {
    			g11 = svg_element("g");
    			g10 = svg_element("g");
    			g3 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			text0 = svg_element("text");
    			g1 = svg_element("g");
    			path1 = svg_element("path");
    			text1 = svg_element("text");
    			g2 = svg_element("g");
    			path2 = svg_element("path");
    			text2 = svg_element("text");
    			g9 = svg_element("g");
    			g4 = svg_element("g");
    			path3 = svg_element("path");
    			text3 = svg_element("text");
    			g5 = svg_element("g");
    			path4 = svg_element("path");
    			text4 = svg_element("text");
    			g6 = svg_element("g");
    			path5 = svg_element("path");
    			text5 = svg_element("text");
    			g7 = svg_element("g");
    			path6 = svg_element("path");
    			text6 = svg_element("text");
    			g8 = svg_element("g");
    			path7 = svg_element("path");
    			text7 = svg_element("text");
    			attr_dev(path0, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path0, "class", "svelte-1m9jpvu");
    			add_location(path0, file$4, 20, 16, 809);
    			attr_dev(text0, "x", markerWidth + 10);
    			attr_dev(text0, "y", "15");
    			attr_dev(text0, "class", "svelte-1m9jpvu");
    			add_location(text0, file$4, 21, 16, 861);
    			attr_dev(g0, "class", "no-regrets scale-group svelte-1m9jpvu");
    			set_style(g0, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].noRegrets.y + "px)");
    			add_location(g0, file$4, 19, 12, 691);
    			attr_dev(path1, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path1, "class", "svelte-1m9jpvu");
    			add_location(path1, file$4, 24, 16, 1084);
    			attr_dev(text1, "x", markerWidth + 10);
    			attr_dev(text1, "y", "15");
    			attr_dev(text1, "class", "svelte-1m9jpvu");
    			add_location(text1, file$4, 25, 16, 1136);
    			attr_dev(g1, "class", "for-rating scale-group svelte-1m9jpvu");
    			set_style(g1, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].forRating.y + "px)");
    			add_location(g1, file$4, 23, 12, 966);
    			attr_dev(path2, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path2, "class", "svelte-1m9jpvu");
    			add_location(path2, file$4, 28, 16, 1355);
    			attr_dev(text2, "x", markerWidth + 10);
    			attr_dev(text2, "y", "15");
    			attr_dev(text2, "class", "svelte-1m9jpvu");
    			add_location(text2, file$4, 29, 16, 1407);
    			attr_dev(g2, "class", "discard scale-group svelte-1m9jpvu");
    			set_style(g2, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].discard.y + "px)");
    			add_location(g2, file$4, 27, 12, 1242);
    			attr_dev(g3, "class", "svelte-1m9jpvu");
    			toggle_class(g3, "hidden", /*$ui*/ ctx[1].state.actionVis.scene !== 0);
    			add_location(g3, file$4, 18, 8, 627);
    			attr_dev(path3, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path3, "class", "svelte-1m9jpvu");
    			add_location(path3, file$4, 35, 16, 1703);
    			attr_dev(text3, "x", markerWidth + 10);
    			attr_dev(text3, "y", "15");
    			attr_dev(text3, "class", "svelte-1m9jpvu");
    			add_location(text3, file$4, 36, 16, 1755);
    			attr_dev(g4, "class", "no-regrets scale-group svelte-1m9jpvu");
    			set_style(g4, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].noRegrets.y + "px)");
    			add_location(g4, file$4, 34, 12, 1585);
    			attr_dev(path4, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path4, "class", "svelte-1m9jpvu");
    			add_location(path4, file$4, 39, 16, 1983);
    			attr_dev(text4, "x", markerWidth + 10);
    			attr_dev(text4, "y", "15");
    			attr_dev(text4, "class", "svelte-1m9jpvu");
    			add_location(text4, file$4, 40, 16, 2035);
    			attr_dev(g5, "class", "two-criteria scale-group svelte-1m9jpvu");
    			set_style(g5, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].twoCriteria.y + "px)");
    			add_location(g5, file$4, 38, 12, 1861);
    			attr_dev(path5, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path5, "class", "svelte-1m9jpvu");
    			add_location(path5, file$4, 43, 16, 2266);
    			attr_dev(text5, "x", markerWidth + 10);
    			attr_dev(text5, "y", "15");
    			attr_dev(text5, "class", "svelte-1m9jpvu");
    			add_location(text5, file$4, 44, 16, 2318);
    			attr_dev(g6, "class", "one-criteria scale-group svelte-1m9jpvu");
    			set_style(g6, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].oneCriteria.y + "px)");
    			add_location(g6, file$4, 42, 12, 2144);
    			attr_dev(path6, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path6, "class", "svelte-1m9jpvu");
    			add_location(path6, file$4, 47, 16, 2551);
    			attr_dev(text6, "x", markerWidth + 10);
    			attr_dev(text6, "y", "15");
    			attr_dev(text6, "class", "svelte-1m9jpvu");
    			add_location(text6, file$4, 48, 16, 2603);
    			attr_dev(g7, "class", "zero-criteria scale-group svelte-1m9jpvu");
    			set_style(g7, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].zeroCriteria.y + "px)");
    			add_location(g7, file$4, 46, 12, 2427);
    			attr_dev(path7, "d", "M5, 0 h" + markerWidth);
    			attr_dev(path7, "class", "svelte-1m9jpvu");
    			add_location(path7, file$4, 51, 16, 2826);
    			attr_dev(text7, "x", markerWidth + 10);
    			attr_dev(text7, "y", "15");
    			attr_dev(text7, "class", "svelte-1m9jpvu");
    			add_location(text7, file$4, 52, 16, 2878);
    			attr_dev(g8, "class", "exclude scale-group svelte-1m9jpvu");
    			set_style(g8, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].discard.y + "px)");
    			add_location(g8, file$4, 50, 12, 2713);
    			attr_dev(g9, "class", "svelte-1m9jpvu");
    			toggle_class(g9, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 0);
    			add_location(g9, file$4, 33, 8, 1521);
    			attr_dev(g10, "class", "rating-scale-group");
    			add_location(g10, file$4, 17, 4, 586);
    			attr_dev(g11, "id", "rating-vis-container");
    			add_location(g11, file$4, 15, 0, 542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g11, anchor);
    			append_dev(g11, g10);
    			append_dev(g10, g3);
    			append_dev(g3, g0);
    			append_dev(g0, path0);
    			append_dev(g0, text0);
    			text0.innerHTML = raw0_value;
    			append_dev(g3, g1);
    			append_dev(g1, path1);
    			append_dev(g1, text1);
    			text1.innerHTML = raw1_value;
    			append_dev(g3, g2);
    			append_dev(g2, path2);
    			append_dev(g2, text2);
    			text2.innerHTML = raw2_value;
    			append_dev(g10, g9);
    			append_dev(g9, g4);
    			append_dev(g4, path3);
    			append_dev(g4, text3);
    			text3.innerHTML = raw3_value;
    			append_dev(g9, g5);
    			append_dev(g5, path4);
    			append_dev(g5, text4);
    			text4.innerHTML = raw4_value;
    			append_dev(g9, g6);
    			append_dev(g6, path5);
    			append_dev(g6, text5);
    			text5.innerHTML = raw5_value;
    			append_dev(g9, g7);
    			append_dev(g7, path6);
    			append_dev(g7, text6);
    			text6.innerHTML = raw6_value;
    			append_dev(g9, g8);
    			append_dev(g8, path7);
    			append_dev(g8, text7);
    			text7.innerHTML = raw7_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ratingData*/ 1 && raw0_value !== (raw0_value = /*ratingData*/ ctx[0].noRegrets.name + "")) text0.innerHTML = raw0_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g0, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].noRegrets.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw1_value !== (raw1_value = /*ratingData*/ ctx[0].forRating.name + "")) text1.innerHTML = raw1_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g1, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].forRating.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw2_value !== (raw2_value = /*ratingData*/ ctx[0].discard.name + "")) text2.innerHTML = raw2_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g2, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].discard.y + "px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g3, "hidden", /*$ui*/ ctx[1].state.actionVis.scene !== 0);
    			}

    			if (dirty & /*ratingData*/ 1 && raw3_value !== (raw3_value = /*ratingData*/ ctx[0].noRegrets.name + "")) text3.innerHTML = raw3_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g4, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].noRegrets.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw4_value !== (raw4_value = /*ratingData*/ ctx[0].twoCriteria.name + "")) text4.innerHTML = raw4_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g5, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].twoCriteria.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw5_value !== (raw5_value = /*ratingData*/ ctx[0].oneCriteria.name + "")) text5.innerHTML = raw5_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g6, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].oneCriteria.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw6_value !== (raw6_value = /*ratingData*/ ctx[0].zeroCriteria.name + "")) text6.innerHTML = raw6_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g7, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].zeroCriteria.y + "px)");
    			}

    			if (dirty & /*ratingData*/ 1 && raw7_value !== (raw7_value = /*ratingData*/ ctx[0].discard.name + "")) text7.innerHTML = raw7_value;
    			if (dirty & /*ratingData*/ 1) {
    				set_style(g8, "transform", "translate(" + 50 + "px , " + /*ratingData*/ ctx[0].discard.y + "px)");
    			}

    			if (dirty & /*$ui*/ 2) {
    				toggle_class(g9, "hidden", /*$ui*/ ctx[1].state.actionVis.scene === 0);
    			}
    		},
    		i: function intro(local) {
    			if (!g11_intro) {
    				add_render_callback(() => {
    					g11_intro = create_in_transition(g11, fade, {});
    					g11_intro.start();
    				});
    			}
    		},
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g11);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const markerWidth = 25;

    function instance$4($$self, $$props, $$invalidate) {
    	let $ui;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(1, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rating', slots, []);
    	let { dims = {} } = $$props; // SVG dimensions
    	let { ratingData = {} } = $$props;
    	const writable_props = ['dims', 'ratingData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rating> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('dims' in $$props) $$invalidate(2, dims = $$props.dims);
    		if ('ratingData' in $$props) $$invalidate(0, ratingData = $$props.ratingData);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		d3,
    		ui,
    		data,
    		slugify,
    		schema,
    		circleClockwise,
    		circleAntiClockwise,
    		dims,
    		ratingData,
    		markerWidth,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('dims' in $$props) $$invalidate(2, dims = $$props.dims);
    		if ('ratingData' in $$props) $$invalidate(0, ratingData = $$props.ratingData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ratingData, $ui, dims];
    }

    class Rating extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { dims: 2, ratingData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rating",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get dims() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dims(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ratingData() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ratingData(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/byPage/actions/ActionVis.svelte generated by Svelte v3.48.0 */
    const file$3 = "src/components/byPage/actions/ActionVis.svelte";

    // (523:64) 
    function create_if_block_7(ctx) {
    	let rating;
    	let current;

    	rating = new Rating({
    			props: {
    				dims: /*dims*/ ctx[3],
    				ratingData: /*ratingData*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rating.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rating, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rating, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(523:64) ",
    		ctx
    	});

    	return block;
    }

    // (521:67) 
    function create_if_block_6(ctx) {
    	let screening;
    	let current;

    	screening = new Screening({
    			props: { dims: /*dims*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(screening.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(screening, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(screening.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(screening.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(screening, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(521:67) ",
    		ctx
    	});

    	return block;
    }

    // (519:67) 
    function create_if_block_5(ctx) {
    	let focusarea;
    	let current;

    	focusarea = new FocusArea({
    			props: { dims: /*dims*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(focusarea.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(focusarea, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(focusarea.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(focusarea.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(focusarea, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(519:67) ",
    		ctx
    	});

    	return block;
    }

    // (517:62) 
    function create_if_block_4(ctx) {
    	let type;
    	let current;

    	type = new Type({
    			props: {
    				dims: /*dims*/ ctx[3],
    				typeData: /*typeData*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(type.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(type, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(type.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(type.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(type, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(517:62) ",
    		ctx
    	});

    	return block;
    }

    // (515:63) 
    function create_if_block_3(ctx) {
    	let scale;
    	let current;

    	scale = new Scale({
    			props: {
    				dims: /*dims*/ ctx[3],
    				scaleData: /*scaleData*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(scale.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(scale, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scale.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scale.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scale, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(515:63) ",
    		ctx
    	});

    	return block;
    }

    // (513:16) {#if $ui.state.actionVis.act === 'approach' }
    function create_if_block_2$1(ctx) {
    	let approach;
    	let current;

    	approach = new Approach({
    			props: {
    				dims: /*dims*/ ctx[3],
    				approachData: /*approachData*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(approach.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(approach, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(approach.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(approach.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(approach, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(513:16) {#if $ui.state.actionVis.act === 'approach' }",
    		ctx
    	});

    	return block;
    }

    // (533:65) 
    function create_if_block_1$1(ctx) {
    	let hazard;
    	let current;

    	hazard = new Hazard({
    			props: { dims: /*dims*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hazard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hazard, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hazard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hazard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hazard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(533:65) ",
    		ctx
    	});

    	return block;
    }

    // (531:16) {#if $ui.state.actionVis.act === 'intro' }
    function create_if_block$1(ctx) {
    	let intro;
    	let current;

    	intro = new Intro({
    			props: { dims: /*dims*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(intro.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(intro, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro$1(local) {
    			if (current) return;
    			transition_in(intro.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(intro.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(intro, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(531:16) {#if $ui.state.actionVis.act === 'intro' }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let section;
    	let div;
    	let figure;
    	let svg;
    	let legend;
    	let current_block_type_index;
    	let if_block0;
    	let if_block0_anchor;
    	let force;
    	let current_block_type_index_1;
    	let if_block1;
    	let current;

    	legend = new Legend({
    			props: { dims: /*dims*/ ctx[3] },
    			$$inline: true
    		});

    	const if_block_creators = [
    		create_if_block_2$1,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5,
    		create_if_block_6,
    		create_if_block_7
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'approach') return 0;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'scale') return 1;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'type') return 2;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'focusArea') return 3;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'screening') return 4;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'rating') return 5;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	force = new Force({
    			props: {
    				dims: /*dims*/ ctx[3],
    				forces: /*forces*/ ctx[2],
    				nodes: /*nodes*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block$1, create_if_block_1$1];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'intro') return 0;
    		if (/*$ui*/ ctx[0].state.actionVis.act === 'hazards') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
    		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	}

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			figure = element("figure");
    			svg = svg_element("svg");
    			create_component(legend.$$.fragment);
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			create_component(force.$$.fragment);
    			if (if_block1) if_block1.c();
    			attr_dev(svg, "viewBox", `0 0 ${/*dims*/ ctx[3].width} ${/*dims*/ ctx[3].height}`);
    			attr_dev(svg, "class", "svelte-191vh3m");
    			add_location(svg, file$3, 508, 12, 28568);
    			attr_dev(figure, "class", "svelte-191vh3m");
    			add_location(figure, file$3, 507, 8, 28547);
    			add_location(div, file$3, 506, 4, 28511);
    			attr_dev(section, "class", "svelte-191vh3m");
    			add_location(section, file$3, 504, 0, 28470);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			append_dev(div, figure);
    			append_dev(figure, svg);
    			mount_component(legend, svg, null);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(svg, null);
    			}

    			append_dev(svg, if_block0_anchor);
    			mount_component(force, svg, null);

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].m(svg, null);
    			}

    			/*div_binding*/ ctx[14](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(svg, if_block0_anchor);
    				} else {
    					if_block0 = null;
    				}
    			}

    			const force_changes = {};
    			if (dirty & /*forces*/ 4) force_changes.forces = /*forces*/ ctx[2];
    			force.$set(force_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if (~current_block_type_index_1) {
    					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    						if_blocks_1[previous_block_index_1] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index_1) {
    					if_block1 = if_blocks_1[current_block_type_index_1];

    					if (!if_block1) {
    						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    						if_block1.c();
    					} else {
    						if_block1.p(ctx, dirty);
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(svg, null);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(legend.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(force.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(legend.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(force.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(legend);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			destroy_component(force);

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].d();
    			}

    			/*div_binding*/ ctx[14](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let collisionType;
    	let forceCollide;
    	let focus;
    	let forces;
    	let $data;
    	let $ui;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(13, $data = $$value));
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(0, $ui = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ActionVis', slots, []);
    	let element;

    	let dims = {
    		width: 1600,
    		height: 1600,
    		nodeRadius: 22.5,
    		nodeArcRadius: 27.5,
    		flowNodeRadius: 0
    	};

    	// Node and schema data
    	const nodes = $data.actions.map(d => d);

    	const typeData = {
    		nodes: $data.schema.actionTypeNodes.data,
    		links: $data.schema.actionTypeLinks.data
    	};

    	const scaleData = $data.schema.actionScale.data.sort((a, b) => a.rank - b.rank);

    	const approachData = [
    		{
    			name: 'Reduce risk',
    			standard: {
    				x: dims.width * 0.3,
    				y: dims.height * 0.4
    			},
    			wide: {
    				x: dims.width * 0.15,
    				y: dims.height * 0.25
    			}
    		},
    		{
    			name: 'Increase resilience',
    			standard: {
    				x: dims.width * 0.7,
    				y: dims.height * 0.4
    			},
    			wide: {
    				x: dims.width * 0.85,
    				y: dims.height * 0.25
    			}
    		},
    		{
    			name: 'None',
    			standard: {
    				x: dims.width * 0.5,
    				y: dims.height * 0.75
    			},
    			wide: {
    				x: dims.width * 0.5,
    				y: dims.height * 0.65
    			}
    		}
    	];

    	const ratingData = {
    		noRegrets: { name: "No regrets", y: 0.1 * dims.height },
    		forRating: {
    			name: "Actions for consideration",
    			y: 0.5 * dims.height
    		},
    		discard: {
    			name: "Limited adaptation benefit",
    			y: 0.85 * dims.height
    		},
    		twoCriteria: {
    			name: "Higher priority",
    			y: 0.35 * dims.height
    		},
    		oneCriteria: {
    			name: "Lower priority",
    			y: 0.6 * dims.height
    		},
    		zeroCriteria: {
    			name: "Uncertain adaptation benefit",
    			y: 0.75 * dims.height
    		}
    	};

    	let schema;

    	// Scales 
    	set_store_value(
    		ui,
    		$ui.vis.nodes.scales = {
    			radiusScale: ordinal().domain(["Local", "Regional", "State", "National"]).range([
    				dims.nodeArcRadius,
    				dims.nodeArcRadius * 1.2,
    				dims.nodeArcRadius * 1.4,
    				dims.nodeArcRadius * 1.6
    			])
    		},
    		$ui
    	);

    	// Base force configurations
    	const centerPos = {
    		x: dims.width * 0.5,
    		y: dims.height * 0.5
    	};

    	const centerForce = {
    		x: x$2().x(centerPos.x),
    		y: y$1().y(centerPos.y)
    	};

    	const radialForceCenter = radial$1().x(centerPos.x).y(centerPos.y).radius(dims.width * 0.5);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ActionVis> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$capture_state = () => ({
    		d3,
    		onMount,
    		ui,
    		data,
    		Legend,
    		Force,
    		Intro,
    		Hazard,
    		Type,
    		Scale,
    		Approach,
    		FocusArea,
    		Screening,
    		Rating,
    		element,
    		dims,
    		nodes,
    		typeData,
    		scaleData,
    		approachData,
    		ratingData,
    		schema,
    		centerPos,
    		centerForce,
    		radialForceCenter,
    		forceCollide,
    		focus,
    		forces,
    		collisionType,
    		$data,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('element' in $$props) $$invalidate(1, element = $$props.element);
    		if ('dims' in $$props) $$invalidate(3, dims = $$props.dims);
    		if ('schema' in $$props) $$invalidate(9, schema = $$props.schema);
    		if ('forceCollide' in $$props) $$invalidate(10, forceCollide = $$props.forceCollide);
    		if ('focus' in $$props) $$invalidate(11, focus = $$props.focus);
    		if ('forces' in $$props) $$invalidate(2, forces = $$props.forces);
    		if ('collisionType' in $$props) $$invalidate(12, collisionType = $$props.collisionType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ui*/ 1) {
    			$$invalidate(12, collisionType = $ui.state.actionVis.nodes.shadow ? 'scale' : 'standard');
    		}

    		if ($$self.$$.dirty & /*collisionType, $data, $ui*/ 12289) {
    			$$invalidate(10, forceCollide = (function () {
    				const colissionMargin = 2.5;

    				switch (collisionType) {
    					case 'scale':
    						return collide().radius(d => {
    							const actionScale = $data.schema.actionScale.data.filter(e => e.recordID === d.Scale[0])[0].Scale;
    							return $ui.vis.nodes.scales.radiusScale(actionScale) + (actionScale === "Local" ? colissionMargin : 1);
    						}).iterations(3);
    					case 'standard':
    					default:
    						return collide().radius(dims.nodeArcRadius + colissionMargin).iterations(3);
    				}
    			})());
    		}

    		if ($$self.$$.dirty & /*$ui*/ 1) {
    			// Setup forces as reactive variables:
    			$$invalidate(11, focus = $ui.state.actionVis.nodes.focusArea);
    		}

    		if ($$self.$$.dirty & /*$ui, forceCollide, focus, $data, schema*/ 11777) {
    			$$invalidate(2, forces = (function () {
    				switch ($ui.state.actionVis.nodes.force) {
    					case "ring-outside":
    						return [
    							["x", centerForce.x.strength(0.1)],
    							["y", centerForce.y.strength(0.1)],
    							["collide", forceCollide],
    							[
    								"radial",
    								radialForceCenter.radius(dims.width * 0.65).strength(0.2)
    							]
    						];
    					case "ring-outer":
    						return [
    							["x", centerForce.x.strength(0.1)],
    							["y", centerForce.y.strength(0.1)],
    							["collide", forceCollide],
    							[
    								"radial",
    								radialForceCenter.radius(dims.width * 0.45).strength(0.75)
    							]
    						];
    					case "ring-mid":
    						return [
    							["x", centerForce.x.strength(0.5)],
    							["y", centerForce.y.strength(0.5)],
    							["collide", forceCollide],
    							["radial", radialForceCenter.radius(dims.width * 0.25).strength(2)]
    						];
    					case "ring-offscreen":
    						return [
    							["x", centerForce.x],
    							["y", centerForce.y],
    							["collide", forceCollide],
    							["radial", radialForceCenter.radius(dims.width * 5).strength(0.1)]
    						];
    					case "ring-focusArea":
    						const focusAreaID = focus
    						? $data.schema.adaptationFocus.data.filter(d => d["Focus area"] === $ui.state.actionVis.nodes.focusArea)[0].recordID
    						: null;
    						return [
    							["collide", forceCollide],
    							["x", centerForce.x.strength(0.1)],
    							[
    								"y",
    								y$1().y(d => d["Focus areas"].indexOf(focusAreaID) > -1
    								? dims.height * 0.4
    								: dims.height * 0.65).strength(0.175)
    							],
    							[
    								"radial",
    								radialForceCenter.radius(d => d["Focus areas"].indexOf(focusAreaID) > -1
    								? dims.width * 0.25
    								: dims.width * 0.45).strength(d => d["Focus areas"].indexOf(focusAreaID) > -1 ? 0.05 : 0.25)
    							]
    						];
    					case "top-line":
    						return [
    							["x", centerForce.x.strength(0.01)],
    							["y", y$1().y(0).strength(2)],
    							["collide", forceCollide]
    						];
    					case "bottom-line":
    						return [
    							["x", centerForce.x.strength(0.04)],
    							["y", y$1().y(dims.height).strength(0.5)],
    							["collide", forceCollide]
    						];
    					case "diagonal-up":
    						return [
    							[
    								"x",
    								x$2().x((d, i) => i / $data.actions.length * dims.width * 0.5 + dims.width * 0.25).strength(0.5)
    							],
    							[
    								"y",
    								y$1().y((d, i) => (dims.height - i / $data.actions.length * dims.height) * 0.8).strength(0.5)
    							],
    							["collide", forceCollide]
    						];
    					case "left-line":
    						return [
    							["x", x$2().x(0).strength(2)],
    							["y", y$1().y(dims.height * 0.5).strength(0.04)],
    							["collide", forceCollide]
    						];
    					case "right-line":
    						return [
    							["x", x$2().x(dims.width).strength(0.2)],
    							["y", y$1().y(dims.height * 0.5).strength(0.001)],
    							["collide", forceCollide]
    						];
    					case "arrow-down":
    						return [
    							["collide", forceCollide],
    							["x", centerForce.x.strength((d, i) => i % 2 === 0 ? 0.01 : 0.5)],
    							[
    								"y",
    								y$1().y((d, i) => i % 2 === 0 ? dims.height : dims.height * 0.5).strength((d, i) => i % 2 === 0 ? 0.2 : 0.02)
    							],
    							[
    								"radial",
    								radialForceCenter.radius(dims.height * 0.25).strength((d, i) => i % 2 === 0 ? 2 : 0)
    							]
    						];
    					case "cluster-type":
    						$$invalidate(9, schema = $data.schema.actionTypes.data);
    						$data.schema.actionTypeNodes.data;
    						return [
    							[
    								"x",
    								x$2().x(d => {
    									const type = schema.filter(e => e.recordID === d["Action type"][0])[0].Type;
    									return ($data.schema.actionTypeNodes.data.filter(d => d.Name === type)[0].xPos * 0.5 + 0.5) * dims.width;
    								})
    							],
    							[
    								"y",
    								y$1().y(d => {
    									const type = schema.filter(e => e.recordID === d["Action type"][0])[0].Type;
    									return $data.schema.actionTypeNodes.data.filter(d => d.Name === type)[0].yPos * dims.height;
    								})
    							],
    							["collide", forceCollide],
    							["charge", manyBody().strength(10)]
    						];
    					case "cluster-concrete-abstract":
    						$$invalidate(9, schema = $data.schema.actionTypes.data);
    						return [
    							["x", x$2().x(dims.width * 0.5)],
    							[
    								"y",
    								y$1().y(d => {
    									const type = schema.filter(e => e.recordID === d["Action type"][0])[0].Type;
    									return ($data.schema.actionTypeNodes.data.filter(d => d.Name === type)[0].yPos + 0.1) * dims.height;
    								})
    							],
    							["collide", forceCollide],
    							["charge", manyBody().strength(10)]
    						];
    					case "cluster-concrete-abstract-right":
    						$$invalidate(9, schema = $data.schema.actionTypes.data);
    						return [
    							["collide", forceCollide],
    							["x", x$2().x(dims.width)],
    							[
    								"y",
    								y$1().y(d => {
    									const type = schema.filter(e => e.recordID === d["Action type"][0])[0].Type;
    									return $data.schema.actionTypeNodes.data.filter(d => d.Name === type)[0].yPos * dims.height;
    								})
    							],
    							["charge", manyBody().strength(10)]
    						];
    					case "cluster-scale":
    						$$invalidate(9, schema = $data.schema.actionScale.data);
    						return [
    							["collide", forceCollide],
    							["x", x$2().x(dims.width * 0.75).strength(0.02)],
    							[
    								"y",
    								y$1().y(d => schema.filter(e => e.recordID === d["Scale"][0])[0].yPos * dims.height).strength(0.1)
    							]
    						];
    					case "cluster-approach":
    						$$invalidate(9, schema = $data.schema.adaptationApproaches.data);
    						return [
    							["collide", forceCollide],
    							[
    								"x",
    								x$2().x(d => {
    									if ([...new Set(d['Linked approach theme'])].length === 1) {
    										return approachData.filter(e => e.name === [...new Set(d['Linked approach theme'])][0])[0].standard.x;
    									} else {
    										return dims.width * 0.5;
    									}
    								}).strength(0.1)
    							],
    							[
    								"y",
    								y$1().y(d => {
    									if ([...new Set(d['Linked approach theme'])].length === 1) {
    										return approachData.filter(e => e.name === [...new Set(d['Linked approach theme'])][0])[0].standard.y;
    									} else {
    										return dims.height * 0.4;
    									}
    								}).strength(0.05)
    							]
    						];
    					case "cluster-approach-wide":
    						$$invalidate(9, schema = $data.schema.adaptationApproaches.data);
    						return [
    							["collide", forceCollide],
    							[
    								"x",
    								x$2().x(d => {
    									if ([...new Set(d['Linked approach theme'])].length === 1) {
    										return approachData.filter(e => e.name === [...new Set(d['Linked approach theme'])][0])[0].wide.x;
    									} else {
    										return dims.width * 0.5;
    									}
    								}).strength(0.15)
    							],
    							[
    								"y",
    								y$1().y(d => {
    									if ([...new Set(d['Linked approach theme'])].length === 1) {
    										return approachData.filter(e => e.name === [...new Set(d['Linked approach theme'])][0])[0].wide.y;
    									} else {
    										return (approachData[0].wide.y + approachData[1].wide.y) * 0.5;
    									}
    								}).strength(0.1)
    							]
    						];
    					case "cluster-hazards":
    						$$invalidate(9, schema = $data.schema.hazards.data);
    						return [
    							["collide", forceCollide],
    							[
    								"x",
    								x$2().x(d => {
    									const hazard = d["Hazard"].length === 1
    										? schema.filter(e => e.recordID === d["Hazard"][0])[0]["Hazard"]
    										: null,
    										i = schema.map(d => d.Hazard).indexOf(hazard);

    									return hazard
    									? dims.width * 0.5 + dims.width * 0.3 * Math.cos(i * (2 * Math.PI / schema.length) - Math.PI / 4)
    									: dims.width * 0.5;
    								})
    							],
    							[
    								"y",
    								y$1().y(d => {
    									const hazard = d["Hazard"].length === 1
    										? schema.filter(e => e.recordID === d["Hazard"][0])[0]["Hazard"]
    										: null,
    										i = schema.map(d => d.Hazard).indexOf(hazard);

    									return hazard
    									? dims.width * 0.5 + dims.width * 0.3 * Math.sin(i * (2 * Math.PI / schema.length) - Math.PI / 4)
    									: dims.width * 0.5;
    								})
    							],
    							[
    								"radial",
    								radialForceCenter.radius(d => {
    									const hazard = d["Hazard"].length === 1
    										? schema.filter(e => e.recordID === d["Hazard"][0])[0]["Hazard"]
    										: null;
    										schema.map(d => d.Hazard).indexOf(hazard);

    									return hazard ? dims.width * 0.225 : 0;
    								}).strength(0.25)
    							]
    						];
    					case "cluster-screening":
    						$$invalidate(9, schema = $data.schema.adaptationScreens.data);
    						return [
    							["collide", forceCollide],
    							[
    								"x",
    								x$2().x(d => {
    									const screen = {};

    									for (const obj of schema) {
    										screen[obj.Screen] = d[obj.fieldName];
    									}

    									if (screen.Flexible === 'Yes' && screen.Robust === "Yes" && screen.Viable === "Yes") {
    										return dims.width * 0.5;
    									} else if (screen.Flexible === 'Yes' && screen.Viable === "Yes") {
    										return dims.width * 0.5;
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes") {
    										return dims.width * 0.675;
    									} else if (screen.Viable === 'Yes' && screen.Robust === "Yes") {
    										return dims.width * 0.325;
    									} else if (screen.Flexible === 'Yes') {
    										return dims.width * 0.75;
    									} else if (screen.Viable === 'Yes') {
    										return dims.width * 0.25;
    									} else if (screen.Robust === 'Yes') {
    										return dims.width * 0.5;
    									} else {
    										return dims.width * 0.5;
    									}
    								}).strength(0.3)
    							],
    							[
    								"y",
    								y$1().y(d => {
    									const screen = {};

    									for (const obj of schema) {
    										screen[obj.Screen] = d[obj.fieldName];
    									}

    									if (screen.Flexible === 'Yes' && screen.Robust === "Yes" && screen.Viable === "Yes") {
    										return dims.height * 0.45;
    									} else if (screen.Flexible === 'Yes' && screen.Viable === "Yes") {
    										return dims.height * 0.65;
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes") {
    										return dims.height * 0.35;
    									} else if (screen.Viable === 'Yes' && screen.Robust === "Yes") {
    										return dims.height * 0.35;
    									} else if (screen.Flexible === 'Yes') {
    										return dims.height * 0.6;
    									} else if (screen.Viable === 'Yes') {
    										return dims.height * 0.6;
    									} else if (screen.Robust === 'Yes') {
    										return dims.height * 0.15;
    									} else {
    										return dims.height * 0.85;
    									}
    								}).strength(0.3)
    							]
    						];
    					case "cluster-noregets-vs-others":
    						return [
    							["collide", forceCollide],
    							["x", centerForce.x],
    							[
    								"y",
    								y$1().y(d => {
    									switch (d["Screening outcome"]) {
    										case "=> No regrets":
    											return ratingData.noRegrets.y;
    										case "=> Discard":
    											return ratingData.discard.y;
    										default:
    											return ratingData.forRating.y;
    									}
    								})
    							]
    						];
    					case "cluster-adaptation-criteria":
    						return [
    							["collide", forceCollide],
    							[
    								"x",
    								x$2().x(d => {
    									const screen = {};

    									for (const obj of schema) {
    										screen[obj.Screen] = d[obj.fieldName];
    									}

    									if (screen.Flexible === 'Yes' && screen.Robust === "Yes" && screen.Viable === "Yes") {
    										return dims.width * 0.65;
    									} else if (screen.Flexible === 'Yes' && screen.Viable === "Yes") {
    										return dims.width * 0.8;
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes") {
    										return dims.width * 0.65;
    									} else if (screen.Viable === 'Yes' && screen.Robust === "Yes") {
    										return dims.width * 0.5;
    									} else if (screen.Flexible === 'Yes') {
    										return dims.width * 0.8;
    									} else if (screen.Viable === 'Yes') {
    										return dims.width * 0.65;
    									} else if (screen.Robust === 'Yes') {
    										return dims.width * 0.5;
    									} else {
    										return dims.width * 0.65;
    									}
    								}).strength(0.15)
    							],
    							[
    								"y",
    								y$1().y(d => {
    									const screen = {};

    									for (const obj of schema) {
    										screen[obj.Screen] = d[obj.fieldName];
    									}

    									if (screen.Flexible === 'No' || screen.Robust === "No" || screen.Viable === "No") {
    										return ratingData.discard.y;
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes" && screen.Viable === "Yes") {
    										return ratingData.noRegrets.y;
    									} else if (screen.Flexible === 'Yes' && screen.Viable === "Yes") {
    										return ratingData.twoCriteria.y;
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes") {
    										return ratingData.twoCriteria.y;
    									} else if (screen.Viable === 'Yes' && screen.Robust === "Yes") {
    										return ratingData.twoCriteria.y;
    									} else if (screen.Flexible === 'Yes') {
    										return ratingData.oneCriteria.y;
    									} else if (screen.Viable === 'Yes') {
    										return ratingData.oneCriteria.y;
    									} else if (screen.Robust === 'Yes') {
    										return ratingData.oneCriteria.y;
    									} else {
    										return ratingData.zeroCriteria.y;
    									}
    								}).strength(0.5)
    							]
    						];
    					case "cluster-rating":
    						return [
    							["collide", forceCollide],
    							["x", x$2().x(dims.width * 0.65).strength(0.15)],
    							[
    								"y",
    								y$1().y(d => {
    									const screen = {};

    									for (const obj of schema) {
    										screen[obj.Screen] = d[obj.fieldName];
    									}

    									if (screen.Flexible === 'Yes' && screen.Robust === "Yes" && screen.Viable === "Yes") {
    										return ratingData.noRegrets.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Flexible === 'No' || screen.Robust === "No" || screen.Viable === "No") {
    										return ratingData.discard.y;
    									} else if (screen.Flexible === 'Yes' && screen.Viable === "Yes") {
    										return ratingData.twoCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Flexible === 'Yes' && screen.Robust === "Yes") {
    										return ratingData.twoCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Viable === 'Yes' && screen.Robust === "Yes") {
    										return ratingData.twoCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Flexible === 'Yes') {
    										return ratingData.oneCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Viable === 'Yes') {
    										return ratingData.oneCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else if (screen.Robust === 'Yes') {
    										return ratingData.oneCriteria.y - (d["Average hazard rating"] / 5 * dims.height * 0.2 - dims.height * 0.1);
    									} else {
    										return ratingData.zeroCriteria.y;
    									}
    								}).strength(0.25)
    							]
    						];
    					case "cluster-center":
    					default:
    						return [
    							["x", centerForce.x],
    							["y", centerForce.y],
    							["collide", forceCollide]
    						];
    				}
    			})());
    		}
    	};

    	return [
    		$ui,
    		element,
    		forces,
    		dims,
    		nodes,
    		typeData,
    		scaleData,
    		approachData,
    		ratingData,
    		schema,
    		forceCollide,
    		focus,
    		collisionType,
    		$data,
    		div_binding
    	];
    }

    class ActionVis extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ActionVis",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/shared/Switch.svelte generated by Svelte v3.48.0 */

    const file$2 = "src/components/shared/Switch.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (28:8) {#each options as option}
    function create_each_block(ctx) {
    	let input;
    	let input_id_value;
    	let input_value_value;
    	let t0;
    	let label;
    	let t1_value = /*option*/ ctx[8] + "";
    	let t1;
    	let t2;
    	let label_for_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = text$1(t1_value);
    			t2 = space();
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "id", input_id_value = `${/*option*/ ctx[8]}-${/*uniqueID*/ ctx[2]}`);
    			input.__value = input_value_value = /*option*/ ctx[8];
    			input.value = input.__value;
    			attr_dev(input, "class", "svelte-3d9wqu");
    			/*$$binding_groups*/ ctx[4][0].push(input);
    			add_location(input, file$2, 28, 12, 1080);
    			attr_dev(label, "for", label_for_value = `${/*option*/ ctx[8]}-${/*uniqueID*/ ctx[2]}`);
    			attr_dev(label, "class", "svelte-3d9wqu");
    			add_location(label, file$2, 29, 12, 1176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = input.__value === /*value*/ ctx[0];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label, anchor);
    			append_dev(label, t1);
    			append_dev(label, t2);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[3]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options*/ 2 && input_id_value !== (input_id_value = `${/*option*/ ctx[8]}-${/*uniqueID*/ ctx[2]}`)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*options*/ 2 && input_value_value !== (input_value_value = /*option*/ ctx[8])) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (dirty & /*value*/ 1) {
    				input.checked = input.__value === /*value*/ ctx[0];
    			}

    			if (dirty & /*options*/ 2 && t1_value !== (t1_value = /*option*/ ctx[8] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*options*/ 2 && label_for_value !== (label_for_value = `${/*option*/ ctx[8]}-${/*uniqueID*/ ctx[2]}`)) {
    				attr_dev(label, "for", label_for_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[4][0].splice(/*$$binding_groups*/ ctx[4][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(28:8) {#each options as option}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div1;
    	let div0;
    	let each_value = /*options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "role", "radiogroup");
    			attr_dev(div0, "class", "group-container svelte-3d9wqu");
    			attr_dev(div0, "aria-labelledby", `label-${/*uniqueID*/ ctx[2]}`);
    			attr_dev(div0, "id", `group-${/*uniqueID*/ ctx[2]}`);
    			add_location(div0, file$2, 25, 4, 846);
    			attr_dev(div1, "class", "s s--multi svelte-3d9wqu");
    			add_location(div1, file$2, 24, 0, 817);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*options, uniqueID, value*/ 7) {
    				each_value = /*options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Switch', slots, []);
    	let { options = [] } = $$props;
    	let { value = 'off' } = $$props;
    	let checked = false;
    	const uniqueID = Math.floor(Math.random() * 100);

    	function handleClick(event) {
    		const target = event.target;
    		const state = target.getAttribute('aria-checked');
    		checked = state === 'true' ? false : true;
    		$$invalidate(0, value = checked === true ? 'on' : 'off');
    	}

    	const slugify = (str = "") => str.toLowerCase().replace(/ /g, "-").replace(/\./g, "");
    	const writable_props = ['options', 'value'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Switch> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		value = this.__value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		options,
    		value,
    		checked,
    		uniqueID,
    		handleClick,
    		slugify
    	});

    	$$self.$inject_state = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('checked' in $$props) checked = $$props.checked;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, options, uniqueID, input_change_handler, $$binding_groups];
    }

    class Switch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { options: 1, value: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Switch",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get options() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/Actions.svelte generated by Svelte v3.48.0 */
    const file$1 = "src/pages/Actions.svelte";

    function create_fragment$1(ctx) {
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let logo;
    	let t0;
    	let h1;
    	let span0;
    	let br0;
    	let t2;
    	let br1;
    	let t3;
    	let span1;
    	let t5;
    	let div2;
    	let p0;
    	let t7;
    	let div3;
    	let ul0;
    	let li0;
    	let t9;
    	let li1;
    	let t11;
    	let li2;
    	let t13;
    	let li3;
    	let t15;
    	let li4;
    	let t17;
    	let li5;
    	let t19;
    	let li6;
    	let t21;
    	let li7;
    	let t23;
    	let li8;
    	let t25;
    	let div40;
    	let div37;
    	let div9;
    	let div6;
    	let hr0;
    	let t26;
    	let h20;
    	let t28;
    	let p1;
    	let t29;
    	let html_tag;
    	let raw0_value = /*$data*/ ctx[1].stats.actions.total + "";
    	let t30;
    	let span2;
    	let t32;
    	let t33;
    	let div7;
    	let p2;
    	let t34;
    	let html_tag_1;
    	let raw1_value = /*$data*/ ctx[1].stats.actions.total + "";
    	let t35;
    	let em0;
    	let t37;
    	let t38;
    	let div8;
    	let p3;
    	let t39;
    	let em1;
    	let t41;
    	let em2;
    	let t43;
    	let em3;
    	let t45;
    	let p4;
    	let t47;
    	let div13;
    	let div10;
    	let hr1;
    	let t48;
    	let h21;
    	let t50;
    	let p5;
    	let t51;
    	let strong0;
    	let t53;
    	let t54;
    	let div11;
    	let p6;
    	let t55;
    	let em4;
    	let t57;
    	let strong1;
    	let t59;
    	let t60;
    	let div12;
    	let p7;
    	let t61;
    	let span3;
    	let t63;
    	let t64;
    	let div17;
    	let div14;
    	let hr2;
    	let t65;
    	let h22;
    	let t67;
    	let p8;
    	let t69;
    	let ul1;
    	let li9;
    	let t70;
    	let strong2;
    	let t72;
    	let t73;
    	let li10;
    	let t74;
    	let strong3;
    	let t76;
    	let p9;
    	let t78;
    	let div15;
    	let p10;
    	let t80;
    	let div16;
    	let p11;
    	let t82;
    	let div20;
    	let div18;
    	let hr3;
    	let t83;
    	let h23;
    	let t85;
    	let p12;
    	let t86;
    	let strong4;
    	let t88;
    	let em5;
    	let t90;
    	let em6;
    	let t92;
    	let em7;
    	let t94;
    	let em8;
    	let t96;
    	let t97;
    	let div19;
    	let p13;
    	let t98;
    	let strong5;
    	let t100;
    	let t101;
    	let div24;
    	let div21;
    	let hr4;
    	let t102;
    	let h24;
    	let t104;
    	let div22;
    	let p14;
    	let t106;
    	let p15;
    	let t107;
    	let strong6;
    	let t109;
    	let em9;
    	let t111;
    	let em10;
    	let t113;
    	let t114;
    	let div23;
    	let p16;
    	let t116;
    	let p17;
    	let t117;
    	let em11;
    	let t119;
    	let t120;
    	let switch_1;
    	let updating_value;
    	let t121;
    	let div26;
    	let div25;
    	let hr5;
    	let t122;
    	let h25;
    	let t124;
    	let p18;
    	let strong7;
    	let t126;
    	let a0;
    	let t128;
    	let a1;
    	let t130;
    	let strong8;
    	let t132;
    	let t133;
    	let p19;
    	let t134;
    	let strong9;
    	let t136;
    	let t137;
    	let p20;
    	let t138;
    	let strong10;
    	let t140;
    	let div30;
    	let div27;
    	let hr6;
    	let t141;
    	let h26;
    	let t143;
    	let div28;
    	let p21;
    	let t145;
    	let p22;
    	let t146;
    	let strong11;
    	let t148;
    	let strong12;
    	let t150;
    	let strong13;
    	let t152;
    	let strong14;
    	let t154;
    	let t155;
    	let div29;
    	let p23;
    	let t156;
    	let strong15;
    	let t158;
    	let t159;
    	let p24;
    	let t160;
    	let em12;
    	let t162;
    	let t163;
    	let div34;
    	let div31;
    	let hr7;
    	let t164;
    	let h27;
    	let t166;
    	let p25;
    	let t168;
    	let div32;
    	let p26;
    	let t170;
    	let div33;
    	let p27;
    	let t171;
    	let em13;
    	let t173;
    	let p28;
    	let t175;
    	let div36;
    	let div35;
    	let hr8;
    	let t176;
    	let h28;
    	let t178;
    	let p29;
    	let t179;
    	let strong16;
    	let t181;
    	let t182;
    	let p30;
    	let t183;
    	let strong17;
    	let t185;
    	let t186;
    	let ul2;
    	let li11;
    	let t188;
    	let li12;
    	let t190;
    	let li13;
    	let t192;
    	let li14;
    	let t194;
    	let p31;
    	let t196;
    	let div39;
    	let div38;
    	let actionvis;
    	let t197;
    	let div42;
    	let div41;
    	let p32;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ $$inline: true });

    	function switch_1_value_binding(value) {
    		/*switch_1_value_binding*/ ctx[5](value);
    	}

    	let switch_1_props = { options: /*flowDiagramOptions*/ ctx[3] };

    	if (/*flowDiagramState*/ ctx[0] !== void 0) {
    		switch_1_props.value = /*flowDiagramState*/ ctx[0];
    	}

    	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(switch_1, 'value', switch_1_value_binding));
    	actionvis = new ActionVis({ $$inline: true });

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			span0 = element("span");
    			span0.textContent = "understanding";
    			br0 = element("br");
    			t2 = text$1("\n            adaptation");
    			br1 = element("br");
    			t3 = space();
    			span1 = element("span");
    			span1.textContent = "actions";
    			t5 = space();
    			div2 = element("div");
    			p0 = element("p");
    			p0.textContent = "There's a lot to consider when thinking about the actions we need to take to prepare and adapt our community for climate change. In this section we'll take a closer look at key actions that area already happening in and around Hepburn, through a series of different adaptation 'lenses'. Our aim is to get a comprehensive idea of how we're responding, and what else we might need to do.";
    			t7 = space();
    			div3 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			li0.textContent = "Introduction";
    			t9 = space();
    			li1 = element("li");
    			li1.textContent = "Hazards";
    			t11 = space();
    			li2 = element("li");
    			li2.textContent = "Approach";
    			t13 = space();
    			li3 = element("li");
    			li3.textContent = "Scale";
    			t15 = space();
    			li4 = element("li");
    			li4.textContent = "Type";
    			t17 = space();
    			li5 = element("li");
    			li5.textContent = "Focus areas";
    			t19 = space();
    			li6 = element("li");
    			li6.textContent = "Adaptation criteria";
    			t21 = space();
    			li7 = element("li");
    			li7.textContent = "Rating actions";
    			t23 = space();
    			li8 = element("li");
    			li8.textContent = "Beyond adaptation";
    			t25 = space();
    			div40 = element("div");
    			div37 = element("div");
    			div9 = element("div");
    			div6 = element("div");
    			hr0 = element("hr");
    			t26 = space();
    			h20 = element("h2");
    			h20.textContent = "Making sense of adaptation actions";
    			t28 = space();
    			p1 = element("p");
    			t29 = text$1("We've identified ");
    			html_tag = new HtmlTag(false);
    			t30 = text$1(" actions (so far) that are helping Hepburn adapt to climate change. Let's start by representing each action as a little ");
    			span2 = element("span");
    			span2.textContent = "dot";
    			t32 = text$1(" on the screen.");
    			t33 = space();
    			div7 = element("div");
    			p2 = element("p");
    			t34 = text$1("This seems nice an orderly: ");
    			html_tag_1 = new HtmlTag(false);
    			t35 = text$1(" actions ");
    			em0 = element("em");
    			em0.textContent = "seems";
    			t37 = text$1(" reasonable...or is it!? Adaptation actions vary wildly in size, scope and focus: many of actions here have adaptation benefits, but aren't specifically being done to manage climate risks and impacts.");
    			t38 = space();
    			div8 = element("div");
    			p3 = element("p");
    			t39 = text$1("So how can we see how these actions match up to ");
    			em1 = element("em");
    			em1.textContent = "our";
    			t41 = text$1(" adaptation needs? How can we tell if what we're doing is effective? Are we doing ");
    			em2 = element("em");
    			em2.textContent = "enough";
    			t43 = text$1("? And are we doing enough in the ");
    			em3 = element("em");
    			em3.textContent = "right places?";
    			t45 = space();
    			p4 = element("p");
    			p4.textContent = "This guide walks you through some key ways to view Hepburn's adaptation actions. It won't definitively answer these questions - because 'adaptation' doesn't have a single, measurable goal - but it will hopefully equip you with an understanding of what's being done, where there might be gaps, and potentially where you might be able to help our community adapt to climate change.";
    			t47 = space();
    			div13 = element("div");
    			div10 = element("div");
    			hr1 = element("hr");
    			t48 = space();
    			h21 = element("h2");
    			h21.textContent = "Actions vs climate hazards";
    			t50 = space();
    			p5 = element("p");
    			t51 = text$1("There are ");
    			strong0 = element("strong");
    			strong0.textContent = "four climate hazards";
    			t53 = text$1(" facing Hepburn, each of which increases the likelihood of climate events that pose risks to the community.");
    			t54 = space();
    			div11 = element("div");
    			p6 = element("p");
    			t55 = text$1("We want to see how our actions address each hazard. To begin with, we can ");
    			em4 = element("em");
    			em4.textContent = "count how many";
    			t57 = text$1(" actions address each hazard. We could try to position each action near the hazards they are trying to address. But we quickly notice is that there are ");
    			strong1 = element("strong");
    			strong1.textContent = "actions that address multiple hazards";
    			t59 = text$1(".");
    			t60 = space();
    			div12 = element("div");
    			p7 = element("p");
    			t61 = text$1("So how about we re-design our dots by putting some matching ");
    			span3 = element("span");
    			span3.textContent = "coloured arcs";
    			t63 = text$1(" around our actions. Its a bit busy, but now we can identify which actions address which hazards!");
    			t64 = space();
    			div17 = element("div");
    			div14 = element("div");
    			hr2 = element("hr");
    			t65 = space();
    			h22 = element("h2");
    			h22.textContent = "Adaptation approaches";
    			t67 = space();
    			p8 = element("p");
    			p8.textContent = "There are two approaches when in comes to adaptation:";
    			t69 = space();
    			ul1 = element("ul");
    			li9 = element("li");
    			t70 = text$1("We can ");
    			strong2 = element("strong");
    			strong2.textContent = "reduce risk";
    			t72 = text$1("; and");
    			t73 = space();
    			li10 = element("li");
    			t74 = text$1("We can ");
    			strong3 = element("strong");
    			strong3.textContent = "increase resilience";
    			t76 = space();
    			p9 = element("p");
    			p9.textContent = "Each of these  approaches contains a handful of more specific approaches, and our actions can take multiple approaches. What is obvious is that we want is good spread of actions so that our approach to adaptation is diverse.";
    			t78 = space();
    			div15 = element("div");
    			p10 = element("p");
    			p10.textContent = "We can try to position actions over these two approaches, but we again run into the problem with actions that both reduce risk and increase resilience. There might also be some actions that don't really fit either approach: usually because they're quite 'indirect' or 'high-level'.";
    			t80 = space();
    			div16 = element("div");
    			p11 = element("p");
    			p11.textContent = "So to help us better identify the adaptation approach of each action, we're going to put little triangle symbols inside each action.";
    			t82 = space();
    			div20 = element("div");
    			div18 = element("div");
    			hr3 = element("hr");
    			t83 = space();
    			h23 = element("h2");
    			h23.textContent = "Actions scale";
    			t85 = space();
    			p12 = element("p");
    			t86 = text$1("The next lens we'll look at our actions through concerns their ");
    			strong4 = element("strong");
    			strong4.textContent = "scale";
    			t88 = text$1(". This is a classification of whether an action is specific to the ");
    			em5 = element("em");
    			em5.textContent = "local";
    			t90 = text$1(" Hepburn area, or if the action operates at broader scale of either: a ");
    			em6 = element("em");
    			em6.textContent = "regional";
    			t92 = text$1(" level (e.g. Grampians or Central Highlands), the Victorian ");
    			em7 = element("em");
    			em7.textContent = "state";
    			t94 = text$1(" level, or at a ");
    			em8 = element("em");
    			em8.textContent = "national";
    			t96 = text$1(" level.");
    			t97 = space();
    			div19 = element("div");
    			p13 = element("p");
    			t98 = text$1("How might we visualise scale? The obvious indicator for scale is size — maybe we could adjust the overall size of each action? However ");
    			strong5 = element("strong");
    			strong5.textContent = "we're interested in how these actions affect Hepburn";
    			t100 = text$1(", so it doesn't make much sense to visually weight a national action over a local one. So what we'll do is add a subtle, shadow-y ring around the actions that are beyond local scale and move on!");
    			t101 = space();
    			div24 = element("div");
    			div21 = element("div");
    			hr4 = element("hr");
    			t102 = space();
    			h24 = element("h2");
    			h24.textContent = "Types of actions";
    			t104 = space();
    			div22 = element("div");
    			p14 = element("p");
    			p14.textContent = "Now that we can see some of the key characteristics of our actions, we can start to think about more sophisticated classifications that give us insight into how well coordinated our adaptation are.";
    			t106 = space();
    			p15 = element("p");
    			t107 = text$1("This diagram shows how actions of different ");
    			strong6 = element("strong");
    			strong6.textContent = "types";
    			t109 = text$1(" might be connected, and how the knowledge gained from more ");
    			em9 = element("em");
    			em9.textContent = "abstract";
    			t111 = text$1(" actions, helps to inform more ");
    			em10 = element("em");
    			em10.textContent = "concrete";
    			t113 = text$1(" responses to climate risk.");
    			t114 = space();
    			div23 = element("div");
    			p16 = element("p");
    			p16.textContent = "We could see how actions are distributed by type by positioning them on the diagram. This view helps us see what types of actions are taking place, and where more attention might be required.";
    			t116 = space();
    			p17 = element("p");
    			t117 = text$1("We can also used these classifications to reveal how actions are distributed on a more focused action type spectrum between ");
    			em11 = element("em");
    			em11.textContent = "more abstract to more concrete";
    			t119 = text$1(" using this switch below.");
    			t120 = space();
    			create_component(switch_1.$$.fragment);
    			t121 = space();
    			div26 = element("div");
    			div25 = element("div");
    			hr5 = element("hr");
    			t122 = space();
    			h25 = element("h2");
    			h25.textContent = "Adaptation focus areas";
    			t124 = space();
    			p18 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Five focus areas";
    			t126 = text$1(" have were identified through a ");
    			a0 = element("a");
    			a0.textContent = "climate adaptation situational analysis study";
    			t128 = text$1(" for broader ");
    			a1 = element("a");
    			a1.textContent = "Grampians region";
    			t130 = text$1(". These areas are another useful lens for assessing how well distributed our adaptation actions are across ");
    			strong8 = element("strong");
    			strong8.textContent = "areas that matter to Hepburn";
    			t132 = text$1(".");
    			t133 = space();
    			p19 = element("p");
    			t134 = text$1("For Hepburn, we've added a sixth important focus area of ");
    			strong9 = element("strong");
    			strong9.textContent = "healing country";
    			t136 = text$1(" to highlight the importance of actions that embrace the views and practices of Traditional Owners' to manage climate risk.");
    			t137 = space();
    			p20 = element("p");
    			t138 = text$1("Now of course, many actions address multiple focus areas - so we'll another way to show which actions gravitate to a given focus area. To do this, ");
    			strong10 = element("strong");
    			strong10.textContent = "you can tap on any of the focus area names to see which actions relate to that area.";
    			t140 = space();
    			div30 = element("div");
    			div27 = element("div");
    			hr6 = element("hr");
    			t141 = space();
    			h26 = element("h2");
    			h26.textContent = "Key adaptation criteria";
    			t143 = space();
    			div28 = element("div");
    			p21 = element("p");
    			p21.textContent = "We've looked at different ways to classify and cluster actions that hopefully provides some insight into how they collectively respond to our adaptation challenge. Now we're going to look at ways of evaluating and prioritising these actions.";
    			t145 = space();
    			p22 = element("p");
    			t146 = text$1("We start by answering three simple questions of each action that are aligned to key ");
    			strong11 = element("strong");
    			strong11.textContent = "adaptation criteria";
    			t148 = text$1(". These are questions that can be answered with a(n emphatic) \"yes\" or \"no\", or \"unsure\". These questions simply consider whether an action is ");
    			strong12 = element("strong");
    			strong12.textContent = "robust";
    			t150 = text$1(", ");
    			strong13 = element("strong");
    			strong13.textContent = "flexible";
    			t152 = text$1(" and/or ");
    			strong14 = element("strong");
    			strong14.textContent = "viable";
    			t154 = text$1(".");
    			t155 = space();
    			div29 = element("div");
    			p23 = element("p");
    			t156 = text$1("Actions that meet all criteria are automatically classed as ");
    			strong15 = element("strong");
    			strong15.textContent = "no regrets actions";
    			t158 = text$1(": there's no reason to not do these actions, so we should implement and support them!");
    			t159 = space();
    			p24 = element("p");
    			t160 = text$1("Actions that answer \"no\" to ");
    			em12 = element("em");
    			em12.textContent = "any of the three criteria";
    			t162 = text$1(" are considered to have limited adaptation benefit, or may lead to maladaptation. These actions are de-prioritised and essentially discarded from consideration. Next we'll look at How we might go further and prioritise these actions.");
    			t163 = space();
    			div34 = element("div");
    			div31 = element("div");
    			hr7 = element("hr");
    			t164 = space();
    			h27 = element("h2");
    			h27.textContent = "Prioritising adaptation actions";
    			t166 = space();
    			p25 = element("p");
    			p25.textContent = "We've separated our actions into three groups based on key adaptation criteria. So what next?";
    			t168 = space();
    			div32 = element("div");
    			p26 = element("p");
    			p26.textContent = "We can use our adaptation criteria further to create priority tiers for those actions that met two, one or none of the criteria. This is a imperfect way of stratifying actions but is relatively logical and robust: actions that expected to meet more key adaptation criteria float to the top.";
    			t170 = space();
    			div33 = element("div");
    			p27 = element("p");
    			t171 = text$1("Next, we'll differentiate actions by rating how effective they're expected to be at responding to climate hazards. We've rated each action on the (expected) efficacy of their response to each hazard that it addresses. This is a subjective (1 to 5) rating that accounts for the size and scope of the action: so it takes into consideration how ambitious the action is, and how much it might achieve against the hazards it addresses. We use this process to differentiate actions ");
    			em13 = element("em");
    			em13.textContent = "within their priority tiers.";
    			t173 = space();
    			p28 = element("p");
    			p28.textContent = "What we're left with is a loosely prioritised a view of our adaptation actions!";
    			t175 = space();
    			div36 = element("div");
    			div35 = element("div");
    			hr8 = element("hr");
    			t176 = space();
    			h28 = element("h2");
    			h28.textContent = "Beyond the adaptation lens";
    			t178 = space();
    			p29 = element("p");
    			t179 = text$1("We've taken a look at our adaptation actions as a ");
    			strong16 = element("strong");
    			strong16.textContent = "collective";
    			t181 = text$1(", through a series lenses and perspectives. We've even tried to assess and rank our actions. But is that enough? Do we now know what to do to adapt to climate change?!");
    			t182 = space();
    			p30 = element("p");
    			t183 = text$1("Well unfortunately, like all complex challenges, there are (yet) ");
    			strong17 = element("strong");
    			strong17.textContent = "more characteristics that need to be considered";
    			t185 = text$1(" that can be equally sophisticated and obtuse. Areas that we haven't 'analysed' here include:");
    			t186 = space();
    			ul2 = element("ul");
    			li11 = element("li");
    			li11.textContent = "action timing and dependencies and/or mutual exclusivity;";
    			t188 = space();
    			li12 = element("li");
    			li12.textContent = "synergies (and dis-synergies) of adaptation benefits;";
    			t190 = space();
    			li13 = element("li");
    			li13.textContent = "the roles of influence and responsibility; and";
    			t192 = space();
    			li14 = element("li");
    			li14.textContent = "idea that actions can have adaptation co-benefits and unintended consequences.";
    			t194 = space();
    			p31 = element("p");
    			p31.textContent = "These last concepts are critical to remember as there can be many reasons to proceed or not proceed with an action that have nothing to do with climate change adaptation. Our challenge as a community is not to precisely account for each of these sophisticated characteristics. Instead, we can use our understanding of what makes for a good adaptation response to support and coordinate actions that we are confident will lead to comprehensive and practical adaptation benefits for our community.";
    			t196 = space();
    			div39 = element("div");
    			div38 = element("div");
    			create_component(actionvis.$$.fragment);
    			t197 = space();
    			div42 = element("div");
    			div41 = element("div");
    			p32 = element("p");
    			p32.textContent = "At the moment there is no \"print to PDF-able\" version of this content as it has been designed for digital media and features interactive content.";
    			attr_dev(div0, "class", "hero-logo__wrapper svelte-1e5obqh");
    			add_location(div0, file$1, 133, 12, 6164);
    			attr_dev(div1, "class", "hero-logo svelte-1e5obqh");
    			add_location(div1, file$1, 132, 8, 6128);
    			attr_dev(span0, "class", "title--mute svelte-1e5obqh");
    			add_location(span0, file$1, 136, 12, 6278);
    			add_location(br0, file$1, 136, 60, 6326);
    			add_location(br1, file$1, 137, 22, 6354);
    			attr_dev(span1, "class", "title--highlight svelte-1e5obqh");
    			add_location(span1, file$1, 138, 12, 6372);
    			attr_dev(h1, "class", "hero-content__title svelte-1e5obqh");
    			add_location(h1, file$1, 135, 8, 6233);
    			add_location(p0, file$1, 141, 12, 6487);
    			attr_dev(div2, "class", "hero-content__text svelte-1e5obqh");
    			add_location(div2, file$1, 140, 8, 6442);
    			attr_dev(li0, "class", "select__item svelte-1e5obqh");
    			attr_dev(li0, "actname", "intro");
    			add_location(li0, file$1, 146, 16, 6971);
    			attr_dev(li1, "class", "select__item svelte-1e5obqh");
    			attr_dev(li1, "actname", "hazards");
    			add_location(li1, file$1, 147, 16, 7070);
    			attr_dev(li2, "class", "select__item svelte-1e5obqh");
    			attr_dev(li2, "actname", "approach");
    			add_location(li2, file$1, 148, 16, 7166);
    			attr_dev(li3, "class", "select__item svelte-1e5obqh");
    			attr_dev(li3, "actname", "scale");
    			add_location(li3, file$1, 149, 16, 7264);
    			attr_dev(li4, "class", "select__item svelte-1e5obqh");
    			attr_dev(li4, "actname", "type");
    			add_location(li4, file$1, 150, 16, 7356);
    			attr_dev(li5, "class", "select__item svelte-1e5obqh");
    			attr_dev(li5, "actname", "focusArea");
    			add_location(li5, file$1, 151, 16, 7446);
    			attr_dev(li6, "class", "select__item svelte-1e5obqh");
    			attr_dev(li6, "actname", "screening");
    			add_location(li6, file$1, 152, 16, 7548);
    			attr_dev(li7, "class", "select__item svelte-1e5obqh");
    			attr_dev(li7, "actname", "rating");
    			add_location(li7, file$1, 153, 16, 7658);
    			attr_dev(li8, "class", "select__item svelte-1e5obqh");
    			attr_dev(li8, "actname", "beyond");
    			add_location(li8, file$1, 154, 16, 7760);
    			add_location(ul0, file$1, 145, 12, 6950);
    			attr_dev(div3, "class", "select svelte-1e5obqh");
    			add_location(div3, file$1, 144, 8, 6916);
    			attr_dev(div4, "class", "hero-content svelte-1e5obqh");
    			add_location(div4, file$1, 130, 4, 6058);
    			attr_dev(div5, "class", "hero-wrapper");
    			add_location(div5, file$1, 129, 0, 6025);
    			attr_dev(hr0, "class", "svelte-1e5obqh");
    			add_location(hr0, file$1, 166, 16, 8155);
    			attr_dev(h20, "class", "svelte-1e5obqh");
    			add_location(h20, file$1, 167, 16, 8176);
    			html_tag.a = t30;
    			attr_dev(span2, "class", "action-dot svelte-1e5obqh");
    			add_location(span2, file$1, 168, 189, 8409);
    			add_location(p1, file$1, 168, 16, 8236);
    			attr_dev(div6, "scene", "0");
    			attr_dev(div6, "force", "cluster-center");
    			add_location(div6, file$1, 165, 12, 8100);
    			html_tag_1.a = t35;
    			add_location(em0, file$1, 171, 89, 8622);
    			add_location(p2, file$1, 171, 16, 8549);
    			attr_dev(div7, "scene", "1");
    			attr_dev(div7, "force", "ring-outer");
    			add_location(div7, file$1, 170, 12, 8498);
    			add_location(em1, file$1, 174, 67, 8988);
    			add_location(em2, file$1, 174, 161, 9082);
    			add_location(em3, file$1, 174, 209, 9130);
    			add_location(p3, file$1, 174, 16, 8937);
    			add_location(p4, file$1, 176, 16, 9190);
    			attr_dev(div8, "scene", "2");
    			attr_dev(div8, "act", "intro");
    			attr_dev(div8, "force", "arrow-down");
    			add_location(div8, file$1, 173, 12, 8872);
    			attr_dev(div9, "act", "intro");
    			attr_dev(div9, "class", "act-narrative svelte-1e5obqh");
    			add_location(div9, file$1, 164, 8, 8044);
    			attr_dev(hr1, "class", "svelte-1e5obqh");
    			add_location(hr1, file$1, 183, 16, 9790);
    			attr_dev(h21, "class", "svelte-1e5obqh");
    			add_location(h21, file$1, 184, 16, 9811);
    			add_location(strong0, file$1, 185, 29, 9876);
    			add_location(p5, file$1, 185, 16, 9863);
    			attr_dev(div10, "act", "hazards");
    			attr_dev(div10, "scene", "0");
    			attr_dev(div10, "force", "cluster-center");
    			add_location(div10, file$1, 182, 12, 9720);
    			add_location(em4, file$1, 189, 93, 10282);
    			add_location(strong1, file$1, 189, 268, 10457);
    			add_location(p6, file$1, 189, 16, 10205);
    			attr_dev(div11, "scene", "1");
    			attr_dev(div11, "force", "cluster-hazard");
    			attr_dev(div11, "nodebase", "true");
    			attr_dev(div11, "nodearcs", "false");
    			attr_dev(div11, "nodeshapes", "false");
    			attr_dev(div11, "nodeshadow", "false");
    			add_location(div11, file$1, 188, 12, 10073);
    			attr_dev(span3, "class", "text-arcs svelte-1e5obqh");
    			add_location(span3, file$1, 193, 79, 10774);
    			add_location(p7, file$1, 193, 16, 10711);
    			attr_dev(div12, "act", "hazards");
    			attr_dev(div12, "scene", "2");
    			attr_dev(div12, "force", "cluster-center");
    			attr_dev(div12, "nodebase", "false");
    			attr_dev(div12, "nodearcs", "true");
    			attr_dev(div12, "nodeshapes", "false");
    			attr_dev(div12, "nodeshadow", "false");
    			add_location(div12, file$1, 192, 12, 10565);
    			attr_dev(div13, "act", "hazards");
    			attr_dev(div13, "class", "act-narrative svelte-1e5obqh");
    			attr_dev(div13, "legendhazards", "false");
    			add_location(div13, file$1, 181, 8, 9637);
    			attr_dev(hr2, "class", "svelte-1e5obqh");
    			add_location(hr2, file$1, 200, 16, 11138);
    			attr_dev(h22, "class", "svelte-1e5obqh");
    			add_location(h22, file$1, 201, 16, 11159);
    			add_location(p8, file$1, 202, 16, 11206);
    			add_location(strong2, file$1, 204, 32, 11320);
    			add_location(li9, file$1, 204, 20, 11308);
    			add_location(strong3, file$1, 205, 32, 11391);
    			add_location(li10, file$1, 205, 20, 11379);
    			add_location(ul1, file$1, 203, 16, 11283);
    			add_location(p9, file$1, 207, 16, 11471);
    			attr_dev(div14, "scene", "0");
    			attr_dev(div14, "force", "diagonal-up");
    			add_location(div14, file$1, 199, 12, 11084);
    			add_location(p10, file$1, 211, 16, 11886);
    			attr_dev(div15, "scene", "1");
    			attr_dev(div15, "force", "cluster-approach");
    			attr_dev(div15, "nodebase", "false");
    			attr_dev(div15, "nodearcs", "true");
    			attr_dev(div15, "nodeshapes", "false");
    			attr_dev(div15, "nodeshadow", "false");
    			add_location(div15, file$1, 210, 12, 11751);
    			add_location(p11, file$1, 215, 16, 12382);
    			attr_dev(div16, "act", "approach");
    			attr_dev(div16, "scene", "2");
    			attr_dev(div16, "force", "cluster-approach-wide");
    			attr_dev(div16, "nodebase", "false");
    			attr_dev(div16, "nodearcs", "true");
    			attr_dev(div16, "nodeshapes", "true");
    			attr_dev(div16, "nodeshadow", "false");
    			add_location(div16, file$1, 214, 12, 12226);
    			attr_dev(div17, "act", "approach");
    			attr_dev(div17, "class", "act-narrative svelte-1e5obqh");
    			attr_dev(div17, "legendhazards", "0.5");
    			attr_dev(div17, "legendapproach", "false");
    			add_location(div17, file$1, 198, 8, 10980);
    			attr_dev(hr3, "class", "svelte-1e5obqh");
    			add_location(hr3, file$1, 222, 16, 12857);
    			attr_dev(h23, "class", "svelte-1e5obqh");
    			add_location(h23, file$1, 223, 16, 12878);
    			add_location(strong4, file$1, 224, 82, 12983);
    			add_location(em5, file$1, 224, 171, 13072);
    			add_location(em6, file$1, 224, 256, 13157);
    			add_location(em7, file$1, 224, 333, 13234);
    			add_location(em8, file$1, 224, 363, 13264);
    			add_location(p12, file$1, 224, 16, 12917);
    			attr_dev(div18, "scene", "0");
    			attr_dev(div18, "force", "cluster-scale");
    			attr_dev(div18, "nodebase", "false");
    			attr_dev(div18, "nodearcs", "true");
    			attr_dev(div18, "nodeshapes", "true");
    			attr_dev(div18, "nodeshadow", "false");
    			attr_dev(div18, "nodesymbol", "false");
    			add_location(div18, file$1, 221, 12, 12706);
    			add_location(strong5, file$1, 228, 160, 13636);
    			add_location(p13, file$1, 228, 16, 13492);
    			attr_dev(div19, "scene", "1");
    			attr_dev(div19, "force", "cluster-scale");
    			attr_dev(div19, "nodebase", "false");
    			attr_dev(div19, "nodearcs", "true");
    			attr_dev(div19, "nodeshapes", "true");
    			attr_dev(div19, "nodeshadow", "true");
    			attr_dev(div19, "nodesymbol", "false");
    			add_location(div19, file$1, 227, 12, 13341);
    			attr_dev(div20, "act", "scale");
    			attr_dev(div20, "class", "act-narrative svelte-1e5obqh");
    			attr_dev(div20, "legendhazards", "0.35");
    			attr_dev(div20, "legendapproach", "0.65");
    			attr_dev(div20, "legendscale", "false");
    			add_location(div20, file$1, 220, 8, 12583);
    			attr_dev(hr4, "class", "svelte-1e5obqh");
    			add_location(hr4, file$1, 235, 16, 14135);
    			attr_dev(h24, "class", "svelte-1e5obqh");
    			add_location(h24, file$1, 236, 16, 14156);
    			attr_dev(div21, "scene", "0");
    			attr_dev(div21, "force", "right-line");
    			add_location(div21, file$1, 234, 12, 14081);
    			add_location(p14, file$1, 239, 16, 14288);
    			add_location(strong6, file$1, 240, 63, 14556);
    			add_location(em9, file$1, 240, 145, 14638);
    			add_location(em10, file$1, 240, 193, 14686);
    			add_location(p15, file$1, 240, 16, 14509);
    			attr_dev(div22, "scene", "1");
    			attr_dev(div22, "force", "cluster-concrete-abstract-right");
    			add_location(div22, file$1, 238, 12, 14213);
    			add_location(p16, file$1, 243, 16, 14820);
    			add_location(em11, file$1, 245, 143, 15163);
    			add_location(p17, file$1, 245, 16, 15036);
    			attr_dev(div23, "scene", "2");
    			attr_dev(div23, "force", "cluster-type");
    			add_location(div23, file$1, 242, 12, 14766);
    			attr_dev(div24, "act", "type");
    			attr_dev(div24, "class", "act-narrative svelte-1e5obqh");
    			attr_dev(div24, "legendhazards", "0.2");
    			attr_dev(div24, "legendapproach", "0.5");
    			attr_dev(div24, "legendscale", "0.8");
    			add_location(div24, file$1, 233, 8, 13964);
    			attr_dev(hr5, "class", "svelte-1e5obqh");
    			add_location(hr5, file$1, 253, 16, 15480);
    			attr_dev(h25, "class", "svelte-1e5obqh");
    			add_location(h25, file$1, 254, 16, 15501);
    			add_location(strong7, file$1, 255, 19, 15552);
    			attr_dev(a0, "href", "https://adaptgrampians.com.au/wp-content/uploads/2021/06/Grampians_Region_Climate_Adaptation_Strategy_Situation_Analysis_Final_.pdf");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$1, 255, 84, 15617);
    			attr_dev(a1, "href", "https://adaptgrampians.com.au/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$1, 255, 305, 15838);
    			add_location(strong8, file$1, 255, 491, 16024);
    			add_location(p18, file$1, 255, 16, 15549);
    			add_location(strong9, file$1, 256, 76, 16152);
    			add_location(p19, file$1, 256, 16, 16092);
    			add_location(strong10, file$1, 257, 166, 16478);
    			add_location(p20, file$1, 257, 16, 16328);
    			attr_dev(div25, "scene", "0");
    			attr_dev(div25, "force", "ring-focusArea");
    			add_location(div25, file$1, 252, 12, 15424);
    			attr_dev(div26, "act", "focusArea");
    			attr_dev(div26, "class", "act-narrative svelte-1e5obqh");
    			add_location(div26, file$1, 251, 8, 15363);
    			attr_dev(hr6, "class", "svelte-1e5obqh");
    			add_location(hr6, file$1, 263, 16, 16746);
    			attr_dev(h26, "class", "svelte-1e5obqh");
    			add_location(h26, file$1, 264, 16, 16767);
    			attr_dev(div27, "scene", "0");
    			attr_dev(div27, "force", "cluster-screening");
    			add_location(div27, file$1, 262, 12, 16687);
    			add_location(p21, file$1, 267, 16, 16889);
    			add_location(strong11, file$1, 269, 103, 17258);
    			add_location(strong12, file$1, 269, 282, 17437);
    			add_location(strong13, file$1, 269, 307, 17462);
    			add_location(strong14, file$1, 269, 340, 17495);
    			add_location(p22, file$1, 269, 16, 17171);
    			attr_dev(div28, "scene", "1");
    			attr_dev(div28, "force", "cluster-screening");
    			add_location(div28, file$1, 266, 12, 16831);
    			add_location(strong15, file$1, 272, 79, 17676);
    			add_location(p23, file$1, 272, 16, 17613);
    			add_location(em12, file$1, 273, 47, 17848);
    			add_location(p24, file$1, 273, 16, 17817);
    			attr_dev(div29, "scene", "2");
    			attr_dev(div29, "force", "cluster-screening");
    			add_location(div29, file$1, 271, 12, 17555);
    			attr_dev(div30, "act", "screening");
    			attr_dev(div30, "class", "act-narrative svelte-1e5obqh");
    			add_location(div30, file$1, 261, 8, 16627);
    			attr_dev(hr7, "class", "svelte-1e5obqh");
    			add_location(hr7, file$1, 279, 16, 18291);
    			attr_dev(h27, "class", "svelte-1e5obqh");
    			add_location(h27, file$1, 280, 16, 18312);
    			add_location(p25, file$1, 281, 16, 18369);
    			attr_dev(div31, "scene", "0");
    			attr_dev(div31, "force", "cluster-noregets-vs-others");
    			add_location(div31, file$1, 278, 12, 18224);
    			add_location(p26, file$1, 285, 16, 18586);
    			attr_dev(div32, "scene", "1");
    			attr_dev(div32, "force", "cluster-adaptation-criteria");
    			add_location(div32, file$1, 284, 12, 18518);
    			add_location(em13, file$1, 289, 495, 19466);
    			add_location(p27, file$1, 289, 16, 18987);
    			add_location(p28, file$1, 291, 16, 19542);
    			attr_dev(div33, "scene", "2");
    			attr_dev(div33, "force", "cluster-rating");
    			add_location(div33, file$1, 288, 12, 18932);
    			attr_dev(div34, "act", "rating");
    			attr_dev(div34, "class", "act-narrative svelte-1e5obqh");
    			add_location(div34, file$1, 277, 8, 18167);
    			attr_dev(hr8, "class", "svelte-1e5obqh");
    			add_location(hr8, file$1, 298, 16, 19795);
    			attr_dev(h28, "class", "svelte-1e5obqh");
    			add_location(h28, file$1, 299, 16, 19816);
    			add_location(strong16, file$1, 300, 69, 19921);
    			add_location(p29, file$1, 300, 16, 19868);
    			add_location(strong17, file$1, 302, 84, 20221);
    			add_location(p30, file$1, 302, 16, 20153);
    			add_location(li11, file$1, 305, 20, 20441);
    			add_location(li12, file$1, 306, 20, 20528);
    			add_location(li13, file$1, 307, 20, 20611);
    			add_location(li14, file$1, 308, 20, 20687);
    			add_location(ul2, file$1, 304, 16, 20416);
    			add_location(p31, file$1, 310, 16, 20815);
    			attr_dev(div35, "scene", "0");
    			attr_dev(div35, "force", "ring-mid");
    			add_location(div35, file$1, 297, 12, 19746);
    			attr_dev(div36, "act", "beyond");
    			attr_dev(div36, "class", "act-narrative svelte-1e5obqh");
    			add_location(div36, file$1, 296, 8, 19689);
    			attr_dev(div37, "class", "narrative-wrapper svelte-1e5obqh");
    			add_location(div37, file$1, 163, 4, 8002);
    			attr_dev(div38, "class", "action-vis-wrapper svelte-1e5obqh");
    			add_location(div38, file$1, 318, 8, 21473);
    			attr_dev(div39, "class", "vis-wrapper svelte-1e5obqh");
    			add_location(div39, file$1, 317, 4, 21437);
    			attr_dev(div40, "class", "content-wrapper svelte-1e5obqh");
    			add_location(div40, file$1, 161, 0, 7930);
    			add_location(p32, file$1, 327, 8, 21662);
    			attr_dev(div41, "class", "print-message svelte-1e5obqh");
    			add_location(div41, file$1, 326, 4, 21624);
    			attr_dev(div42, "class", "print-wrapper svelte-1e5obqh");
    			add_location(div42, file$1, 325, 0, 21590);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			mount_component(logo, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, h1);
    			append_dev(h1, span0);
    			append_dev(h1, br0);
    			append_dev(h1, t2);
    			append_dev(h1, br1);
    			append_dev(h1, t3);
    			append_dev(h1, span1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div2, p0);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, ul0);
    			append_dev(ul0, li0);
    			append_dev(ul0, t9);
    			append_dev(ul0, li1);
    			append_dev(ul0, t11);
    			append_dev(ul0, li2);
    			append_dev(ul0, t13);
    			append_dev(ul0, li3);
    			append_dev(ul0, t15);
    			append_dev(ul0, li4);
    			append_dev(ul0, t17);
    			append_dev(ul0, li5);
    			append_dev(ul0, t19);
    			append_dev(ul0, li6);
    			append_dev(ul0, t21);
    			append_dev(ul0, li7);
    			append_dev(ul0, t23);
    			append_dev(ul0, li8);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div40, anchor);
    			append_dev(div40, div37);
    			append_dev(div37, div9);
    			append_dev(div9, div6);
    			append_dev(div6, hr0);
    			append_dev(div6, t26);
    			append_dev(div6, h20);
    			append_dev(div6, t28);
    			append_dev(div6, p1);
    			append_dev(p1, t29);
    			html_tag.m(raw0_value, p1);
    			append_dev(p1, t30);
    			append_dev(p1, span2);
    			append_dev(p1, t32);
    			append_dev(div9, t33);
    			append_dev(div9, div7);
    			append_dev(div7, p2);
    			append_dev(p2, t34);
    			html_tag_1.m(raw1_value, p2);
    			append_dev(p2, t35);
    			append_dev(p2, em0);
    			append_dev(p2, t37);
    			append_dev(div9, t38);
    			append_dev(div9, div8);
    			append_dev(div8, p3);
    			append_dev(p3, t39);
    			append_dev(p3, em1);
    			append_dev(p3, t41);
    			append_dev(p3, em2);
    			append_dev(p3, t43);
    			append_dev(p3, em3);
    			append_dev(div8, t45);
    			append_dev(div8, p4);
    			append_dev(div37, t47);
    			append_dev(div37, div13);
    			append_dev(div13, div10);
    			append_dev(div10, hr1);
    			append_dev(div10, t48);
    			append_dev(div10, h21);
    			append_dev(div10, t50);
    			append_dev(div10, p5);
    			append_dev(p5, t51);
    			append_dev(p5, strong0);
    			append_dev(p5, t53);
    			append_dev(div13, t54);
    			append_dev(div13, div11);
    			append_dev(div11, p6);
    			append_dev(p6, t55);
    			append_dev(p6, em4);
    			append_dev(p6, t57);
    			append_dev(p6, strong1);
    			append_dev(p6, t59);
    			append_dev(div13, t60);
    			append_dev(div13, div12);
    			append_dev(div12, p7);
    			append_dev(p7, t61);
    			append_dev(p7, span3);
    			append_dev(p7, t63);
    			append_dev(div37, t64);
    			append_dev(div37, div17);
    			append_dev(div17, div14);
    			append_dev(div14, hr2);
    			append_dev(div14, t65);
    			append_dev(div14, h22);
    			append_dev(div14, t67);
    			append_dev(div14, p8);
    			append_dev(div14, t69);
    			append_dev(div14, ul1);
    			append_dev(ul1, li9);
    			append_dev(li9, t70);
    			append_dev(li9, strong2);
    			append_dev(li9, t72);
    			append_dev(ul1, t73);
    			append_dev(ul1, li10);
    			append_dev(li10, t74);
    			append_dev(li10, strong3);
    			append_dev(div14, t76);
    			append_dev(div14, p9);
    			append_dev(div17, t78);
    			append_dev(div17, div15);
    			append_dev(div15, p10);
    			append_dev(div17, t80);
    			append_dev(div17, div16);
    			append_dev(div16, p11);
    			append_dev(div37, t82);
    			append_dev(div37, div20);
    			append_dev(div20, div18);
    			append_dev(div18, hr3);
    			append_dev(div18, t83);
    			append_dev(div18, h23);
    			append_dev(div18, t85);
    			append_dev(div18, p12);
    			append_dev(p12, t86);
    			append_dev(p12, strong4);
    			append_dev(p12, t88);
    			append_dev(p12, em5);
    			append_dev(p12, t90);
    			append_dev(p12, em6);
    			append_dev(p12, t92);
    			append_dev(p12, em7);
    			append_dev(p12, t94);
    			append_dev(p12, em8);
    			append_dev(p12, t96);
    			append_dev(div20, t97);
    			append_dev(div20, div19);
    			append_dev(div19, p13);
    			append_dev(p13, t98);
    			append_dev(p13, strong5);
    			append_dev(p13, t100);
    			append_dev(div37, t101);
    			append_dev(div37, div24);
    			append_dev(div24, div21);
    			append_dev(div21, hr4);
    			append_dev(div21, t102);
    			append_dev(div21, h24);
    			append_dev(div24, t104);
    			append_dev(div24, div22);
    			append_dev(div22, p14);
    			append_dev(div22, t106);
    			append_dev(div22, p15);
    			append_dev(p15, t107);
    			append_dev(p15, strong6);
    			append_dev(p15, t109);
    			append_dev(p15, em9);
    			append_dev(p15, t111);
    			append_dev(p15, em10);
    			append_dev(p15, t113);
    			append_dev(div24, t114);
    			append_dev(div24, div23);
    			append_dev(div23, p16);
    			append_dev(div23, t116);
    			append_dev(div23, p17);
    			append_dev(p17, t117);
    			append_dev(p17, em11);
    			append_dev(p17, t119);
    			append_dev(div23, t120);
    			mount_component(switch_1, div23, null);
    			append_dev(div37, t121);
    			append_dev(div37, div26);
    			append_dev(div26, div25);
    			append_dev(div25, hr5);
    			append_dev(div25, t122);
    			append_dev(div25, h25);
    			append_dev(div25, t124);
    			append_dev(div25, p18);
    			append_dev(p18, strong7);
    			append_dev(p18, t126);
    			append_dev(p18, a0);
    			append_dev(p18, t128);
    			append_dev(p18, a1);
    			append_dev(p18, t130);
    			append_dev(p18, strong8);
    			append_dev(p18, t132);
    			append_dev(div25, t133);
    			append_dev(div25, p19);
    			append_dev(p19, t134);
    			append_dev(p19, strong9);
    			append_dev(p19, t136);
    			append_dev(div25, t137);
    			append_dev(div25, p20);
    			append_dev(p20, t138);
    			append_dev(p20, strong10);
    			append_dev(div37, t140);
    			append_dev(div37, div30);
    			append_dev(div30, div27);
    			append_dev(div27, hr6);
    			append_dev(div27, t141);
    			append_dev(div27, h26);
    			append_dev(div30, t143);
    			append_dev(div30, div28);
    			append_dev(div28, p21);
    			append_dev(div28, t145);
    			append_dev(div28, p22);
    			append_dev(p22, t146);
    			append_dev(p22, strong11);
    			append_dev(p22, t148);
    			append_dev(p22, strong12);
    			append_dev(p22, t150);
    			append_dev(p22, strong13);
    			append_dev(p22, t152);
    			append_dev(p22, strong14);
    			append_dev(p22, t154);
    			append_dev(div30, t155);
    			append_dev(div30, div29);
    			append_dev(div29, p23);
    			append_dev(p23, t156);
    			append_dev(p23, strong15);
    			append_dev(p23, t158);
    			append_dev(div29, t159);
    			append_dev(div29, p24);
    			append_dev(p24, t160);
    			append_dev(p24, em12);
    			append_dev(p24, t162);
    			append_dev(div37, t163);
    			append_dev(div37, div34);
    			append_dev(div34, div31);
    			append_dev(div31, hr7);
    			append_dev(div31, t164);
    			append_dev(div31, h27);
    			append_dev(div31, t166);
    			append_dev(div31, p25);
    			append_dev(div34, t168);
    			append_dev(div34, div32);
    			append_dev(div32, p26);
    			append_dev(div34, t170);
    			append_dev(div34, div33);
    			append_dev(div33, p27);
    			append_dev(p27, t171);
    			append_dev(p27, em13);
    			append_dev(div33, t173);
    			append_dev(div33, p28);
    			append_dev(div37, t175);
    			append_dev(div37, div36);
    			append_dev(div36, div35);
    			append_dev(div35, hr8);
    			append_dev(div35, t176);
    			append_dev(div35, h28);
    			append_dev(div35, t178);
    			append_dev(div35, p29);
    			append_dev(p29, t179);
    			append_dev(p29, strong16);
    			append_dev(p29, t181);
    			append_dev(div35, t182);
    			append_dev(div35, p30);
    			append_dev(p30, t183);
    			append_dev(p30, strong17);
    			append_dev(p30, t185);
    			append_dev(div35, t186);
    			append_dev(div35, ul2);
    			append_dev(ul2, li11);
    			append_dev(ul2, t188);
    			append_dev(ul2, li12);
    			append_dev(ul2, t190);
    			append_dev(ul2, li13);
    			append_dev(ul2, t192);
    			append_dev(ul2, li14);
    			append_dev(div35, t194);
    			append_dev(div35, p31);
    			append_dev(div40, t196);
    			append_dev(div40, div39);
    			append_dev(div39, div38);
    			mount_component(actionvis, div38, null);
    			insert_dev(target, t197, anchor);
    			insert_dev(target, div42, anchor);
    			append_dev(div42, div41);
    			append_dev(div41, p32);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li1, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li2, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li3, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li4, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li5, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li6, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li7, "click", /*scrollTo*/ ctx[2], false, false, false),
    					listen_dev(li8, "click", /*scrollTo*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$data*/ 2) && raw0_value !== (raw0_value = /*$data*/ ctx[1].stats.actions.total + "")) html_tag.p(raw0_value);
    			if ((!current || dirty & /*$data*/ 2) && raw1_value !== (raw1_value = /*$data*/ ctx[1].stats.actions.total + "")) html_tag_1.p(raw1_value);
    			const switch_1_changes = {};

    			if (!updating_value && dirty & /*flowDiagramState*/ 1) {
    				updating_value = true;
    				switch_1_changes.value = /*flowDiagramState*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			switch_1.$set(switch_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(switch_1.$$.fragment, local);
    			transition_in(actionvis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(switch_1.$$.fragment, local);
    			transition_out(actionvis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(logo);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div40);
    			destroy_component(switch_1);
    			destroy_component(actionvis);
    			if (detaching) detach_dev(t197);
    			if (detaching) detach_dev(div42);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(4, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Actions', slots, []);

    	const scrollTo = function () {
    		document.querySelector(`div[act=${this.getAttribute('actName')}]`).scrollIntoView({ behavior: 'smooth' });
    	};

    	const updateScene = el => {
    		// Update the scene number and node forces
    		if (el.getAttribute('scene')) set_store_value(ui, $ui.state.actionVis.scene = +el.getAttribute('scene'), $ui);

    		if (el.getAttribute('force')) set_store_value(ui, $ui.state.actionVis.nodes.force = el.getAttribute('force'), $ui);

    		// Change node marker state
    		if (el.getAttribute('nodeBase')) set_store_value(ui, $ui.state.actionVis.nodes.base = el.getAttribute('nodeBase') === "true" ? true : false, $ui);

    		if (el.getAttribute('nodeArcs')) set_store_value(ui, $ui.state.actionVis.nodes.arcs = el.getAttribute('nodeArcs') === "true" ? true : false, $ui);
    		if (el.getAttribute('nodeShapes')) set_store_value(ui, $ui.state.actionVis.nodes.shapes = el.getAttribute('nodeShapes') === "true" ? true : false, $ui);
    		if (el.getAttribute('nodeSymbol')) set_store_value(ui, $ui.state.actionVis.nodes.symbols = el.getAttribute('nodeSymbol') === "true" ? true : false, $ui);
    		if (el.getAttribute('nodeShadow')) set_store_value(ui, $ui.state.actionVis.nodes.shadow = el.getAttribute('nodeShadow') === "true" ? true : false, $ui);
    	};

    	const updateAct = el => {
    		// Update the act
    		if (el.getAttribute('act')) set_store_value(ui, $ui.state.actionVis.act = el.getAttribute('act'), $ui);

    		// Change the legend view
    		if (el.getAttribute('legendHazards')) set_store_value(
    			ui,
    			$ui.state.actionVis.legend.hazards = el.getAttribute('legendHazards') === "false"
    			? false
    			: +el.getAttribute('legendHazards'),
    			$ui
    		);

    		if (el.getAttribute('legendApproach')) set_store_value(
    			ui,
    			$ui.state.actionVis.legend.approach = el.getAttribute('legendApproach') === "false"
    			? false
    			: +el.getAttribute('legendApproach'),
    			$ui
    		);

    		if (el.getAttribute('legendScale')) set_store_value(
    			ui,
    			$ui.state.actionVis.legend.scale = el.getAttribute('legendScale') === "false"
    			? false
    			: +el.getAttribute('legendScale'),
    			$ui
    		);

    		// Reset focus area dorce
    		set_store_value(ui, $ui.state.actionVis.nodes.focusArea = null, $ui);

    		$$invalidate(0, flowDiagramState = null);
    	};

    	// Add scroll trigger functionlity after DOM is mounted    
    	onMount(() => {
    		const debug = {
    			actPin: false,
    			actAppear: false,
    			scene: false
    		};

    		// ScrollTrigger to pin page content wrapper and page wrappers (no tweens)
    		gsapWithCSS.registerPlugin(ScrollTrigger);

    		// 1. "Acts": pin each narrative "page" (with associated background visual):  
    		const actData = document.querySelectorAll('.act-narrative');

    		actData.forEach((el, i) => {
    			// Trigger to pin narrative section to top of page while scenes enter/play
    			gsapWithCSS.to(el, {
    				scrollTrigger: {
    					trigger: el,
    					start: "top 5%",
    					end: "bottom 5%",
    					pin: true,
    					scrub: true,
    					markers: debug.actPin
    				}
    			});

    			// Trigger to call onStart/onReverseComplete to update state when act appears on screen (bottom)
    			gsapWithCSS.to(el, {
    				scrollTrigger: {
    					trigger: el,
    					start: "top bottom",
    					end: "top bottom",
    					scrub: true,
    					markers: debug.actAppear
    				},
    				onStart: () => updateAct(el),
    				onReverseComplete: () => {
    					const prevEl = i === 0 ? actData[0] : actData[i - 1];
    					updateAct(prevEl);
    					const lastSceneEl = prevEl.lastChild;
    					updateScene(lastSceneEl);
    				}
    			});
    		});

    		// 2. "Scenes": are parts of "Acts" and are named bysequential integer
    		for (const el of actData) {
    			const sections = Array.from(el.children);

    			sections.forEach((el, i) => {
    				gsapWithCSS.fromTo(el, { opacity: 0 }, {
    					scrollTrigger: {
    						trigger: el,
    						start: i == 0 ? "top 90%" : "top 50%",
    						end: i == 0 ? "+=80%" : "+=25%",
    						scrub: true,
    						markers: debug.scene
    					},
    					opacity: 1,
    					onStart: () => updateScene(el),
    					onReverseComplete: () => updateScene(i === 0 ? sections[0] : sections[i - 1])
    				});
    			});
    		}
    	});

    	// Setup the flow diagram switch function
    	let flowDiagramState = null;

    	const flowDiagramOptions = ['Abstract to concrete', 'Action type flow'];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Actions> was created with unknown prop '${key}'`);
    	});

    	function switch_1_value_binding(value) {
    		flowDiagramState = value;
    		$$invalidate(0, flowDiagramState);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		gsap: gsapWithCSS,
    		ScrollTrigger,
    		ui,
    		data,
    		Logo,
    		ActionVis,
    		Switch,
    		scrollTo,
    		updateScene,
    		updateAct,
    		flowDiagramState,
    		flowDiagramOptions,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('flowDiagramState' in $$props) $$invalidate(0, flowDiagramState = $$props.flowDiagramState);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ui, flowDiagramState*/ 17) {
    			{
    				if ($ui.state.actionVis.act === 'type' && flowDiagramState === flowDiagramOptions[0]) {
    					set_store_value(ui, $ui.state.actionVis.nodes.force = 'cluster-concrete-abstract', $ui);
    					set_store_value(ui, $ui.state.actionVis.scene = 3, $ui);
    				} else if ($ui.state.actionVis.act === 'type' && flowDiagramState === flowDiagramOptions[1]) {
    					set_store_value(ui, $ui.state.actionVis.nodes.force = 'cluster-type', $ui);
    					set_store_value(ui, $ui.state.actionVis.scene = 2, $ui);
    				}
    			}
    		}
    	};

    	return [
    		flowDiagramState,
    		$data,
    		scrollTo,
    		flowDiagramOptions,
    		$ui,
    		switch_1_value_binding
    	];
    }

    class Actions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Actions",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.48.0 */

    const { console: console_1 } = globals;
    const file = "src/App.svelte";

    // (234:43) 
    function create_if_block_2(ctx) {
    	let postcards;
    	let current;
    	postcards = new Postcards({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(postcards.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(postcards, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(postcards.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(postcards.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(postcards, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(234:43) ",
    		ctx
    	});

    	return block;
    }

    // (233:41) 
    function create_if_block_1(ctx) {
    	let actions;
    	let current;
    	actions = new Actions({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(233:41) ",
    		ctx
    	});

    	return block;
    }

    // (232:8) {#if  $ui.page === 'adaptation'}
    function create_if_block(ctx) {
    	let adaptation;
    	let current;
    	adaptation = new Adaptation({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(adaptation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adaptation, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adaptation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adaptation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adaptation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(232:8) {#if  $ui.page === 'adaptation'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let section0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let button;
    	let t1;
    	let section1;
    	let div14;
    	let div13;
    	let div12;
    	let div4;
    	let div1;
    	let h1;
    	let t3;
    	let div0;
    	let t4;
    	let div3;
    	let div2;
    	let logo;
    	let t5;
    	let div11;
    	let div6;
    	let div5;
    	let t6;
    	let a0;
    	let t8;
    	let div8;
    	let div7;
    	let t9;
    	let a1;
    	let t11;
    	let div10;
    	let div9;
    	let t12;
    	let a2;
    	let t14;
    	let h2;
    	let t15;
    	let br0;
    	let t16;
    	let span;
    	let br1;
    	let t18;
    	let t19;
    	let section2;
    	let div16;
    	let div15;
    	let t20;
    	let div18;
    	let div17;
    	let t21;
    	let div20;
    	let div19;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$ui*/ ctx[3].page === 'adaptation') return 0;
    		if (/*$ui*/ ctx[3].page === 'actions') return 1;
    		if (/*$ui*/ ctx[3].page === 'postcards') return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	logo = new Logo({ props: { type: 'width' }, $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			section0 = element("section");
    			if (if_block) if_block.c();
    			t0 = space();
    			button = element("button");
    			t1 = space();
    			section1 = element("section");
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Hepburn Shire —— guide to adaptation action";
    			t3 = space();
    			div0 = element("div");
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(logo.$$.fragment);
    			t5 = space();
    			div11 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			t6 = space();
    			a0 = element("a");
    			a0.textContent = "context + concepts";
    			t8 = space();
    			div8 = element("div");
    			div7 = element("div");
    			t9 = space();
    			a1 = element("a");
    			a1.textContent = "action collection";
    			t11 = space();
    			div10 = element("div");
    			div9 = element("div");
    			t12 = space();
    			a2 = element("a");
    			a2.textContent = "action postcards";
    			t14 = space();
    			h2 = element("h2");
    			t15 = text$1("Climate change");
    			br0 = element("br");
    			t16 = space();
    			span = element("span");
    			span.textContent = "adaptation";
    			br1 = element("br");
    			t18 = text$1("\n                        in Hepburn");
    			t19 = space();
    			section2 = element("section");
    			div16 = element("div");
    			div15 = element("div");
    			t20 = space();
    			div18 = element("div");
    			div17 = element("div");
    			t21 = space();
    			div20 = element("div");
    			div19 = element("div");
    			attr_dev(section0, "class", "chapters");
    			add_location(section0, file, 230, 4, 9599);
    			attr_dev(button, "class", "back svelte-17i1sst");
    			attr_dev(button, "aria-label", "Back to homepage");
    			add_location(button, file, 237, 4, 9845);
    			attr_dev(h1, "class", "frame__title svelte-17i1sst");
    			add_location(h1, file, 246, 28, 10240);
    			attr_dev(div0, "class", "frame__links svelte-17i1sst");
    			add_location(div0, file, 247, 28, 10355);
    			attr_dev(div1, "class", "frame__title-wrapper svelte-17i1sst");
    			add_location(div1, file, 245, 24, 10177);
    			attr_dev(div2, "class", "logo-container");
    			add_location(div2, file, 250, 28, 10508);
    			attr_dev(div3, "class", "frame__logo-wrapper svelte-17i1sst");
    			add_location(div3, file, 249, 24, 10444);
    			attr_dev(div4, "class", "frame svelte-17i1sst");
    			add_location(div4, file, 244, 20, 10133);
    			attr_dev(div5, "class", "hero__img svelte-17i1sst");
    			set_style(div5, "background-image", "url(https://hepburnznet.org.au/wp-content/uploads/2020/06/Zero-Net-Emissions-About-2.jpg)");
    			add_location(div5, file, 259, 28, 10816);
    			attr_dev(a0, "class", "hero__menu-label svelte-17i1sst");
    			attr_dev(a0, "name", "adaptation");
    			add_location(a0, file, 260, 28, 10991);
    			attr_dev(div6, "class", "hero__menu-item");
    			add_location(div6, file, 258, 24, 10758);
    			attr_dev(div7, "class", "hero__img svelte-17i1sst");
    			set_style(div7, "background-image", "url(https://hepburnznet.org.au/wp-content/uploads/2020/06/Zero-Net-Emissions-Hepburn-Wind-Farm-Home-3.jpg)");
    			add_location(div7, file, 263, 28, 11226);
    			attr_dev(a1, "class", "hero__menu-label svelte-17i1sst");
    			attr_dev(a1, "name", "actions");
    			add_location(a1, file, 264, 28, 11418);
    			attr_dev(div8, "class", "hero__menu-item");
    			add_location(div8, file, 262, 24, 11168);
    			attr_dev(div9, "class", "hero__img svelte-17i1sst");
    			set_style(div9, "background-image", "url(https://hepburnznet.org.au/wp-content/uploads/2020/08/Zero-Net-Emissions-Hepburn-Wind-Community-Hero.jpg)");
    			add_location(div9, file, 267, 28, 11650);
    			attr_dev(a2, "class", "hero__menu-label svelte-17i1sst");
    			attr_dev(a2, "name", "postcards");
    			add_location(a2, file, 268, 28, 11845);
    			attr_dev(div10, "class", "hero__menu-item");
    			add_location(div10, file, 266, 24, 11592);
    			attr_dev(div11, "class", "hero__menu svelte-17i1sst");
    			add_location(div11, file, 257, 20, 10709);
    			add_location(br0, file, 273, 38, 12106);
    			attr_dev(span, "class", "highlight svelte-17i1sst");
    			add_location(span, file, 274, 24, 12135);
    			add_location(br1, file, 274, 67, 12178);
    			attr_dev(h2, "class", "hero__title svelte-17i1sst");
    			add_location(h2, file, 272, 20, 12043);
    			attr_dev(div12, "class", "hero__container svelte-17i1sst");
    			add_location(div12, file, 243, 16, 10083);
    			attr_dev(div13, "class", "content__reverse");
    			add_location(div13, file, 242, 12, 10036);
    			attr_dev(div14, "class", "content__move svelte-17i1sst");
    			add_location(div14, file, 241, 8, 9996);
    			attr_dev(section1, "class", "homepage svelte-17i1sst");
    			add_location(section1, file, 240, 4, 9961);
    			attr_dev(div15, "class", "overlay__inner overlay__inner--color-1 svelte-17i1sst");
    			add_location(div15, file, 284, 12, 12430);
    			attr_dev(div16, "class", "overlay overlay--1 svelte-17i1sst");
    			add_location(div16, file, 283, 8, 12385);
    			attr_dev(div17, "class", "overlay__inner overlay__inner--color-2 svelte-17i1sst");
    			add_location(div17, file, 287, 12, 12557);
    			attr_dev(div18, "class", "overlay overlay--2 svelte-17i1sst");
    			add_location(div18, file, 286, 8, 12512);
    			attr_dev(div19, "class", "overlay__inner overlay__inner--color-3 svelte-17i1sst");
    			add_location(div19, file, 290, 12, 12684);
    			attr_dev(div20, "class", "overlay overlay--3 svelte-17i1sst");
    			add_location(div20, file, 289, 8, 12639);
    			attr_dev(section2, "class", "transitions svelte-17i1sst");
    			add_location(section2, file, 282, 4, 12345);
    			attr_dev(main, "id", "app-container");
    			attr_dev(main, "class", "svelte-17i1sst");
    			add_location(main, file, 228, 0, 9514);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, section0);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(section0, null);
    			}

    			append_dev(main, t0);
    			append_dev(main, button);
    			append_dev(main, t1);
    			append_dev(main, section1);
    			append_dev(section1, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h1);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			mount_component(logo, div2, null);
    			append_dev(div12, t5);
    			append_dev(div12, div11);
    			append_dev(div11, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t6);
    			append_dev(div6, a0);
    			append_dev(div11, t8);
    			append_dev(div11, div8);
    			append_dev(div8, div7);
    			append_dev(div8, t9);
    			append_dev(div8, a1);
    			append_dev(div11, t11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div10, t12);
    			append_dev(div10, a2);
    			append_dev(div12, t14);
    			append_dev(div12, h2);
    			append_dev(h2, t15);
    			append_dev(h2, br0);
    			append_dev(h2, t16);
    			append_dev(h2, span);
    			append_dev(h2, br1);
    			append_dev(h2, t18);
    			append_dev(main, t19);
    			append_dev(main, section2);
    			append_dev(section2, div16);
    			append_dev(div16, div15);
    			append_dev(section2, t20);
    			append_dev(section2, div18);
    			append_dev(div18, div17);
    			append_dev(section2, t21);
    			append_dev(section2, div20);
    			append_dev(div20, div19);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button,
    						"click",
    						function () {
    							if (is_function(/*showMenu*/ ctx[1])) /*showMenu*/ ctx[1].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a0,
    						"click",
    						function () {
    							if (is_function(/*showPage*/ ctx[0])) /*showPage*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a0,
    						"mouseenter",
    						function () {
    							if (is_function(/*onEnterHoverFn*/ ctx[2])) /*onEnterHoverFn*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a1,
    						"click",
    						function () {
    							if (is_function(/*showPage*/ ctx[0])) /*showPage*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a1,
    						"mouseenter",
    						function () {
    							if (is_function(/*onEnterHoverFn*/ ctx[2])) /*onEnterHoverFn*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a2,
    						"click",
    						function () {
    							if (is_function(/*showPage*/ ctx[0])) /*showPage*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						a2,
    						"mouseenter",
    						function () {
    							if (is_function(/*onEnterHoverFn*/ ctx[2])) /*onEnterHoverFn*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(section0, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			destroy_component(logo);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $ui;
    	let $data;
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, $$value => $$invalidate(3, $ui = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(8, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { actionData } = $$props;
    	let { schemaData } = $$props;
    	let { climateData } = $$props;
    	let { queryParams = {} } = $$props;

    	// Store loaded action data and schema
    	set_store_value(data, $data.actions = actionData["Adaptation actions"], $data);

    	set_store_value(data, $data.stakeholders = actionData["Stakeholders"], $data);
    	set_store_value(data, $data.references = actionData["References"], $data);
    	set_store_value(data, $data.schema = schemaData, $data);
    	set_store_value(data, $data.climate = climateData, $data);

    	// Calc and store data stats
    	set_store_value(
    		data,
    		$data.stats.actions = {
    			total: $data.actions.length,
    			noRegrets: $data.actions.filter(d => d["Screening outcome"] === "=> No regrets").length,
    			byHazard: (function () {
    				const obj = {};

    				for (const d of $data.schema.hazards.data) {
    					obj[d.Hazard] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})(),
    			byHazardEvent: (function () {
    				const obj = {};

    				for (const d of $data.schema.hazardEvents.data) {
    					obj[d["Hazard event"]] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})(),
    			byApproach: (function () {
    				const obj = {};

    				for (const d of $data.schema.adaptationApproaches.data) {
    					obj[d["Adaptation and risk approach"]] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})(),
    			byApproachType: (function () {
    				const obj = { "Improve risk and resilience": 0 };

    				const approachThemes = [
    					...new Set($data.schema.adaptationApproaches.data.map(d => d["Approach theme"]))
    				];

    				for (const theme of approachThemes) {
    					obj[theme] = 0;
    				}

    				for (const d of $data.actions) {
    					if ([...new Set(d["Linked approach theme"])].length === 1) obj[d["Linked approach theme"][0]]++;
    					if ([...new Set(d["Linked approach theme"])].length === 2) obj["Improve risk and resilience"]++;
    				}

    				return obj;
    			})(),
    			byType: (function () {
    				const obj = {};

    				for (const d of $data.schema.actionTypes.data) {
    					obj[d["Type"]] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})(),
    			byFocus: (function () {
    				const obj = {};

    				for (const d of $data.schema.adaptationFocus.data) {
    					obj[d["Focus area"]] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})(),
    			byScale: (function () {
    				const obj = {};

    				for (const d of $data.schema.actionScale.data) {
    					obj[d["Scale"]] = !d["Linked adaptation actions"]
    					? 0
    					: d["Linked adaptation actions"].length;
    				}

    				return obj;
    			})()
    		},
    		$data
    	);

    	console.log('Data:', $data);

    	// Homepage interactions (applied onMount)
    	let showPage, showMenu, onEnterHoverFn;

    	onMount(async () => {
    		// 1. Add element references
    		set_store_value(ui, $ui.el.app = document.getElementById('app-container'), $ui);

    		set_store_value(ui, $ui.el.homeContainer = document.querySelector('.homepage'), $ui);
    		set_store_value(ui, $ui.el.pageContainer = document.querySelector('.content--container'), $ui);
    		set_store_value(ui, $ui.el.homeMenuItems = document.querySelectorAll('.hero__menu-item'), $ui);
    		set_store_value(ui, $ui.el.homeTitle = document.querySelector('.hero__title'), $ui);

    		// 2. Typography: splitting le // remainingtters for animation 
    		charming($ui.el.homeTitle);

    		let titleLetters = [...$ui.el.homeTitle.querySelectorAll('span')];
    		titleLetters.sort(() => Math.round(Math.random()) - 0.5);
    		let letters = titleLetters.filter(_ => Math.random() < .5); // some random letters
    		let otherletters = titleLetters.filter(el => letters.indexOf(el) < 0); // remaining

    		// 3. Revealer transitions and animations 
    		const revealer = new Revealer($ui.el.homeContainer, { angle: 3 });

    		const transitions = [];
    		const overlayElems = [...document.querySelectorAll('.overlay')];
    		const transitionsTotal = overlayElems.length;
    		overlayElems.forEach((overlay, i) => transitions.push(new Revealer(overlay, { angle: i % 2 === 0 ? -3 : 3 })));

    		// Interactions
    		// b. Animate to content page
    		$$invalidate(0, showPage = function (page) {
    			window.scrollTo({ top: 0, behavior: 'smooth' });

    			set_store_value(
    				ui,
    				$ui.page = typeof this !== 'undefined'
    				? this.getAttribute('name')
    				: page,
    				$ui
    			);

    			$ui.el.app.classList.add('overflow');
    			$ui.el.homeContainer.classList.add('content--hidden');
    			const ease = Expo.easeInOut;
    			const duration = 1.2;

    			set_store_value(
    				ui,
    				$ui.animation.pageToggleTimeline = gsapWithCSS$1.timeline().// Animate overlay page elements (optional)
    				to(
    					$ui.el.homeMenuItems,
    					{
    						duration,
    						ease,
    						y: -150,
    						scaleY: 1.1,
    						opacity: 0,
    						stagger: { amount: 0.04 }
    					},
    					0
    				).to(
    					otherletters,
    					{
    						duration: duration * 0.8,
    						ease,
    						yPercent: -100,
    						scaleX: 0.8,
    						scaleY: 1.5,
    						opacity: 0,
    						stagger: { amount: 0.04 }
    					},
    					0
    				).// "Unreveal effect" (inner moves to one direction and reverse moves to the opposite one)
    				to(revealer.DOM.inner, { duration, ease, yPercent: -100 }, 0).to(revealer.DOM.reverse, { duration, ease, yPercent: 100 }, 0),
    				$ui
    			);

    			// Animate transitions
    			let t = 0;

    			for (let i = 0; i <= transitionsTotal - 1; ++i) {
    				t = 0.2 * i + 0.2;
    				$ui.animation.pageToggleTimeline.to(transitions[transitionsTotal - 1 - i].DOM.inner, { duration, ease, yPercent: -100 }, t);
    			}
    		});

    		// c. Animate back to home page menu
    		$$invalidate(1, showMenu = () => {
    			if ($ui.state.postcards.view === 'postcard') {
    				set_store_value(ui, $ui.state.postcards.view = 'table', $ui);
    			} else {
    				$ui.el.app.classList.remove('overflow');
    				$ui.el.homeContainer.classList.remove('content--hidden'); // Pointer events related class
    				$ui.animation.pageToggleTimeline.reverse();
    			}
    		});

    		// d. Hover animation on the hero "enter" element
    		let enterHoverAnimationRunning = false;

    		$$invalidate(2, onEnterHoverFn = () => {
    			if (enterHoverAnimationRunning) return false;
    			enterHoverAnimationRunning = true;
    			letters = titleLetters.filter(_ => Math.random() < .5);
    			otherletters = titleLetters.filter(el => letters.indexOf(el) < 0);

    			gsapWithCSS$1.timeline({
    				onComplete: () => enterHoverAnimationRunning = false
    			}).to(letters, {
    				duration: 0.2,
    				ease: Quad$1.easeIn,
    				yPercent: 100,
    				opacity: 0,
    				stagger: { each: 0.04 }
    			}).to(letters, {
    				duration: 0.6,
    				ease: Quint.easeOut,
    				yPercent: 0,
    				opacity: 1,
    				stagger: { each: 0.08, delay: 0.2 }
    			});
    		});

    		// Set page view if set via query param
    		if (queryParams.get('page')) showPage(queryParams.get('page'));

    		if (queryParams.get('postcards')) set_store_value(ui, $ui.state.postcards.view = queryParams.get('postcards'), $ui);
    	});

    	const writable_props = ['actionData', 'schemaData', 'climateData', 'queryParams'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('actionData' in $$props) $$invalidate(4, actionData = $$props.actionData);
    		if ('schemaData' in $$props) $$invalidate(5, schemaData = $$props.schemaData);
    		if ('climateData' in $$props) $$invalidate(6, climateData = $$props.climateData);
    		if ('queryParams' in $$props) $$invalidate(7, queryParams = $$props.queryParams);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		onMount,
    		ui,
    		data,
    		gsap: gsapWithCSS$1,
    		Quad: Quad$1,
    		Quint,
    		Expo,
    		Revealer,
    		Postcards,
    		Adaptation,
    		Actions,
    		Logo,
    		actionData,
    		schemaData,
    		climateData,
    		queryParams,
    		showPage,
    		showMenu,
    		onEnterHoverFn,
    		$ui,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('actionData' in $$props) $$invalidate(4, actionData = $$props.actionData);
    		if ('schemaData' in $$props) $$invalidate(5, schemaData = $$props.schemaData);
    		if ('climateData' in $$props) $$invalidate(6, climateData = $$props.climateData);
    		if ('queryParams' in $$props) $$invalidate(7, queryParams = $$props.queryParams);
    		if ('showPage' in $$props) $$invalidate(0, showPage = $$props.showPage);
    		if ('showMenu' in $$props) $$invalidate(1, showMenu = $$props.showMenu);
    		if ('onEnterHoverFn' in $$props) $$invalidate(2, onEnterHoverFn = $$props.onEnterHoverFn);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showPage,
    		showMenu,
    		onEnterHoverFn,
    		$ui,
    		actionData,
    		schemaData,
    		climateData,
    		queryParams
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance, create_fragment, safe_not_equal, {
    			actionData: 4,
    			schemaData: 5,
    			climateData: 6,
    			queryParams: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*actionData*/ ctx[4] === undefined && !('actionData' in props)) {
    			console_1.warn("<App> was created without expected prop 'actionData'");
    		}

    		if (/*schemaData*/ ctx[5] === undefined && !('schemaData' in props)) {
    			console_1.warn("<App> was created without expected prop 'schemaData'");
    		}

    		if (/*climateData*/ ctx[6] === undefined && !('climateData' in props)) {
    			console_1.warn("<App> was created without expected prop 'climateData'");
    		}
    	}

    	get actionData() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionData(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get schemaData() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set schemaData(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get climateData() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set climateData(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get queryParams() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set queryParams(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var airtable_umd = createCommonjsModule(function (module, exports) {
    (function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    // istanbul ignore file
    var AbortController;
    if (typeof window === 'undefined') {
        AbortController = require('abort-controller');
    }
    else if ('signal' in new Request('')) {
        AbortController = window.AbortController;
    }
    else {
        /* eslint-disable @typescript-eslint/no-var-requires */
        var polyfill = require('abortcontroller-polyfill/dist/cjs-ponyfill');
        /* eslint-enable @typescript-eslint/no-var-requires */
        AbortController = polyfill.AbortController;
    }
    module.exports = AbortController;

    },{"abort-controller":20,"abortcontroller-polyfill/dist/cjs-ponyfill":19}],2:[function(require,module,exports){
    var AirtableError = /** @class */ (function () {
        function AirtableError(error, message, statusCode) {
            this.error = error;
            this.message = message;
            this.statusCode = statusCode;
        }
        AirtableError.prototype.toString = function () {
            return [
                this.message,
                '(',
                this.error,
                ')',
                this.statusCode ? "[Http code " + this.statusCode + "]" : '',
            ].join('');
        };
        return AirtableError;
    }());
    module.exports = AirtableError;

    },{}],3:[function(require,module,exports){
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var get_1 = __importDefault(require("lodash/get"));
    var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
    var keys_1 = __importDefault(require("lodash/keys"));
    var fetch_1 = __importDefault(require("./fetch"));
    var abort_controller_1 = __importDefault(require("./abort-controller"));
    var object_to_query_param_string_1 = __importDefault(require("./object_to_query_param_string"));
    var airtable_error_1 = __importDefault(require("./airtable_error"));
    var table_1 = __importDefault(require("./table"));
    var http_headers_1 = __importDefault(require("./http_headers"));
    var run_action_1 = __importDefault(require("./run_action"));
    var package_version_1 = __importDefault(require("./package_version"));
    var exponential_backoff_with_jitter_1 = __importDefault(require("./exponential_backoff_with_jitter"));
    var userAgent = "Airtable.js/" + package_version_1.default;
    var Base = /** @class */ (function () {
        function Base(airtable, baseId) {
            this._airtable = airtable;
            this._id = baseId;
        }
        Base.prototype.table = function (tableName) {
            return new table_1.default(this, null, tableName);
        };
        Base.prototype.makeRequest = function (options) {
            var _this = this;
            var _a;
            if (options === void 0) { options = {}; }
            var method = get_1.default(options, 'method', 'GET').toUpperCase();
            var url = this._airtable._endpointUrl + "/v" + this._airtable._apiVersionMajor + "/" + this._id + get_1.default(options, 'path', '/') + "?" + object_to_query_param_string_1.default(get_1.default(options, 'qs', {}));
            var controller = new abort_controller_1.default();
            var headers = this._getRequestHeaders(Object.assign({}, this._airtable._customHeaders, (_a = options.headers) !== null && _a !== void 0 ? _a : {}));
            var requestOptions = {
                method: method,
                headers: headers,
                signal: controller.signal,
            };
            if ('body' in options && _canRequestMethodIncludeBody(method)) {
                requestOptions.body = JSON.stringify(options.body);
            }
            var timeout = setTimeout(function () {
                controller.abort();
            }, this._airtable._requestTimeout);
            return new Promise(function (resolve, reject) {
                fetch_1.default(url, requestOptions)
                    .then(function (resp) {
                    clearTimeout(timeout);
                    if (resp.status === 429 && !_this._airtable._noRetryIfRateLimited) {
                        var numAttempts_1 = get_1.default(options, '_numAttempts', 0);
                        var backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts_1);
                        setTimeout(function () {
                            var newOptions = __assign(__assign({}, options), { _numAttempts: numAttempts_1 + 1 });
                            _this.makeRequest(newOptions)
                                .then(resolve)
                                .catch(reject);
                        }, backoffDelayMs);
                    }
                    else {
                        resp.json()
                            .then(function (body) {
                            var err = _this._checkStatusForError(resp.status, body) ||
                                _getErrorForNonObjectBody(resp.status, body);
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve({
                                    statusCode: resp.status,
                                    headers: resp.headers,
                                    body: body,
                                });
                            }
                        })
                            .catch(function () {
                            var err = _getErrorForNonObjectBody(resp.status);
                            reject(err);
                        });
                    }
                })
                    .catch(function (err) {
                    clearTimeout(timeout);
                    err = new airtable_error_1.default('CONNECTION_ERROR', err.message, null);
                    reject(err);
                });
            });
        };
        /**
         * @deprecated This method is deprecated.
         */
        Base.prototype.runAction = function (method, path, queryParams, bodyData, callback) {
            run_action_1.default(this, method, path, queryParams, bodyData, callback, 0);
        };
        Base.prototype._getRequestHeaders = function (headers) {
            var result = new http_headers_1.default();
            result.set('Authorization', "Bearer " + this._airtable._apiKey);
            result.set('User-Agent', userAgent);
            result.set('Content-Type', 'application/json');
            for (var _i = 0, _a = keys_1.default(headers); _i < _a.length; _i++) {
                var headerKey = _a[_i];
                result.set(headerKey, headers[headerKey]);
            }
            return result.toJSON();
        };
        Base.prototype._checkStatusForError = function (statusCode, body) {
            var _a = (body !== null && body !== void 0 ? body : { error: {} }).error, error = _a === void 0 ? {} : _a;
            var type = error.type, message = error.message;
            if (statusCode === 401) {
                return new airtable_error_1.default('AUTHENTICATION_REQUIRED', 'You should provide valid api key to perform this operation', statusCode);
            }
            else if (statusCode === 403) {
                return new airtable_error_1.default('NOT_AUTHORIZED', 'You are not authorized to perform this operation', statusCode);
            }
            else if (statusCode === 404) {
                return new airtable_error_1.default('NOT_FOUND', message !== null && message !== void 0 ? message : 'Could not find what you are looking for', statusCode);
            }
            else if (statusCode === 413) {
                return new airtable_error_1.default('REQUEST_TOO_LARGE', 'Request body is too large', statusCode);
            }
            else if (statusCode === 422) {
                return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNPROCESSABLE_ENTITY', message !== null && message !== void 0 ? message : 'The operation cannot be processed', statusCode);
            }
            else if (statusCode === 429) {
                return new airtable_error_1.default('TOO_MANY_REQUESTS', 'You have made too many requests in a short period of time. Please retry your request later', statusCode);
            }
            else if (statusCode === 500) {
                return new airtable_error_1.default('SERVER_ERROR', 'Try again. If the problem persists, contact support.', statusCode);
            }
            else if (statusCode === 503) {
                return new airtable_error_1.default('SERVICE_UNAVAILABLE', 'The service is temporarily unavailable. Please retry shortly.', statusCode);
            }
            else if (statusCode >= 400) {
                return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNEXPECTED_ERROR', message !== null && message !== void 0 ? message : 'An unexpected error occurred', statusCode);
            }
            else {
                return null;
            }
        };
        Base.prototype.doCall = function (tableName) {
            return this.table(tableName);
        };
        Base.prototype.getId = function () {
            return this._id;
        };
        Base.createFunctor = function (airtable, baseId) {
            var base = new Base(airtable, baseId);
            var baseFn = function (tableName) {
                return base.doCall(tableName);
            };
            baseFn._base = base;
            baseFn.table = base.table.bind(base);
            baseFn.makeRequest = base.makeRequest.bind(base);
            baseFn.runAction = base.runAction.bind(base);
            baseFn.getId = base.getId.bind(base);
            return baseFn;
        };
        return Base;
    }());
    function _canRequestMethodIncludeBody(method) {
        return method !== 'GET' && method !== 'DELETE';
    }
    function _getErrorForNonObjectBody(statusCode, body) {
        if (isPlainObject_1.default(body)) {
            return null;
        }
        else {
            return new airtable_error_1.default('UNEXPECTED_ERROR', 'The response from Airtable was invalid JSON. Please try again soon.', statusCode);
        }
    }
    module.exports = Base;

    },{"./abort-controller":1,"./airtable_error":2,"./exponential_backoff_with_jitter":6,"./fetch":7,"./http_headers":9,"./object_to_query_param_string":11,"./package_version":12,"./run_action":16,"./table":17,"lodash/get":77,"lodash/isPlainObject":89,"lodash/keys":93}],4:[function(require,module,exports){
    /**
     * Given a function fn that takes a callback as its last argument, returns
     * a new version of the function that takes the callback optionally. If
     * the function is not called with a callback for the last argument, the
     * function will return a promise instead.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
    function callbackToPromise(fn, context, callbackArgIndex) {
        if (callbackArgIndex === void 0) { callbackArgIndex = void 0; }
        /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
        return function () {
            var callArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                callArgs[_i] = arguments[_i];
            }
            var thisCallbackArgIndex;
            if (callbackArgIndex === void 0) {
                // istanbul ignore next
                thisCallbackArgIndex = callArgs.length > 0 ? callArgs.length - 1 : 0;
            }
            else {
                thisCallbackArgIndex = callbackArgIndex;
            }
            var callbackArg = callArgs[thisCallbackArgIndex];
            if (typeof callbackArg === 'function') {
                fn.apply(context, callArgs);
                return void 0;
            }
            else {
                var args_1 = [];
                // If an explicit callbackArgIndex is set, but the function is called
                // with too few arguments, we want to push undefined onto args so that
                // our constructed callback ends up at the right index.
                var argLen = Math.max(callArgs.length, thisCallbackArgIndex);
                for (var i = 0; i < argLen; i++) {
                    args_1.push(callArgs[i]);
                }
                return new Promise(function (resolve, reject) {
                    args_1.push(function (err, result) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(result);
                        }
                    });
                    fn.apply(context, args_1);
                });
            }
        };
    }
    module.exports = callbackToPromise;

    },{}],5:[function(require,module,exports){
    var didWarnForDeprecation = {};
    /**
     * Convenience function for marking a function as deprecated.
     *
     * Will emit a warning the first time that function is called.
     *
     * @param fn the function to mark as deprecated.
     * @param key a unique key identifying the function.
     * @param message the warning message.
     *
     * @return a wrapped function
     */
    function deprecate(fn, key, message) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!didWarnForDeprecation[key]) {
                didWarnForDeprecation[key] = true;
                console.warn(message);
            }
            fn.apply(this, args);
        };
    }
    module.exports = deprecate;

    },{}],6:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var internal_config_json_1 = __importDefault(require("./internal_config.json"));
    // "Full Jitter" algorithm taken from https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
    function exponentialBackoffWithJitter(numberOfRetries) {
        var rawBackoffTimeMs = internal_config_json_1.default.INITIAL_RETRY_DELAY_IF_RATE_LIMITED * Math.pow(2, numberOfRetries);
        var clippedBackoffTimeMs = Math.min(internal_config_json_1.default.MAX_RETRY_DELAY_IF_RATE_LIMITED, rawBackoffTimeMs);
        var jitteredBackoffTimeMs = Math.random() * clippedBackoffTimeMs;
        return jitteredBackoffTimeMs;
    }
    module.exports = exponentialBackoffWithJitter;

    },{"./internal_config.json":10}],7:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    // istanbul ignore file
    var node_fetch_1 = __importDefault(require("node-fetch"));
    module.exports = typeof window === 'undefined' ? node_fetch_1.default : window.fetch.bind(window);

    },{"node-fetch":20}],8:[function(require,module,exports){
    /* eslint-enable @typescript-eslint/no-explicit-any */
    function has(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }
    module.exports = has;

    },{}],9:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var keys_1 = __importDefault(require("lodash/keys"));
    var isBrowser = typeof window !== 'undefined';
    var HttpHeaders = /** @class */ (function () {
        function HttpHeaders() {
            this._headersByLowercasedKey = {};
        }
        HttpHeaders.prototype.set = function (headerKey, headerValue) {
            var lowercasedKey = headerKey.toLowerCase();
            if (lowercasedKey === 'x-airtable-user-agent') {
                lowercasedKey = 'user-agent';
                headerKey = 'User-Agent';
            }
            this._headersByLowercasedKey[lowercasedKey] = {
                headerKey: headerKey,
                headerValue: headerValue,
            };
        };
        HttpHeaders.prototype.toJSON = function () {
            var result = {};
            for (var _i = 0, _a = keys_1.default(this._headersByLowercasedKey); _i < _a.length; _i++) {
                var lowercasedKey = _a[_i];
                var headerDefinition = this._headersByLowercasedKey[lowercasedKey];
                var headerKey = void 0;
                /* istanbul ignore next */
                if (isBrowser && lowercasedKey === 'user-agent') {
                    // Some browsers do not allow overriding the user agent.
                    // https://github.com/Airtable/airtable.js/issues/52
                    headerKey = 'X-Airtable-User-Agent';
                }
                else {
                    headerKey = headerDefinition.headerKey;
                }
                result[headerKey] = headerDefinition.headerValue;
            }
            return result;
        };
        return HttpHeaders;
    }());
    module.exports = HttpHeaders;

    },{"lodash/keys":93}],10:[function(require,module,exports){
    module.exports={
        "INITIAL_RETRY_DELAY_IF_RATE_LIMITED": 5000,
        "MAX_RETRY_DELAY_IF_RATE_LIMITED": 600000
    };

    },{}],11:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var isArray_1 = __importDefault(require("lodash/isArray"));
    var isNil_1 = __importDefault(require("lodash/isNil"));
    var keys_1 = __importDefault(require("lodash/keys"));
    /* eslint-enable @typescript-eslint/no-explicit-any */
    // Adapted from jQuery.param:
    // https://github.com/jquery/jquery/blob/2.2-stable/src/serialize.js
    function buildParams(prefix, obj, addFn) {
        if (isArray_1.default(obj)) {
            // Serialize array item.
            for (var index = 0; index < obj.length; index++) {
                var value = obj[index];
                if (/\[\]$/.test(prefix)) {
                    // Treat each array item as a scalar.
                    addFn(prefix, value);
                }
                else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + (typeof value === 'object' && value !== null ? index : '') + "]", value, addFn);
                }
            }
        }
        else if (typeof obj === 'object') {
            // Serialize object item.
            for (var _i = 0, _a = keys_1.default(obj); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = obj[key];
                buildParams(prefix + "[" + key + "]", value, addFn);
            }
        }
        else {
            // Serialize scalar item.
            addFn(prefix, obj);
        }
    }
    function objectToQueryParamString(obj) {
        var parts = [];
        var addFn = function (key, value) {
            value = isNil_1.default(value) ? '' : value;
            parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        };
        for (var _i = 0, _a = keys_1.default(obj); _i < _a.length; _i++) {
            var key = _a[_i];
            var value = obj[key];
            buildParams(key, value, addFn);
        }
        return parts.join('&').replace(/%20/g, '+');
    }
    module.exports = objectToQueryParamString;

    },{"lodash/isArray":79,"lodash/isNil":85,"lodash/keys":93}],12:[function(require,module,exports){
    module.exports = "0.11.4";

    },{}],13:[function(require,module,exports){
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var isFunction_1 = __importDefault(require("lodash/isFunction"));
    var keys_1 = __importDefault(require("lodash/keys"));
    var record_1 = __importDefault(require("./record"));
    var callback_to_promise_1 = __importDefault(require("./callback_to_promise"));
    var has_1 = __importDefault(require("./has"));
    var query_params_1 = require("./query_params");
    /**
     * Builds a query object. Won't fetch until `firstPage` or
     * or `eachPage` is called.
     *
     * Params should be validated prior to being passed to Query
     * with `Query.validateParams`.
     */
    var Query = /** @class */ (function () {
        function Query(table, params) {
            this._table = table;
            this._params = params;
            this.firstPage = callback_to_promise_1.default(firstPage, this);
            this.eachPage = callback_to_promise_1.default(eachPage, this, 1);
            this.all = callback_to_promise_1.default(all, this);
        }
        /**
         * Validates the parameters for passing to the Query constructor.
         *
         * @params {object} params parameters to validate
         *
         * @return an object with two keys:
         *  validParams: the object that should be passed to the constructor.
         *  ignoredKeys: a list of keys that will be ignored.
         *  errors: a list of error messages.
         */
        Query.validateParams = function (params) {
            var validParams = {};
            var ignoredKeys = [];
            var errors = [];
            for (var _i = 0, _a = keys_1.default(params); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = params[key];
                if (has_1.default(Query.paramValidators, key)) {
                    var validator = Query.paramValidators[key];
                    var validationResult = validator(value);
                    if (validationResult.pass) {
                        validParams[key] = value;
                    }
                    else {
                        errors.push(validationResult.error);
                    }
                }
                else {
                    ignoredKeys.push(key);
                }
            }
            return {
                validParams: validParams,
                ignoredKeys: ignoredKeys,
                errors: errors,
            };
        };
        Query.paramValidators = query_params_1.paramValidators;
        return Query;
    }());
    /**
     * Fetches the first page of results for the query asynchronously,
     * then calls `done(error, records)`.
     */
    function firstPage(done) {
        if (!isFunction_1.default(done)) {
            throw new Error('The first parameter to `firstPage` must be a function');
        }
        this.eachPage(function (records) {
            done(null, records);
        }, function (error) {
            done(error, null);
        });
    }
    /**
     * Fetches each page of results for the query asynchronously.
     *
     * Calls `pageCallback(records, fetchNextPage)` for each
     * page. You must call `fetchNextPage()` to fetch the next page of
     * results.
     *
     * After fetching all pages, or if there's an error, calls
     * `done(error)`.
     */
    function eachPage(pageCallback, done) {
        var _this = this;
        if (!isFunction_1.default(pageCallback)) {
            throw new Error('The first parameter to `eachPage` must be a function');
        }
        if (!isFunction_1.default(done) && done !== void 0) {
            throw new Error('The second parameter to `eachPage` must be a function or undefined');
        }
        var path = "/" + this._table._urlEncodedNameOrId();
        var params = __assign({}, this._params);
        var inner = function () {
            _this._table._base.runAction('get', path, params, null, function (err, response, result) {
                if (err) {
                    done(err, null);
                }
                else {
                    var next = void 0;
                    if (result.offset) {
                        params.offset = result.offset;
                        next = inner;
                    }
                    else {
                        next = function () {
                            done(null);
                        };
                    }
                    var records = result.records.map(function (recordJson) {
                        return new record_1.default(_this._table, null, recordJson);
                    });
                    pageCallback(records, next);
                }
            });
        };
        inner();
    }
    /**
     * Fetches all pages of results asynchronously. May take a long time.
     */
    function all(done) {
        if (!isFunction_1.default(done)) {
            throw new Error('The first parameter to `all` must be a function');
        }
        var allRecords = [];
        this.eachPage(function (pageRecords, fetchNextPage) {
            allRecords.push.apply(allRecords, pageRecords);
            fetchNextPage();
        }, function (err) {
            if (err) {
                done(err, null);
            }
            else {
                done(null, allRecords);
            }
        });
    }
    module.exports = Query;

    },{"./callback_to_promise":4,"./has":8,"./query_params":14,"./record":15,"lodash/isFunction":83,"lodash/keys":93}],14:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.paramValidators = void 0;
    var typecheck_1 = __importDefault(require("./typecheck"));
    var isString_1 = __importDefault(require("lodash/isString"));
    var isNumber_1 = __importDefault(require("lodash/isNumber"));
    var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
    var isBoolean_1 = __importDefault(require("lodash/isBoolean"));
    exports.paramValidators = {
        fields: typecheck_1.default(typecheck_1.default.isArrayOf(isString_1.default), 'the value for `fields` should be an array of strings'),
        filterByFormula: typecheck_1.default(isString_1.default, 'the value for `filterByFormula` should be a string'),
        maxRecords: typecheck_1.default(isNumber_1.default, 'the value for `maxRecords` should be a number'),
        pageSize: typecheck_1.default(isNumber_1.default, 'the value for `pageSize` should be a number'),
        offset: typecheck_1.default(isNumber_1.default, 'the value for `offset` should be a number'),
        sort: typecheck_1.default(typecheck_1.default.isArrayOf(function (obj) {
            return (isPlainObject_1.default(obj) &&
                isString_1.default(obj.field) &&
                (obj.direction === void 0 || ['asc', 'desc'].includes(obj.direction)));
        }), 'the value for `sort` should be an array of sort objects. ' +
            'Each sort object must have a string `field` value, and an optional ' +
            '`direction` value that is "asc" or "desc".'),
        view: typecheck_1.default(isString_1.default, 'the value for `view` should be a string'),
        cellFormat: typecheck_1.default(function (cellFormat) {
            return isString_1.default(cellFormat) && ['json', 'string'].includes(cellFormat);
        }, 'the value for `cellFormat` should be "json" or "string"'),
        timeZone: typecheck_1.default(isString_1.default, 'the value for `timeZone` should be a string'),
        userLocale: typecheck_1.default(isString_1.default, 'the value for `userLocale` should be a string'),
        returnFieldsByFieldId: typecheck_1.default(isBoolean_1.default, 'the value for `returnFieldsByFieldId` should be a boolean'),
    };

    },{"./typecheck":18,"lodash/isBoolean":81,"lodash/isNumber":86,"lodash/isPlainObject":89,"lodash/isString":90}],15:[function(require,module,exports){
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var callback_to_promise_1 = __importDefault(require("./callback_to_promise"));
    var Record = /** @class */ (function () {
        function Record(table, recordId, recordJson) {
            this._table = table;
            this.id = recordId || recordJson.id;
            this.setRawJson(recordJson);
            this.save = callback_to_promise_1.default(save, this);
            this.patchUpdate = callback_to_promise_1.default(patchUpdate, this);
            this.putUpdate = callback_to_promise_1.default(putUpdate, this);
            this.destroy = callback_to_promise_1.default(destroy, this);
            this.fetch = callback_to_promise_1.default(fetch, this);
            this.updateFields = this.patchUpdate;
            this.replaceFields = this.putUpdate;
        }
        Record.prototype.getId = function () {
            return this.id;
        };
        Record.prototype.get = function (columnName) {
            return this.fields[columnName];
        };
        Record.prototype.set = function (columnName, columnValue) {
            this.fields[columnName] = columnValue;
        };
        Record.prototype.setRawJson = function (rawJson) {
            this._rawJson = rawJson;
            this.fields = (this._rawJson && this._rawJson.fields) || {};
        };
        return Record;
    }());
    function save(done) {
        this.putUpdate(this.fields, done);
    }
    function patchUpdate(cellValuesByName, opts, done) {
        var _this = this;
        if (!done) {
            done = opts;
            opts = {};
        }
        var updateBody = __assign({ fields: cellValuesByName }, opts);
        this._table._base.runAction('patch', "/" + this._table._urlEncodedNameOrId() + "/" + this.id, {}, updateBody, function (err, response, results) {
            if (err) {
                done(err);
                return;
            }
            _this.setRawJson(results);
            done(null, _this);
        });
    }
    function putUpdate(cellValuesByName, opts, done) {
        var _this = this;
        if (!done) {
            done = opts;
            opts = {};
        }
        var updateBody = __assign({ fields: cellValuesByName }, opts);
        this._table._base.runAction('put', "/" + this._table._urlEncodedNameOrId() + "/" + this.id, {}, updateBody, function (err, response, results) {
            if (err) {
                done(err);
                return;
            }
            _this.setRawJson(results);
            done(null, _this);
        });
    }
    function destroy(done) {
        var _this = this;
        this._table._base.runAction('delete', "/" + this._table._urlEncodedNameOrId() + "/" + this.id, {}, null, function (err) {
            if (err) {
                done(err);
                return;
            }
            done(null, _this);
        });
    }
    function fetch(done) {
        var _this = this;
        this._table._base.runAction('get', "/" + this._table._urlEncodedNameOrId() + "/" + this.id, {}, null, function (err, response, results) {
            if (err) {
                done(err);
                return;
            }
            _this.setRawJson(results);
            done(null, _this);
        });
    }
    module.exports = Record;

    },{"./callback_to_promise":4}],16:[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var exponential_backoff_with_jitter_1 = __importDefault(require("./exponential_backoff_with_jitter"));
    var object_to_query_param_string_1 = __importDefault(require("./object_to_query_param_string"));
    var package_version_1 = __importDefault(require("./package_version"));
    var fetch_1 = __importDefault(require("./fetch"));
    var abort_controller_1 = __importDefault(require("./abort-controller"));
    var userAgent = "Airtable.js/" + package_version_1.default;
    function runAction(base, method, path, queryParams, bodyData, callback, numAttempts) {
        var url = base._airtable._endpointUrl + "/v" + base._airtable._apiVersionMajor + "/" + base._id + path + "?" + object_to_query_param_string_1.default(queryParams);
        var headers = {
            authorization: "Bearer " + base._airtable._apiKey,
            'x-api-version': base._airtable._apiVersion,
            'x-airtable-application-id': base.getId(),
            'content-type': 'application/json',
        };
        var isBrowser = typeof window !== 'undefined';
        // Some browsers do not allow overriding the user agent.
        // https://github.com/Airtable/airtable.js/issues/52
        if (isBrowser) {
            headers['x-airtable-user-agent'] = userAgent;
        }
        else {
            headers['User-Agent'] = userAgent;
        }
        var controller = new abort_controller_1.default();
        var normalizedMethod = method.toUpperCase();
        var options = {
            method: normalizedMethod,
            headers: headers,
            signal: controller.signal,
        };
        if (bodyData !== null) {
            if (normalizedMethod === 'GET' || normalizedMethod === 'HEAD') {
                console.warn('body argument to runAction are ignored with GET or HEAD requests');
            }
            else {
                options.body = JSON.stringify(bodyData);
            }
        }
        var timeout = setTimeout(function () {
            controller.abort();
        }, base._airtable._requestTimeout);
        fetch_1.default(url, options)
            .then(function (resp) {
            clearTimeout(timeout);
            if (resp.status === 429 && !base._airtable._noRetryIfRateLimited) {
                var backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts);
                setTimeout(function () {
                    runAction(base, method, path, queryParams, bodyData, callback, numAttempts + 1);
                }, backoffDelayMs);
            }
            else {
                resp.json()
                    .then(function (body) {
                    var error = base._checkStatusForError(resp.status, body);
                    // Ensure Response interface matches interface from
                    // `request` Response object
                    var r = {};
                    Object.keys(resp).forEach(function (property) {
                        r[property] = resp[property];
                    });
                    r.body = body;
                    r.statusCode = resp.status;
                    callback(error, r, body);
                })
                    .catch(function () {
                    callback(base._checkStatusForError(resp.status));
                });
            }
        })
            .catch(function (error) {
            clearTimeout(timeout);
            callback(error);
        });
    }
    module.exports = runAction;

    },{"./abort-controller":1,"./exponential_backoff_with_jitter":6,"./fetch":7,"./object_to_query_param_string":11,"./package_version":12}],17:[function(require,module,exports){
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
    var deprecate_1 = __importDefault(require("./deprecate"));
    var query_1 = __importDefault(require("./query"));
    var record_1 = __importDefault(require("./record"));
    var callback_to_promise_1 = __importDefault(require("./callback_to_promise"));
    var Table = /** @class */ (function () {
        function Table(base, tableId, tableName) {
            if (!tableId && !tableName) {
                throw new Error('Table name or table ID is required');
            }
            this._base = base;
            this.id = tableId;
            this.name = tableName;
            // Public API
            this.find = callback_to_promise_1.default(this._findRecordById, this);
            this.select = this._selectRecords.bind(this);
            this.create = callback_to_promise_1.default(this._createRecords, this);
            this.update = callback_to_promise_1.default(this._updateRecords.bind(this, false), this);
            this.replace = callback_to_promise_1.default(this._updateRecords.bind(this, true), this);
            this.destroy = callback_to_promise_1.default(this._destroyRecord, this);
            // Deprecated API
            this.list = deprecate_1.default(this._listRecords.bind(this), 'table.list', 'Airtable: `list()` is deprecated. Use `select()` instead.');
            this.forEach = deprecate_1.default(this._forEachRecord.bind(this), 'table.forEach', 'Airtable: `forEach()` is deprecated. Use `select()` instead.');
        }
        Table.prototype._findRecordById = function (recordId, done) {
            var record = new record_1.default(this, recordId);
            record.fetch(done);
        };
        Table.prototype._selectRecords = function (params) {
            if (params === void 0) {
                params = {};
            }
            if (arguments.length > 1) {
                console.warn("Airtable: `select` takes only one parameter, but it was given " + arguments.length + " parameters. Use `eachPage` or `firstPage` to fetch records.");
            }
            if (isPlainObject_1.default(params)) {
                var validationResults = query_1.default.validateParams(params);
                if (validationResults.errors.length) {
                    var formattedErrors = validationResults.errors.map(function (error) {
                        return "  * " + error;
                    });
                    throw new Error("Airtable: invalid parameters for `select`:\n" + formattedErrors.join('\n'));
                }
                if (validationResults.ignoredKeys.length) {
                    console.warn("Airtable: the following parameters to `select` will be ignored: " + validationResults.ignoredKeys.join(', '));
                }
                return new query_1.default(this, validationResults.validParams);
            }
            else {
                throw new Error('Airtable: the parameter for `select` should be a plain object or undefined.');
            }
        };
        Table.prototype._urlEncodedNameOrId = function () {
            return this.id || encodeURIComponent(this.name);
        };
        Table.prototype._createRecords = function (recordsData, optionalParameters, done) {
            var _this = this;
            var isCreatingMultipleRecords = Array.isArray(recordsData);
            if (!done) {
                done = optionalParameters;
                optionalParameters = {};
            }
            var requestData;
            if (isCreatingMultipleRecords) {
                requestData = __assign({ records: recordsData }, optionalParameters);
            }
            else {
                requestData = __assign({ fields: recordsData }, optionalParameters);
            }
            this._base.runAction('post', "/" + this._urlEncodedNameOrId() + "/", {}, requestData, function (err, resp, body) {
                if (err) {
                    done(err);
                    return;
                }
                var result;
                if (isCreatingMultipleRecords) {
                    result = body.records.map(function (record) {
                        return new record_1.default(_this, record.id, record);
                    });
                }
                else {
                    result = new record_1.default(_this, body.id, body);
                }
                done(null, result);
            });
        };
        Table.prototype._updateRecords = function (isDestructiveUpdate, recordsDataOrRecordId, recordDataOrOptsOrDone, optsOrDone, done) {
            var _this = this;
            var opts;
            if (Array.isArray(recordsDataOrRecordId)) {
                var recordsData = recordsDataOrRecordId;
                opts = isPlainObject_1.default(recordDataOrOptsOrDone) ? recordDataOrOptsOrDone : {};
                done = (optsOrDone || recordDataOrOptsOrDone);
                var method = isDestructiveUpdate ? 'put' : 'patch';
                var requestData = __assign({ records: recordsData }, opts);
                this._base.runAction(method, "/" + this._urlEncodedNameOrId() + "/", {}, requestData, function (err, resp, body) {
                    if (err) {
                        done(err);
                        return;
                    }
                    var result = body.records.map(function (record) {
                        return new record_1.default(_this, record.id, record);
                    });
                    done(null, result);
                });
            }
            else {
                var recordId = recordsDataOrRecordId;
                var recordData = recordDataOrOptsOrDone;
                opts = isPlainObject_1.default(optsOrDone) ? optsOrDone : {};
                done = (done || optsOrDone);
                var record = new record_1.default(this, recordId);
                if (isDestructiveUpdate) {
                    record.putUpdate(recordData, opts, done);
                }
                else {
                    record.patchUpdate(recordData, opts, done);
                }
            }
        };
        Table.prototype._destroyRecord = function (recordIdsOrId, done) {
            var _this = this;
            if (Array.isArray(recordIdsOrId)) {
                var queryParams = { records: recordIdsOrId };
                this._base.runAction('delete', "/" + this._urlEncodedNameOrId(), queryParams, null, function (err, response, results) {
                    if (err) {
                        done(err);
                        return;
                    }
                    var records = results.records.map(function (_a) {
                        var id = _a.id;
                        return new record_1.default(_this, id, null);
                    });
                    done(null, records);
                });
            }
            else {
                var record = new record_1.default(this, recordIdsOrId);
                record.destroy(done);
            }
        };
        Table.prototype._listRecords = function (limit, offset, opts, done) {
            var _this = this;
            if (!done) {
                done = opts;
                opts = {};
            }
            var listRecordsParameters = __assign({ limit: limit,
                offset: offset }, opts);
            this._base.runAction('get', "/" + this._urlEncodedNameOrId() + "/", listRecordsParameters, null, function (err, response, results) {
                if (err) {
                    done(err);
                    return;
                }
                var records = results.records.map(function (recordJson) {
                    return new record_1.default(_this, null, recordJson);
                });
                done(null, records, results.offset);
            });
        };
        Table.prototype._forEachRecord = function (opts, callback, done) {
            var _this = this;
            if (arguments.length === 2) {
                done = callback;
                callback = opts;
                opts = {};
            }
            var limit = Table.__recordsPerPageForIteration || 100;
            var offset = null;
            var nextPage = function () {
                _this._listRecords(limit, offset, opts, function (err, page, newOffset) {
                    if (err) {
                        done(err);
                        return;
                    }
                    for (var index = 0; index < page.length; index++) {
                        callback(page[index]);
                    }
                    if (newOffset) {
                        offset = newOffset;
                        nextPage();
                    }
                    else {
                        done();
                    }
                });
            };
            nextPage();
        };
        return Table;
    }());
    module.exports = Table;

    },{"./callback_to_promise":4,"./deprecate":5,"./query":13,"./record":15,"lodash/isPlainObject":89}],18:[function(require,module,exports){
    /* eslint-enable @typescript-eslint/no-explicit-any */
    function check(fn, error) {
        return function (value) {
            if (fn(value)) {
                return { pass: true };
            }
            else {
                return { pass: false, error: error };
            }
        };
    }
    check.isOneOf = function isOneOf(options) {
        return options.includes.bind(options);
    };
    check.isArrayOf = function (itemValidator) {
        return function (value) {
            return Array.isArray(value) && value.every(itemValidator);
        };
    };
    module.exports = check;

    },{}],19:[function(require,module,exports){

    Object.defineProperty(exports, '__esModule', { value: true });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    var Emitter =
    /*#__PURE__*/
    function () {
      function Emitter() {
        _classCallCheck(this, Emitter);

        Object.defineProperty(this, 'listeners', {
          value: {},
          writable: true,
          configurable: true
        });
      }

      _createClass(Emitter, [{
        key: "addEventListener",
        value: function addEventListener(type, callback) {
          if (!(type in this.listeners)) {
            this.listeners[type] = [];
          }

          this.listeners[type].push(callback);
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, callback) {
          if (!(type in this.listeners)) {
            return;
          }

          var stack = this.listeners[type];

          for (var i = 0, l = stack.length; i < l; i++) {
            if (stack[i] === callback) {
              stack.splice(i, 1);
              return;
            }
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          var _this = this;

          if (!(event.type in this.listeners)) {
            return;
          }

          var debounce = function debounce(callback) {
            setTimeout(function () {
              return callback.call(_this, event);
            });
          };

          var stack = this.listeners[event.type];

          for (var i = 0, l = stack.length; i < l; i++) {
            debounce(stack[i]);
          }

          return !event.defaultPrevented;
        }
      }]);

      return Emitter;
    }();

    var AbortSignal =
    /*#__PURE__*/
    function (_Emitter) {
      _inherits(AbortSignal, _Emitter);

      function AbortSignal() {
        var _this2;

        _classCallCheck(this, AbortSignal);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this)); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent
        // constructor has failed to run, then "this.listeners" will still be undefined and then we call
        // the parent constructor directly instead as a workaround. For general details, see babel bug:
        // https://github.com/babel/babel/issues/3041
        // This hack was added as a fix for the issue described here:
        // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042

        if (!_this2.listeners) {
          Emitter.call(_assertThisInitialized(_this2));
        } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
        // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl


        Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {
          value: false,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {
          value: null,
          writable: true,
          configurable: true
        });
        return _this2;
      }

      _createClass(AbortSignal, [{
        key: "toString",
        value: function toString() {
          return '[object AbortSignal]';
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          if (event.type === 'abort') {
            this.aborted = true;

            if (typeof this.onabort === 'function') {
              this.onabort.call(this, event);
            }
          }

          _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, event);
        }
      }]);

      return AbortSignal;
    }(Emitter);
    var AbortController =
    /*#__PURE__*/
    function () {
      function AbortController() {
        _classCallCheck(this, AbortController);

        // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
        // we want Object.keys(new AbortController()) to be [] for compat with the native impl
        Object.defineProperty(this, 'signal', {
          value: new AbortSignal(),
          writable: true,
          configurable: true
        });
      }

      _createClass(AbortController, [{
        key: "abort",
        value: function abort() {
          var event;

          try {
            event = new Event('abort');
          } catch (e) {
            if (typeof document !== 'undefined') {
              if (!document.createEvent) {
                // For Internet Explorer 8:
                event = document.createEventObject();
                event.type = 'abort';
              } else {
                // For Internet Explorer 11:
                event = document.createEvent('Event');
                event.initEvent('abort', false, false);
              }
            } else {
              // Fallback where document isn't available:
              event = {
                type: 'abort',
                bubbles: false,
                cancelable: false
              };
            }
          }

          this.signal.dispatchEvent(event);
        }
      }, {
        key: "toString",
        value: function toString() {
          return '[object AbortController]';
        }
      }]);

      return AbortController;
    }();

    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      // These are necessary to make sure that we get correct output for:
      // Object.prototype.toString.call(new AbortController())
      AbortController.prototype[Symbol.toStringTag] = 'AbortController';
      AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
    }

    function polyfillNeeded(self) {
      if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
        return true;
      } // Note that the "unfetch" minimal fetch polyfill defines fetch() without
      // defining window.Request, and this polyfill need to work on top of unfetch
      // so the below feature detection needs the !self.AbortController part.
      // The Request.prototype check is also needed because Safari versions 11.1.2
      // up to and including 12.1.x has a window.AbortController present but still
      // does NOT correctly implement abortable fetch:
      // https://bugs.webkit.org/show_bug.cgi?id=174980#c2


      return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;
    }

    /**
     * Note: the "fetch.Request" default value is available for fetch imported from
     * the "node-fetch" package and not in browsers. This is OK since browsers
     * will be importing umd-polyfill.js from that path "self" is passed the
     * decorator so the default value will not be used (because browsers that define
     * fetch also has Request). One quirky setup where self.fetch exists but
     * self.Request does not is when the "unfetch" minimal fetch polyfill is used
     * on top of IE11; for this case the browser will try to use the fetch.Request
     * default value which in turn will be undefined but then then "if (Request)"
     * will ensure that you get a patched fetch but still no Request (as expected).
     * @param {fetch, Request = fetch.Request}
     * @returns {fetch: abortableFetch, Request: AbortableRequest}
     */

    function abortableFetchDecorator(patchTargets) {
      if ('function' === typeof patchTargets) {
        patchTargets = {
          fetch: patchTargets
        };
      }

      var _patchTargets = patchTargets,
          fetch = _patchTargets.fetch,
          _patchTargets$Request = _patchTargets.Request,
          NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
          NativeAbortController = _patchTargets.AbortController,
          _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
          __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

      if (!polyfillNeeded({
        fetch: fetch,
        Request: NativeRequest,
        AbortController: NativeAbortController,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
      })) {
        return {
          fetch: fetch,
          Request: Request
        };
      }

      var Request = NativeRequest; // Note that the "unfetch" minimal fetch polyfill defines fetch() without
      // defining window.Request, and this polyfill need to work on top of unfetch
      // hence we only patch it if it's available. Also we don't patch it if signal
      // is already available on the Request prototype because in this case support
      // is present and the patching below can cause a crash since it assigns to
      // request.signal which is technically a read-only property. This latter error
      // happens when you run the main5.js node-fetch example in the repo
      // "abortcontroller-polyfill-examples". The exact error is:
      //   request.signal = init.signal;
      //   ^
      // TypeError: Cannot set property signal of #<Request> which has only a getter

      if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        Request = function Request(input, init) {
          var signal;

          if (init && init.signal) {
            signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has
            // been installed because if we're running on top of a browser with a
            // working native AbortController (i.e. the polyfill was installed due to
            // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
            // fake AbortSignal to the native fetch will trigger:
            // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.

            delete init.signal;
          }

          var request = new NativeRequest(input, init);

          if (signal) {
            Object.defineProperty(request, 'signal', {
              writable: false,
              enumerable: false,
              configurable: true,
              value: signal
            });
          }

          return request;
        };

        Request.prototype = NativeRequest.prototype;
      }

      var realFetch = fetch;

      var abortableFetch = function abortableFetch(input, init) {
        var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

        if (signal) {
          var abortError;

          try {
            abortError = new DOMException('Aborted', 'AbortError');
          } catch (err) {
            // IE 11 does not support calling the DOMException constructor, use a
            // regular error object on it instead.
            abortError = new Error('Aborted');
            abortError.name = 'AbortError';
          } // Return early if already aborted, thus avoiding making an HTTP request


          if (signal.aborted) {
            return Promise.reject(abortError);
          } // Turn an event into a promise, reject it once `abort` is dispatched


          var cancellation = new Promise(function (_, reject) {
            signal.addEventListener('abort', function () {
              return reject(abortError);
            }, {
              once: true
            });
          });

          if (init && init.signal) {
            // Never pass .signal to the native implementation when the polyfill has
            // been installed because if we're running on top of a browser with a
            // working native AbortController (i.e. the polyfill was installed due to
            // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
            // fake AbortSignal to the native fetch will trigger:
            // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.
            delete init.signal;
          } // Return the fastest promise (don't need to wait for request to finish)


          return Promise.race([cancellation, realFetch(input, init)]);
        }

        return realFetch(input, init);
      };

      return {
        fetch: abortableFetch,
        Request: Request
      };
    }

    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.abortableFetch = abortableFetchDecorator;

    },{}],20:[function(require,module,exports){

    },{}],21:[function(require,module,exports){
    var hashClear = require('./_hashClear'),
        hashDelete = require('./_hashDelete'),
        hashGet = require('./_hashGet'),
        hashHas = require('./_hashHas'),
        hashSet = require('./_hashSet');

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    module.exports = Hash;

    },{"./_hashClear":46,"./_hashDelete":47,"./_hashGet":48,"./_hashHas":49,"./_hashSet":50}],22:[function(require,module,exports){
    var listCacheClear = require('./_listCacheClear'),
        listCacheDelete = require('./_listCacheDelete'),
        listCacheGet = require('./_listCacheGet'),
        listCacheHas = require('./_listCacheHas'),
        listCacheSet = require('./_listCacheSet');

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    module.exports = ListCache;

    },{"./_listCacheClear":56,"./_listCacheDelete":57,"./_listCacheGet":58,"./_listCacheHas":59,"./_listCacheSet":60}],23:[function(require,module,exports){
    var getNative = require('./_getNative'),
        root = require('./_root');

    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map');

    module.exports = Map;

    },{"./_getNative":42,"./_root":72}],24:[function(require,module,exports){
    var mapCacheClear = require('./_mapCacheClear'),
        mapCacheDelete = require('./_mapCacheDelete'),
        mapCacheGet = require('./_mapCacheGet'),
        mapCacheHas = require('./_mapCacheHas'),
        mapCacheSet = require('./_mapCacheSet');

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    module.exports = MapCache;

    },{"./_mapCacheClear":61,"./_mapCacheDelete":62,"./_mapCacheGet":63,"./_mapCacheHas":64,"./_mapCacheSet":65}],25:[function(require,module,exports){
    var root = require('./_root');

    /** Built-in value references. */
    var Symbol = root.Symbol;

    module.exports = Symbol;

    },{"./_root":72}],26:[function(require,module,exports){
    var baseTimes = require('./_baseTimes'),
        isArguments = require('./isArguments'),
        isArray = require('./isArray'),
        isBuffer = require('./isBuffer'),
        isIndex = require('./_isIndex'),
        isTypedArray = require('./isTypedArray');

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    module.exports = arrayLikeKeys;

    },{"./_baseTimes":35,"./_isIndex":51,"./isArguments":78,"./isArray":79,"./isBuffer":82,"./isTypedArray":92}],27:[function(require,module,exports){
    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    module.exports = arrayMap;

    },{}],28:[function(require,module,exports){
    var eq = require('./eq');

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    module.exports = assocIndexOf;

    },{"./eq":76}],29:[function(require,module,exports){
    var castPath = require('./_castPath'),
        toKey = require('./_toKey');

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    module.exports = baseGet;

    },{"./_castPath":38,"./_toKey":74}],30:[function(require,module,exports){
    var Symbol = require('./_Symbol'),
        getRawTag = require('./_getRawTag'),
        objectToString = require('./_objectToString');

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    module.exports = baseGetTag;

    },{"./_Symbol":25,"./_getRawTag":44,"./_objectToString":70}],31:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    module.exports = baseIsArguments;

    },{"./_baseGetTag":30,"./isObjectLike":88}],32:[function(require,module,exports){
    var isFunction = require('./isFunction'),
        isMasked = require('./_isMasked'),
        isObject = require('./isObject'),
        toSource = require('./_toSource');

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    module.exports = baseIsNative;

    },{"./_isMasked":54,"./_toSource":75,"./isFunction":83,"./isObject":87}],33:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isLength = require('./isLength'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    module.exports = baseIsTypedArray;

    },{"./_baseGetTag":30,"./isLength":84,"./isObjectLike":88}],34:[function(require,module,exports){
    var isPrototype = require('./_isPrototype'),
        nativeKeys = require('./_nativeKeys');

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    module.exports = baseKeys;

    },{"./_isPrototype":55,"./_nativeKeys":68}],35:[function(require,module,exports){
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    module.exports = baseTimes;

    },{}],36:[function(require,module,exports){
    var Symbol = require('./_Symbol'),
        arrayMap = require('./_arrayMap'),
        isArray = require('./isArray'),
        isSymbol = require('./isSymbol');

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    module.exports = baseToString;

    },{"./_Symbol":25,"./_arrayMap":27,"./isArray":79,"./isSymbol":91}],37:[function(require,module,exports){
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    module.exports = baseUnary;

    },{}],38:[function(require,module,exports){
    var isArray = require('./isArray'),
        isKey = require('./_isKey'),
        stringToPath = require('./_stringToPath'),
        toString = require('./toString');

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    module.exports = castPath;

    },{"./_isKey":52,"./_stringToPath":73,"./isArray":79,"./toString":96}],39:[function(require,module,exports){
    var root = require('./_root');

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    module.exports = coreJsData;

    },{"./_root":72}],40:[function(require,module,exports){
    (function (global){
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    module.exports = freeGlobal;

    }).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    },{}],41:[function(require,module,exports){
    var isKeyable = require('./_isKeyable');

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    module.exports = getMapData;

    },{"./_isKeyable":53}],42:[function(require,module,exports){
    var baseIsNative = require('./_baseIsNative'),
        getValue = require('./_getValue');

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    module.exports = getNative;

    },{"./_baseIsNative":32,"./_getValue":45}],43:[function(require,module,exports){
    var overArg = require('./_overArg');

    /** Built-in value references. */
    var getPrototype = overArg(Object.getPrototypeOf, Object);

    module.exports = getPrototype;

    },{"./_overArg":71}],44:[function(require,module,exports){
    var Symbol = require('./_Symbol');

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Built-in value references. */
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    module.exports = getRawTag;

    },{"./_Symbol":25}],45:[function(require,module,exports){
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    module.exports = getValue;

    },{}],46:[function(require,module,exports){
    var nativeCreate = require('./_nativeCreate');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    module.exports = hashClear;

    },{"./_nativeCreate":67}],47:[function(require,module,exports){
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    module.exports = hashDelete;

    },{}],48:[function(require,module,exports){
    var nativeCreate = require('./_nativeCreate');

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    module.exports = hashGet;

    },{"./_nativeCreate":67}],49:[function(require,module,exports){
    var nativeCreate = require('./_nativeCreate');

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    module.exports = hashHas;

    },{"./_nativeCreate":67}],50:[function(require,module,exports){
    var nativeCreate = require('./_nativeCreate');

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    module.exports = hashSet;

    },{"./_nativeCreate":67}],51:[function(require,module,exports){
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    module.exports = isIndex;

    },{}],52:[function(require,module,exports){
    var isArray = require('./isArray'),
        isSymbol = require('./isSymbol');

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    module.exports = isKey;

    },{"./isArray":79,"./isSymbol":91}],53:[function(require,module,exports){
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    module.exports = isKeyable;

    },{}],54:[function(require,module,exports){
    var coreJsData = require('./_coreJsData');

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    module.exports = isMasked;

    },{"./_coreJsData":39}],55:[function(require,module,exports){
    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    module.exports = isPrototype;

    },{}],56:[function(require,module,exports){
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    module.exports = listCacheClear;

    },{}],57:[function(require,module,exports){
    var assocIndexOf = require('./_assocIndexOf');

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    module.exports = listCacheDelete;

    },{"./_assocIndexOf":28}],58:[function(require,module,exports){
    var assocIndexOf = require('./_assocIndexOf');

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    module.exports = listCacheGet;

    },{"./_assocIndexOf":28}],59:[function(require,module,exports){
    var assocIndexOf = require('./_assocIndexOf');

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    module.exports = listCacheHas;

    },{"./_assocIndexOf":28}],60:[function(require,module,exports){
    var assocIndexOf = require('./_assocIndexOf');

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    module.exports = listCacheSet;

    },{"./_assocIndexOf":28}],61:[function(require,module,exports){
    var Hash = require('./_Hash'),
        ListCache = require('./_ListCache'),
        Map = require('./_Map');

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    module.exports = mapCacheClear;

    },{"./_Hash":21,"./_ListCache":22,"./_Map":23}],62:[function(require,module,exports){
    var getMapData = require('./_getMapData');

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    module.exports = mapCacheDelete;

    },{"./_getMapData":41}],63:[function(require,module,exports){
    var getMapData = require('./_getMapData');

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    module.exports = mapCacheGet;

    },{"./_getMapData":41}],64:[function(require,module,exports){
    var getMapData = require('./_getMapData');

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    module.exports = mapCacheHas;

    },{"./_getMapData":41}],65:[function(require,module,exports){
    var getMapData = require('./_getMapData');

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    module.exports = mapCacheSet;

    },{"./_getMapData":41}],66:[function(require,module,exports){
    var memoize = require('./memoize');

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    module.exports = memoizeCapped;

    },{"./memoize":94}],67:[function(require,module,exports){
    var getNative = require('./_getNative');

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    module.exports = nativeCreate;

    },{"./_getNative":42}],68:[function(require,module,exports){
    var overArg = require('./_overArg');

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    module.exports = nativeKeys;

    },{"./_overArg":71}],69:[function(require,module,exports){
    var freeGlobal = require('./_freeGlobal');

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;

    },{"./_freeGlobal":40}],70:[function(require,module,exports){
    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    module.exports = objectToString;

    },{}],71:[function(require,module,exports){
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    module.exports = overArg;

    },{}],72:[function(require,module,exports){
    var freeGlobal = require('./_freeGlobal');

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    module.exports = root;

    },{"./_freeGlobal":40}],73:[function(require,module,exports){
    var memoizeCapped = require('./_memoizeCapped');

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    module.exports = stringToPath;

    },{"./_memoizeCapped":66}],74:[function(require,module,exports){
    var isSymbol = require('./isSymbol');

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    module.exports = toKey;

    },{"./isSymbol":91}],75:[function(require,module,exports){
    /** Used for built-in method references. */
    var funcProto = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    module.exports = toSource;

    },{}],76:[function(require,module,exports){
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    module.exports = eq;

    },{}],77:[function(require,module,exports){
    var baseGet = require('./_baseGet');

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    module.exports = get;

    },{"./_baseGet":29}],78:[function(require,module,exports){
    var baseIsArguments = require('./_baseIsArguments'),
        isObjectLike = require('./isObjectLike');

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    module.exports = isArguments;

    },{"./_baseIsArguments":31,"./isObjectLike":88}],79:[function(require,module,exports){
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    module.exports = isArray;

    },{}],80:[function(require,module,exports){
    var isFunction = require('./isFunction'),
        isLength = require('./isLength');

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    module.exports = isArrayLike;

    },{"./isFunction":83,"./isLength":84}],81:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    module.exports = isBoolean;

    },{"./_baseGetTag":30,"./isObjectLike":88}],82:[function(require,module,exports){
    var root = require('./_root'),
        stubFalse = require('./stubFalse');

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    module.exports = isBuffer;

    },{"./_root":72,"./stubFalse":95}],83:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isObject = require('./isObject');

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    module.exports = isFunction;

    },{"./_baseGetTag":30,"./isObject":87}],84:[function(require,module,exports){
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    module.exports = isLength;

    },{}],85:[function(require,module,exports){
    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    module.exports = isNil;

    },{}],86:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var numberTag = '[object Number]';

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    module.exports = isNumber;

    },{"./_baseGetTag":30,"./isObjectLike":88}],87:[function(require,module,exports){
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    module.exports = isObject;

    },{}],88:[function(require,module,exports){
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    module.exports = isObjectLike;

    },{}],89:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        getPrototype = require('./_getPrototype'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var objectTag = '[object Object]';

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    module.exports = isPlainObject;

    },{"./_baseGetTag":30,"./_getPrototype":43,"./isObjectLike":88}],90:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isArray = require('./isArray'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var stringTag = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    module.exports = isString;

    },{"./_baseGetTag":30,"./isArray":79,"./isObjectLike":88}],91:[function(require,module,exports){
    var baseGetTag = require('./_baseGetTag'),
        isObjectLike = require('./isObjectLike');

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    module.exports = isSymbol;

    },{"./_baseGetTag":30,"./isObjectLike":88}],92:[function(require,module,exports){
    var baseIsTypedArray = require('./_baseIsTypedArray'),
        baseUnary = require('./_baseUnary'),
        nodeUtil = require('./_nodeUtil');

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    module.exports = isTypedArray;

    },{"./_baseIsTypedArray":33,"./_baseUnary":37,"./_nodeUtil":69}],93:[function(require,module,exports){
    var arrayLikeKeys = require('./_arrayLikeKeys'),
        baseKeys = require('./_baseKeys'),
        isArrayLike = require('./isArrayLike');

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    module.exports = keys;

    },{"./_arrayLikeKeys":26,"./_baseKeys":34,"./isArrayLike":80}],94:[function(require,module,exports){
    var MapCache = require('./_MapCache');

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    module.exports = memoize;

    },{"./_MapCache":24}],95:[function(require,module,exports){
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    module.exports = stubFalse;

    },{}],96:[function(require,module,exports){
    var baseToString = require('./_baseToString');

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    module.exports = toString;

    },{"./_baseToString":36}],"airtable":[function(require,module,exports){
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var base_1 = __importDefault(require("./base"));
    var record_1 = __importDefault(require("./record"));
    var table_1 = __importDefault(require("./table"));
    var airtable_error_1 = __importDefault(require("./airtable_error"));
    var Airtable = /** @class */ (function () {
        function Airtable(opts) {
            if (opts === void 0) { opts = {}; }
            var defaultConfig = Airtable.default_config();
            var apiVersion = opts.apiVersion || Airtable.apiVersion || defaultConfig.apiVersion;
            Object.defineProperties(this, {
                _apiKey: {
                    value: opts.apiKey || Airtable.apiKey || defaultConfig.apiKey,
                },
                _apiVersion: {
                    value: apiVersion,
                },
                _apiVersionMajor: {
                    value: apiVersion.split('.')[0],
                },
                _customHeaders: {
                    value: opts.customHeaders || {},
                },
                _endpointUrl: {
                    value: opts.endpointUrl || Airtable.endpointUrl || defaultConfig.endpointUrl,
                },
                _noRetryIfRateLimited: {
                    value: opts.noRetryIfRateLimited ||
                        Airtable.noRetryIfRateLimited ||
                        defaultConfig.noRetryIfRateLimited,
                },
                _requestTimeout: {
                    value: opts.requestTimeout || Airtable.requestTimeout || defaultConfig.requestTimeout,
                },
            });
            if (!this._apiKey) {
                throw new Error('An API key is required to connect to Airtable');
            }
        }
        Airtable.prototype.base = function (baseId) {
            return base_1.default.createFunctor(this, baseId);
        };
        Airtable.default_config = function () {
            return {
                endpointUrl: 'https://api.airtable.com',
                apiVersion: '0.1.0',
                apiKey: undefined,
                noRetryIfRateLimited: false,
                requestTimeout: 300 * 1000,
            };
        };
        Airtable.configure = function (_a) {
            var apiKey = _a.apiKey, endpointUrl = _a.endpointUrl, apiVersion = _a.apiVersion, noRetryIfRateLimited = _a.noRetryIfRateLimited, requestTimeout = _a.requestTimeout;
            Airtable.apiKey = apiKey;
            Airtable.endpointUrl = endpointUrl;
            Airtable.apiVersion = apiVersion;
            Airtable.noRetryIfRateLimited = noRetryIfRateLimited;
            Airtable.requestTimeout = requestTimeout;
        };
        Airtable.base = function (baseId) {
            return new Airtable().base(baseId);
        };
        Airtable.Base = base_1.default;
        Airtable.Record = record_1.default;
        Airtable.Table = table_1.default;
        Airtable.Error = airtable_error_1.default;
        return Airtable;
    }());
    module.exports = Airtable;

    },{"./airtable_error":2,"./base":3,"./record":15,"./table":17}]},{},["airtable"])("airtable")
    });
    });

    var airtable = /*@__PURE__*/getDefaultExportFromCjs(airtable_umd);

    exports.app = void 0;
    initWithAirtableContent(initSvelteApp);

    // Instantiate Svelte App with content and queryParams as props
    function initSvelteApp(actionData, schemaData, climateData){
        const queryParams = new URLSearchParams(window.location.search);

        exports.app = new App({
            target: document.body,
            props: {actionData, schemaData, climateData, queryParams}
        });
    }
    // Get Airtable + GSheet content before instantiating Svelte app
    function initWithAirtableContent(initApp){
        const apiKey = 'key3EFjfpM7LqvZGK';
        const dataBase = new airtable({apiKey}).base('appBfnKX8Pf8oHvRt');
        const airtableData = {};

        // Schema data
        for (const tableName of Object.keys(schema) ){
            dataBase(`s_${tableName}`).select({
                maxRecords: 50,
                view: "Grid view",
            }).eachPage(function page(records, fetchNextPage) {
                records.forEach(record => {
                    const cleanRecord = {}; 
                    for( const field of schema[tableName].fields){
                        cleanRecord[field] = record.fields[field];
                    }
                    schema[tableName].data.push(cleanRecord); 
                });
                fetchNextPage();
            });
        }
        // Content database
        const dataTableNames = ['Adaptation actions', 'Stakeholders', 'References'];
        for (const tableName of dataTableNames) {
            airtableData[tableName] = [];
            dataBase(tableName).select({
                maxRecords: 200,
                sort: [{field: "Name", direction: "asc"}]
            }).eachPage(function page(records, fetchNextPage) {
                records.forEach(record => airtableData[tableName].push(record.fields) );
                fetchNextPage();
            }).then( async() => {
            

                //////////// Load climate data from GSheet TSV
                const loadedClimateData =  await tsv("https://docs.google.com/spreadsheets/d/e/2PACX-1vS86VEQlm8KI0g0b_thIlz8boNSfWwO5xZgA_8wLOEfjgygRUR0WEVHnBD2kh9EgbgJqyKuKdkwn-F3/pub?gid=0&single=true&output=tsv");

                // Parse and shape data to numbers
                const climateData = {
                    schema: {
                        scenarios:  ["RCP4.5", "RCP8.5"],
                        seasons:    ["Annual", "Summer", "Autumn", "Winter", "Spring"],
                        years:      [2030, 2050, 2070, 2090],
                        variables:  [...new Set(loadedClimateData.map(d => d.Variable))],
                        estimates:  ["Median", "Lower", "Upper"]
                    },
                    variables: {
                        projectedChange: {}
                    } 
                };

                for(const d of loadedClimateData){
                    for(const scenario of climateData.schema.scenarios){ 
                        if(!climateData.variables.projectedChange[scenario]) climateData.variables.projectedChange[scenario] = {};
                        for (const season of climateData.schema.seasons){  
                            if(!climateData.variables.projectedChange[scenario][season]) climateData.variables.projectedChange[scenario][season] = {};
                            for(const variable of climateData.schema.variables){
                                if(!climateData.variables.projectedChange[scenario][season][variable]) climateData.variables.projectedChange[scenario][season][variable] = {};
                                for(const estimate of climateData.schema.estimates){
                                    if(!climateData.variables.projectedChange[scenario][season][variable][estimate]) climateData.variables.projectedChange[scenario][season][variable][estimate] = {};
                                    for(const year of climateData.schema.years){
                                        if(d.Variable === variable && season === d.Season) {
                                            climateData.variables.projectedChange[scenario][season][variable][estimate][year] =  +d[`${year}-${scenario}_${estimate}`];
                                        }
                                    }
                                }
                            }                    
                        }
                    }
                }

                /// Call initApp
                if(tableName == dataTableNames[dataTableNames.length - 1]){
                    setTimeout(() => initApp(airtableData, schema, climateData), 1000);
                }
            }); 
        }






    }

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=bundle.js.map
